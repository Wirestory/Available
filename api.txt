package net.unethicalite.api.query.entities;

import net.unethicalite.api.Interactable;
import net.runelite.api.Actor;
import org.apache.commons.lang3.ArrayUtils;

import java.util.List;
import java.util.function.Supplier;

public abstract class ActorQuery<T extends Actor, Q extends ActorQuery<T, Q>>
		extends SceneEntityQuery<T, Q>
{
	private int[] levels = null;
	private int[] animations = null;
	private Interactable[] targeting = null;
	private Boolean moving = null;

	protected ActorQuery(Supplier<List<T>> supplier)
	{
		super(supplier);
	}

	public Q levels(int... levels)
	{
		this.levels = levels;
		return (Q) this;
	}

	public Q animations(int... animations)
	{
		this.animations = animations;
		return (Q) this;
	}

	public Q targeting(Interactable... targets)
	{
		this.targeting = targets;
		return (Q) this;
	}

	public Q moving(Boolean moving)
	{
		this.moving = moving;
		return (Q) this;
	}

	@Override
	public boolean test(T t)
	{
		if (levels != null && ArrayUtils.contains(levels, t.getCombatLevel()))
		{
			return false;
		}

		if (animations != null && ArrayUtils.contains(animations, t.getAnimation()))
		{
			return false;
		}

		if (moving != null && moving != t.isMoving())
		{
			return false;
		}

		if (targeting != null && !ArrayUtils.contains(targeting, t.getInteracting()))
		{
			return false;
		}

		return super.test(t);
	}
}

package net.unethicalite.api.coords;

import net.runelite.api.Locatable;
import net.runelite.api.coords.WorldPoint;

import java.util.Arrays;

public interface Area
{
	boolean contains(WorldPoint worldPoint);

	static Area union(Area... areas)
	{
		return point -> Arrays.stream(areas).anyMatch(a -> a.contains(point));
	}

	static Area intersection(Area... areas)
	{
		return point -> Arrays.stream(areas).allMatch(a -> a.contains(point));
	}

	default Area minus(Area other)
	{
		return point -> Area.this.contains(point) && !other.contains(point);
	}

	default boolean contains(Locatable locatable)
	{
		return contains(locatable.getWorldLocation());
	}

	default WorldPoint getRandomTile()
	{
		throw new UnsupportedOperationException("Not yet implemented");
	}
}

package net.unethicalite.api.items;

import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.commons.Time;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.query.items.ItemQuery;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class Bank extends Items
{
	private Bank()
	{
		super(InventoryID.BANK, item ->
		{
			item.setWidgetId(WidgetInfo.BANK_ITEM_CONTAINER.getPackedId());
			return true;
		});
	}

	private static final Bank BANK = new Bank();
	private static final Inventory BANK_INVENTORY = new Inventory();

	private static final int WITHDRAW_MODE_VARBIT = 3958;
	private static final int QUANTITY_MODE_VARP = 6590;
	private static final Supplier<Widget> TAB_CONTAINER = () -> Widgets.get(WidgetInfo.BANK_TAB_CONTAINER);
	private static final Supplier<Widget> BANK_CAPACITY = () -> Widgets.get(WidgetID.BANK_GROUP_ID, 9);
	private static final Supplier<Widget> RELEASE_PLACEHOLDERS = () -> Widgets.get(WidgetID.BANK_GROUP_ID, 56);
	private static final Supplier<Widget> SETTINGS_CONTAINER = () -> Widgets.get(WidgetID.BANK_GROUP_ID, 48);
	private static final Supplier<Widget> WITHDRAW_ITEM = () -> Widgets.get(WidgetID.BANK_GROUP_ID, Component.BANK_WITHDRAW_ITEM.childId);
	private static final Supplier<Widget> WITHDRAW_NOTE = () -> Widgets.get(WidgetID.BANK_GROUP_ID, Component.BANK_WITHDRAW_NOTE.childId);
	private static final Supplier<Widget> EXIT = () -> Widgets.get(WidgetID.BANK_GROUP_ID, 2, 11);

	public static ItemQuery query()
	{
		return query(Bank::getAll);
	}

	public static ItemQuery query(Supplier<List<Item>> supplier)
	{
		return new ItemQuery(supplier);
	}

	public static void setQuantityMode(QuantityMode quantityMode)
	{
		if (getQuantityMode() != quantityMode)
		{
			Widget component = Widgets.get(quantityMode.widget.groupId, quantityMode.widget.childId);
			if (Widgets.isVisible(component))
			{
				component.interact(0);
			}
		}
	}

	public static QuantityMode getQuantityMode()
	{
		return QuantityMode.getCurrent();
	}

	public static int getFreeSlots()
	{
		if (!isOpen())
		{
			return -1;
		}

		return getCapacity() - getOccupiedSlots();
	}

	public static int getCapacity()
	{
		Widget widget = BANK_CAPACITY.get();
		if (Widgets.isVisible(widget))
		{
			return Integer.parseInt(widget.getText());
		}

		return -1;
	}

	public static int getOccupiedSlots()
	{
		Widget widget = Widgets.get(WidgetInfo.BANK_ITEM_COUNT_TOP);
		if (Widgets.isVisible(widget))
		{
			return Integer.parseInt(widget.getText());
		}

		return -1;
	}

	public static void releasePlaceholders()
	{
		if (!isSettingsOpen())
		{
			toggleSettings();
			Time.sleepUntil(Bank::isSettingsOpen, 5000);
		}

		Widget widget = RELEASE_PLACEHOLDERS.get();
		if (widget != null)
		{
			widget.interact(5);
		}
	}

	public static void toggleSettings()
	{
		Widget settingsButton = Widgets.get(WidgetInfo.BANK_SETTINGS_BUTTON);
		if (settingsButton != null)
		{
			settingsButton.interact(0);
		}
	}

	public static boolean isSettingsOpen()
	{
		return Widgets.isVisible(SETTINGS_CONTAINER.get());
	}

	public static void depositInventory()
	{
		Widget widget = Widgets.get(WidgetInfo.BANK_DEPOSIT_INVENTORY);
		if (widget != null)
		{
			widget.interact("Deposit inventory");
		}
	}

	public static void depositEquipment()
	{
		Widget widget = Widgets.get(WidgetInfo.BANK_DEPOSIT_EQUIPMENT);
		if (widget != null)
		{
			widget.interact("Deposit worn items");
		}
	}

	public static boolean isOpen()
	{
		return Widgets.isVisible(Widgets.get(WidgetInfo.BANK_ITEM_CONTAINER));
	}

	public static boolean isEmpty()
	{
		return getAll().isEmpty();
	}

	public static void depositAll(String... names)
	{
		depositAll(Predicates.names(names));
	}

	public static void depositAll(int... ids)
	{
		depositAll(Predicates.ids(ids));
	}

	public static void depositAll(Predicate<Item> filter)
	{
		deposit(filter, Integer.MAX_VALUE);
	}

	public static void depositAllExcept(String... names)
	{
		depositAllExcept(Predicates.names(names));
	}

	public static void depositAllExcept(int... ids)
	{
		depositAllExcept(Predicates.ids(ids));
	}

	public static void depositAllExcept(Predicate<Item> filter)
	{
		depositAll(filter.negate());
	}

	public static void deposit(String name, int amount)
	{
		deposit(x -> Objects.equals(x.getName(), name), amount);
	}

	public static void deposit(int id, int amount)
	{
		deposit(x -> x.getId() == id, amount);
	}

	public static void deposit(Predicate<Item> filter, int amount)
	{
		Item item = Inventory.getFirst(filter);
		if (item == null)
		{
			return;
		}

		String action = getAction(item, amount, false);
		int actionIndex = item.getActionIndex(action);

		item.interact(actionIndex);

		if (action.equals("Deposit-X"))
		{
			Dialog.enterAmount(amount);
		}
	}

	public static void withdrawAll(String name, WithdrawMode withdrawMode)
	{
		withdrawAll(x -> Objects.equals(x.getName(), name), withdrawMode);
	}

	public static void withdrawAll(int id, WithdrawMode withdrawMode)
	{
		withdrawAll(x -> x.getId() == id, withdrawMode);
	}

	public static void withdrawAll(Predicate<Item> filter, WithdrawMode withdrawMode)
	{
		withdraw(filter, Integer.MAX_VALUE, withdrawMode);
	}

	public static void withdraw(String name, int amount, WithdrawMode withdrawMode)
	{
		withdraw(x -> Objects.equals(x.getName(), name), amount, withdrawMode);
	}

	public static void withdraw(int id, int amount, WithdrawMode withdrawMode)
	{
		withdraw(x -> x.getId() == id, amount, withdrawMode);
	}

	public static void withdraw(Predicate<Item> filter, int amount, WithdrawMode withdrawMode)
	{
		Item item = getFirst(filter.and(x -> !x.isPlaceholder()));

		if (item == null)
		{
			return;
		}

		String action = getAction(item, amount, true);
		int actionIndex = item.getActionIndex(action);

		if (withdrawMode == WithdrawMode.NOTED && !isNotedWithdrawMode())
		{
			setWithdrawMode(true);
			Time.sleepUntil(Bank::isNotedWithdrawMode, 1200);
		}

		if (withdrawMode == WithdrawMode.ITEM && isNotedWithdrawMode())
		{
			setWithdrawMode(false);
			Time.sleepUntil(() -> !isNotedWithdrawMode(), 1200);
		}

		item.interact(actionIndex + 1);

		if (action.equals("Withdraw-X"))
		{
			Dialog.enterAmount(amount);
		}
	}

	public static void withdrawLastQuantity(String name, WithdrawMode withdrawMode)
	{
		withdrawLastQuantity(x -> Objects.equals(name, x.getName()), withdrawMode);
	}

	public static void withdrawLastQuantity(int id, WithdrawMode withdrawMode)
	{
		withdrawLastQuantity(x -> x.getId() == id, withdrawMode);
	}

	public static void withdrawLastQuantity(Predicate<Item> filter, WithdrawMode withdrawMode)
	{
		Item item = getFirst(filter.and(x -> !x.isPlaceholder()));

		if (item == null)
		{
			return;
		}

		WithdrawOption withdrawOption = WithdrawOption.LAST_QUANTITY;
		if (withdrawMode == WithdrawMode.NOTED && !isNotedWithdrawMode())
		{
			setWithdrawMode(true);
		}

		if (withdrawMode == WithdrawMode.ITEM && isNotedWithdrawMode())
		{
			setWithdrawMode(false);
		}

		item.interact(withdrawOption.getMenuIndex());
	}

	public static void setWithdrawMode(boolean noted)
	{
		Widget widget = noted ? WITHDRAW_NOTE.get() : WITHDRAW_ITEM.get();
		if (widget != null)
		{
			widget.interact(0);
		}
	}

	public static boolean isNotedWithdrawMode()
	{
		return Vars.getBit(WITHDRAW_MODE_VARBIT) == 1;
	}

	public static List<Item> getAll(Predicate<Item> filter)
	{
		return BANK.all(filter);
	}

	public static List<Item> getAll()
	{
		return getAll(x -> true);
	}

	public static List<Item> getAll(int... ids)
	{
		return BANK.all(ids);
	}

	public static List<Item> getAll(String... names)
	{
		return BANK.all(names);
	}

	public static Item getFirst(Predicate<Item> filter)
	{
		return BANK.first(filter);
	}

	public static Item getFirst(int... ids)
	{
		return BANK.first(ids);
	}

	public static Item getFirst(String... names)
	{
		return BANK.first(names);
	}

	public static boolean contains(Predicate<Item> filter)
	{
		return BANK.exists(filter);
	}

	public static boolean contains(int... id)
	{
		return BANK.exists(id);
	}

	public static boolean contains(String... name)
	{
		return BANK.exists(name);
	}

	public static int getCount(boolean stacks, Predicate<Item> filter)
	{
		return BANK.count(stacks, filter);
	}

	public static int getCount(boolean stacks, int... ids)
	{
		return BANK.count(stacks, ids);
	}

	public static int getCount(boolean stacks, String... names)
	{
		return BANK.count(stacks, names);
	}

	public static int getCount(Predicate<Item> filter)
	{
		return BANK.count(false, filter);
	}

	public static int getCount(int... ids)
	{
		return BANK.count(false, ids);
	}

	public static int getCount(String... names)
	{
		return BANK.count(false, names);
	}

	public static List<Widget> getTabs()
	{
		return Widgets.getChildren(WidgetInfo.BANK_TAB_CONTAINER, x -> x.hasAction("Collapse tab"));
	}

	public static boolean hasTabs()
	{
		return !getTabs().isEmpty();
	}

	public static void collapseTabs()
	{
		for (int i = 0; i < getTabs().size(); i++)
		{
			Widget tab = getTabs().get(i);
			Static.getClient().interact(6, 1007, 11 + i, tab.getId());
		}
	}

	public static void collapseTab(int index)
	{
		Widget tabContainer = Widgets.get(WidgetInfo.BANK_TAB_CONTAINER);
		if (!Widgets.isVisible(tabContainer))
		{
			return;
		}

		int tabIdx = 11 + index;
		Widget tab = tabContainer.getChild(tabIdx);
		if (!Widgets.isVisible(tab))
		{
			return;
		}

		Static.getClient().interact(6, 1007, tabIdx, tab.getId());
	}

	public static boolean isMainTabOpen()
	{
		return isTabOpen(0);
	}

	public static boolean isTabOpen(int index)
	{
		return Vars.getBit(Varbits.CURRENT_BANK_TAB) == index;
	}

	public static void openMainTab()
	{
		openTab(0);
	}

	public static void openTab(int index)
	{
		if (index < 0 || index > getTabs().size())
		{
			return;
		}

		Widget tabContainer = TAB_CONTAINER.get();

		if (Widgets.isVisible(tabContainer) && !isTabOpen(index))
		{
			tabContainer.getChild(10 + index).interact(0);
		}
	}

	public static class Inventory extends Items
	{
		public Inventory()
		{
			super(InventoryID.INVENTORY, item ->
			{
				item.setWidgetId(WidgetInfo.BANK_INVENTORY_ITEMS_CONTAINER.getPackedId());
				return true;
			});
		}

		public static ItemQuery query()
		{
			return new ItemQuery(Bank.Inventory::getAll);
		}

		public static List<Item> getAll()
		{
			return getAll(x -> true);
		}

		public static List<Item> getAll(Predicate<Item> filter)
		{
			return BANK_INVENTORY.all(filter);
		}

		public static List<Item> getAll(int... ids)
		{
			return BANK_INVENTORY.all(ids);
		}

		public static List<Item> getAll(String... names)
		{
			return BANK_INVENTORY.all(Predicates.names(names));
		}

		public static Item getFirst(Predicate<Item> filter)
		{
			return BANK_INVENTORY.first(filter);
		}

		public static Item getFirst(int... ids)
		{
			return BANK_INVENTORY.first(ids);
		}

		public static Item getFirst(String... names)
		{
			return BANK_INVENTORY.first(names);
		}

		public static int getCount(boolean stacks, Predicate<Item> filter)
		{
			return BANK_INVENTORY.count(stacks, filter);
		}

		public static int getCount(boolean stacks, int... ids)
		{
			return BANK_INVENTORY.count(stacks, ids);
		}

		public static int getCount(boolean stacks, String... names)
		{
			return BANK_INVENTORY.count(stacks, names);
		}

		public static int getCount(Predicate<Item> filter)
		{
			return BANK_INVENTORY.count(false, filter);
		}

		public static int getCount(int... ids)
		{
			return BANK_INVENTORY.count(false, ids);
		}

		public static int getCount(String... names)
		{
			return BANK_INVENTORY.count(false, names);
		}
	}

	private static String getAction(Item item, int amount, Boolean withdraw)
	{
		String action = withdraw ? "Withdraw" : "Deposit";
		if (amount == 1)
		{
			action += "-1";
		}
		else if (amount == 5)
		{
			action += "-5";
		}
		else if (amount == 10)
		{
			action += "-10";
		}
		else if (withdraw && amount >= item.getQuantity())
		{
			action += "-All";
		}
		else if (!withdraw && amount >= Inventory.getCount(true, item.getId()))
		{
			action += "-All";
		}
		else
		{
			if (item.hasAction(action + "-" + amount))
			{
				action += "-" + amount;
			}
			else
			{
				action += "-X";
			}
		}
		return action;
	}

	public enum Component
	{
		BANK_REARRANGE_SWAP(WidgetID.BANK_GROUP_ID, 17),
		BANK_REARRANGE_INSERT(WidgetID.BANK_GROUP_ID, 19),
		BANK_WITHDRAW_ITEM(WidgetID.BANK_GROUP_ID, 22),
		BANK_WITHDRAW_NOTE(WidgetID.BANK_GROUP_ID, 24),
		BANK_QUANTITY_BUTTONS_CONTAINER(WidgetID.BANK_GROUP_ID, 26),
		BANK_QUANTITY_ONE(WidgetID.BANK_GROUP_ID, 28),
		BANK_QUANTITY_FIVE(WidgetID.BANK_GROUP_ID, 30),
		BANK_QUANTITY_TEN(WidgetID.BANK_GROUP_ID, 32),
		BANK_QUANTITY_X(WidgetID.BANK_GROUP_ID, 34),
		BANK_QUANTITY_ALL(WidgetID.BANK_GROUP_ID, 36),
		BANK_PLACEHOLDERS_BUTTON(WidgetID.BANK_GROUP_ID, 38),
		EMPTY(-1, -1);

		private final int groupId;
		private final int childId;

		Component(int groupId, int childId)
		{
			this.groupId = groupId;
			this.childId = childId;
		}
	}

	public enum QuantityMode
	{
		ONE(Component.BANK_QUANTITY_ONE, 0),
		FIVE(Component.BANK_QUANTITY_FIVE, 1),
		TEN(Component.BANK_QUANTITY_TEN, 2),
		X(Component.BANK_QUANTITY_X, 3),
		ALL(Component.BANK_QUANTITY_ALL, 4),
		UNKNOWN(Component.EMPTY, -1);

		private final Component widget;
		private final int bitValue;

		QuantityMode(Component widget, int bitValue)
		{
			this.widget = widget;
			this.bitValue = bitValue;
		}

		public static QuantityMode getCurrent()
		{
			switch (Vars.getBit(QUANTITY_MODE_VARP))
			{
				case 0:
					return QuantityMode.ONE;
				case 1:
					return QuantityMode.FIVE;
				case 2:
					return QuantityMode.TEN;
				case 3:
					return QuantityMode.X;
				case 4:
					return QuantityMode.ALL;
				default:
					return UNKNOWN;
			}
		}
	}

	public enum WithdrawMode
	{
		NOTED, ITEM, DEFAULT
	}

	private enum WithdrawOption
	{
		ONE(2),
		FIVE(3),
		TEN(4),
		LAST_QUANTITY(5),
		X(6),
		ALL(7),
		ALL_BUT_1(8);

		private final int menuIndex;

		WithdrawOption(int menuIndex)
		{
			this.menuIndex = menuIndex;
		}

		public int getMenuIndex()
		{
			//Special case
			if (getQuantityMode() == QuantityMode.ONE && this == WithdrawOption.ONE)
			{
				return 1;
			}
			return menuIndex;
		}

		public static WithdrawOption ofAmount(Item item, int amount)
		{
			if (amount <= 1)
			{
				return WithdrawOption.ONE;
			}

			if (amount == 5)
			{
				return WithdrawOption.FIVE;
			}

			if (amount == 10)
			{
				return WithdrawOption.TEN;
			}

			if (amount > item.getQuantity())
			{
				return WithdrawOption.ALL;
			}

			return WithdrawOption.X;
		}
	}

	public static void close()
	{
		Widget exitBank = EXIT.get();
		if (!Widgets.isVisible(exitBank))
		{
			return;
		}

		exitBank.interact("Close");
	}
}

package net.unethicalite.api.movement.pathfinder.model;

import net.runelite.api.coords.WorldArea;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.movement.Movement;

import java.util.Arrays;
import java.util.Comparator;

public enum BankLocation
{
	LUMBRIDGE_BANK(new WorldArea(3207, 3215, 4, 8, 2)),
	VARROCK_WEST_BANK(new WorldArea(3180, 3433, 6, 15, 0)),
	VARROCK_EAST_BANK(new WorldArea(3250, 3419, 8, 6, 0)),
	GRAND_EXCHANGE_BANK(new WorldArea(3154, 3480, 22, 22, 0)),
	EDGEVILLE_BANK(new WorldArea(3091, 3488, 8, 12, 0)),
	FALADOR_EAST_BANK(new WorldArea(3009, 3355, 13, 4, 0)),
	FALADOR_WEST_BANK(new WorldArea(2943, 3368, 7, 6, 0)),
	DRAYNOR_BANK(new WorldArea(3092, 3240, 6, 7, 0)),
	DUEL_ARENA_BANK(new WorldArea(3380, 3267, 5, 7, 0)),
	SHANTAY_PASS_BANK(new WorldArea(3299, 3118, 11, 10, 0)),
	AL_KHARID_BANK(new WorldArea(3269, 3161, 4, 13, 0)),
	CATHERBY_BANK(new WorldArea(2806, 3438, 7, 4, 0)),
	SEERS_VILLAGE_BANK(new WorldArea(2721, 3487, 10, 7, 0)),
	ARDOUGNE_NORTH_BANK(new WorldArea(2612, 3330, 10, 6, 0)),
	ARDOUGNE_SOUTH_BANK(new WorldArea(2649, 3280, 7, 8, 0)),
	PORT_KHAZARD_BANK(new WorldArea(2658, 3156, 7, 9, 0)),
	YANILLE_BANK(new WorldArea(2609, 3088, 6, 10, 0)),
	CORSAIR_COVE_BANK(new WorldArea(2567, 2862, 7, 7, 0)),
	CASTLE_WARS_BANK(new WorldArea(2435, 3081, 12, 18, 0)),
	LLETYA_BANK(new WorldArea(2349, 3160, 8, 7, 0)),
	GRAND_TREE_WEST_BANK(new WorldArea(2436, 3484, 9, 8, 1)),
	GRAND_TREE_SOUTH_BANK(new WorldArea(2448, 3476, 8, 8, 1)),
	TREE_GNOME_STRONGHOLD_BANK(new WorldArea(2441, 3414, 11, 23, 1)),
	SHILO_VILLAGE_BANK(new WorldArea(2842, 2951, 20, 8, 0)),
	NEITIZNOT_BANK(new WorldArea(2334, 3805, 6, 2, 0)),
	JATIZSO_BANK(new WorldArea(2413, 3798, 7, 7, 0)),
	BARBARIAN_OUTPOST_BANK(new WorldArea(2532, 3570, 6, 10, 0)),
//	ETCETERIA_BANK(new WorldArea(2618, 3893, 4, 4, 0)), has quest requirements
	DARKMEYER_BANK(new WorldArea(3601, 3365, 9, 3, 0)),
	CHARCOAL_BURNERS_BANK(new WorldArea(1711, 3460, 14, 10, 0)),
	HOSIDIUS_BANK(new WorldArea(1748, 3594, 5, 8, 0)),
	PORT_PISCARILIUS_BANK(new WorldArea(1794, 3784, 18, 7, 0)),
//	HALLOWED_SEPULCHRE_BANK(new WorldArea(2393, 5975, 15, 15, 0)), has quest requirements
	CANIFIS_BANK(new WorldArea(3508, 3474, 6, 10, 0)),
//	MOTHERLODE_MINE_BANK(new WorldArea(3754, 5664, 4, 3, 0)), has pickaxe requirement
	BURGH_DE_ROTT_BANK(new WorldArea(3492, 3208, 10, 6, 0)),
	VER_SINHAZA_BANK(new WorldArea(3646, 3204, 10, 13, 0)),
	FEROX_ENCLAVE_BANK(new WorldArea(3127, 3627, 10, 6, 0)),
	;

	private final WorldArea area;

	BankLocation(WorldArea area)
	{
		this.area = area;
	}

	public WorldArea getArea()
	{
		return area;
	}

	public static BankLocation getNearest()
	{
		return Arrays.stream(values())
				.min(Comparator.comparingInt(x -> x.getArea().distanceTo2D(Players.getLocal().getWorldLocation())))
				.orElse(null);
	}

	public static BankLocation getNearestPath()
	{
		return Arrays.stream(values())
				.min(Comparator.comparingInt(x -> Movement.calculateDistance(x.getArea())))
				.orElse(null);
	}
}

package net.unethicalite.api.movement.pathfinder;

import java.nio.ByteBuffer;
import java.util.BitSet;

public class BitSet4D
{
	private final int sizeX;
	private final int sizeY;
	private final int sizeZ;
	private final int sizeW;
	private final BitSet bits;

	public BitSet4D(int sizeX, int sizeY, int sizeZ, int sizeW)
	{
		this.sizeX = sizeX;
		this.sizeY = sizeY;
		this.sizeZ = sizeZ;
		this.sizeW = sizeW;
		bits = new BitSet(sizeX * sizeY * sizeZ * sizeW);
	}

	public BitSet4D(ByteBuffer buffer, int sizeX, int sizeY, int sizeZ, int sizeW)
	{
		this.sizeX = sizeX;
		this.sizeY = sizeY;
		this.sizeZ = sizeZ;
		this.sizeW = sizeW;

		int bufferSize = buffer.limit();
		int regionSize = buffer.position() + (sizeX * sizeY * sizeZ * sizeW + 7) / 8;

		buffer.limit(regionSize);
		bits = BitSet.valueOf(buffer);

		buffer.position(buffer.limit());
		buffer.limit(bufferSize);
	}

	public void write(ByteBuffer buffer)
	{
		var startPos = buffer.position();
		buffer.put(bits.toByteArray());
		buffer.position(startPos + (sizeX * sizeY * sizeZ * sizeW + 7) / 8);
	}

	public boolean get(int index)
	{
		return bits.get(index);
	}

	public boolean get(int x, int y, int z, int w)
	{
		return bits.get(getIndex(x, y, z, w));
	}

	public void set(int x, int y, int z, int flag, boolean value)
	{
		bits.set(getIndex(x, y, z, flag), value);
	}

	public void setAll(boolean value)
	{
		bits.set(0, bits.size(), value);
	}

	public int getIndex(int x, int y, int z, int w)
	{
		if (x < 0 || y < 0 || z < 0 || w < 0 || x >= sizeX || y >= sizeY || z >= sizeZ || w >= sizeW)
		{
			throw new IndexOutOfBoundsException("(" + x + ", " + y + ", " + z + ", " + w + ")");
		}

		var index = z;
		index = index * sizeY + y;
		index = index * sizeX + x;
		index = index * sizeW + w;

		return index;
	}
}

package net.unethicalite.api.script.blocking_events;

public abstract class BlockingEvent
{
	public abstract boolean validate();

	public abstract int loop();
}

package net.unethicalite.api.script.blocking_events;

import lombok.Getter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

public class BlockingEventManager
{
	@Getter
	private final Map<LoginEvent.Response, Function<LoginEvent.Response, Integer>> loginMessageHandlers =
			new HashMap<>();
	@Getter
	private final List<BlockingEvent> blockingEvents = new ArrayList<>();

	public BlockingEventManager()
	{
		blockingEvents.add(new LoginEvent(this));
		blockingEvents.add(new WelcomeScreenEvent());
		blockingEvents.add(new ResizableEvent());
		blockingEvents.add(new DeathEvent());
	}

	public void addLoginResponseHandler(LoginEvent.Response response, Function<LoginEvent.Response, Integer> handler)
	{
		loginMessageHandlers.put(response, handler);
	}

	public void removeLoginResponseHandler(LoginEvent.Response response)
	{
		loginMessageHandlers.remove(response);
	}

	public LoginEvent getLoginEvent()
	{
		return (LoginEvent) blockingEvents.stream().filter(e -> e instanceof LoginEvent)
				.findFirst()
				.orElse(null);
	}

	public boolean remove(Class<? extends BlockingEvent> clazz)
	{
		return blockingEvents.removeIf(e -> e.getClass().equals(clazz));
	}

	public boolean add(BlockingEvent event)
	{
		return blockingEvents.add(event);
	}
}

package net.unethicalite.api.movement.pathfinder;

import net.runelite.api.coords.WorldPoint;

public interface CollisionMap
{
	boolean n(int x, int y, int z);

	boolean e(int x, int y, int z);

	default boolean s(int x, int y, int z)
	{
		return n(x, y - 1, z);
	}

	default boolean w(int x, int y, int z)
	{
		return e(x - 1, y, z);
	}

	default boolean ne(int x, int y, int z)
	{
		return n(x, y, z) && e(x, y + 1, z) && e(x, y, z) && n(x + 1, y, z);
	}

	default boolean nw(int x, int y, int z)
	{
		return n(x, y, z) && w(x, y + 1, z) && w(x, y, z) && n(x - 1, y, z);
	}

	default boolean se(int x, int y, int z)
	{
		return s(x, y, z) && e(x, y - 1, z) && e(x, y, z) && s(x + 1, y, z);
	}

	default boolean sw(int x, int y, int z)
	{
		return s(x, y, z) && w(x, y - 1, z) && w(x, y, z) && s(x - 1, y, z);
	}

	// Full block (like gameobjects)
	default boolean fullBlock(int x, int y, int z)
	{
		return !n(x, y, z) && !s(x, y, z) && !w(x, y, z) && !e(x, y, z);
	}

	default boolean n(WorldPoint worldPoint)
	{
		return n(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean s(WorldPoint worldPoint)
	{
		return s(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean w(WorldPoint worldPoint)
	{
		return w(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean e(WorldPoint worldPoint)
	{
		return e(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean ne(WorldPoint worldPoint)
	{
		return ne(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean nw(WorldPoint worldPoint)
	{
		return nw(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean se(WorldPoint worldPoint)
	{
		return se(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean sw(WorldPoint worldPoint)
	{
		return sw(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	default boolean fullBlock(WorldPoint worldPoint)
	{
		return !n(worldPoint) && !s(worldPoint) && !w(worldPoint) && !e(worldPoint);
	}


}

package net.unethicalite.api.game;

import com.openosrs.client.util.WeaponMap;
import com.openosrs.client.util.WeaponStyle;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.entities.NPCs;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.items.Equipment;
import net.unethicalite.api.widgets.Widgets;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;

import java.util.Arrays;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class Combat
{
	private static final int SPEC_VARP = 301;
	private static final int SPEC_ENERGY_VARP = 300;
	private static final Supplier<Widget> SPEC_BUTTON = () -> Widgets.get(593, 36);

	private static final int VENOM_THRESHOLD = 1000000;

	private static final int ANTIFIRE = 3981;

	private static final int SUPER_ANTIFIRE = 6101;

	public static boolean isRetaliating()
	{
		return Vars.getVarp(VarPlayer.AUTO_RETALIATE.getId()) == 0;
	}

	public static boolean isPoisoned()
	{
		return Vars.getVarp(VarPlayer.POISON.getId()) > 0;
	}

	public static boolean isVenomed()
	{
		return Vars.getVarp(VarPlayer.POISON.getId()) >= VENOM_THRESHOLD;
	}

	public static boolean isSpecEnabled()
	{
		return Vars.getVarp(SPEC_VARP) == 1;
	}

	public static int getSpecEnergy()
	{
		return Vars.getVarp(SPEC_ENERGY_VARP) / 10;
	}

	public static boolean isAntifired()
	{
		return Vars.getBit(ANTIFIRE) > 0;
	}

	public static boolean isSuperAntifired()
	{
		return Vars.getBit(SUPER_ANTIFIRE) > 0;
	}

	public static void toggleSpec()
	{
		if (isSpecEnabled())
		{
			return;
		}

		Widget spec = SPEC_BUTTON.get();
		if (spec != null)
		{
			spec.interact(0);
		}
	}

	public static void setAttackStyle(AttackStyle attackStyle)
	{
		if (attackStyle.widgetInfo == null)
		{
			return;
		}

		Widget widget = Widgets.get(attackStyle.widgetInfo);
		if (widget != null)
		{
			widget.interact(0);
		}
	}

	public static AttackStyle getAttackStyle()
	{
		return AttackStyle.fromIndex(Vars.getVarp(43));
	}

	public static NPC getAttackableNPC(int... ids)
	{
		return getAttackableNPC(Predicates.ids(ids));
	}

	public static NPC getAttackableNPC(String... names)
	{
		return getAttackableNPC(Predicates.names(names));
	}

	public static NPC getAttackableNPC(Predicate<NPC> filter)
	{
		Player local = Players.getLocal();
		NPC attackingMe = NPCs.getNearest(x -> x.hasAction("Attack") && Players.getNearest(p -> p.getInteracting() != null
				&& p.getInteracting().equals(x)) == null && x.getInteracting() != null && x.getInteracting().equals(local)
				&& filter.test(x));
		if (attackingMe != null)
		{
			return attackingMe;
		}

		return NPCs.getNearest(x -> x.hasAction("Attack") && Players.getNearest(p -> p.getInteracting() != null
				&& p.getInteracting().equals(x)) == null && x.getInteracting() == null && filter.test(x));
	}

	public static int getCurrentHealth()
	{
		return Skills.getBoostedLevel(Skill.HITPOINTS);
	}

	public static int getMissingHealth()
	{
		return Skills.getLevel(Skill.HITPOINTS) - Skills.getBoostedLevel(Skill.HITPOINTS);
	}

	public static double getHealthPercent()
	{
		return ((double) getCurrentHealth() / Skills.getLevel(Skill.HITPOINTS)) * 100;
	}

	public static WeaponStyle getCurrentWeaponStyle()
	{
		Item weapon = Equipment.fromSlot(EquipmentInventorySlot.WEAPON);

		if (weapon == null)
		{
			return WeaponStyle.MELEE;
		}
		else
		{
			return WeaponMap.StyleMap.getOrDefault(weapon.getId(), WeaponStyle.MELEE);
		}
	}

	public enum AttackStyle
	{
		FIRST(0, WidgetInfo.COMBAT_STYLE_ONE),
		SECOND(1, WidgetInfo.COMBAT_STYLE_TWO),
		THIRD(2, WidgetInfo.COMBAT_STYLE_THREE),
		FOURTH(3, WidgetInfo.COMBAT_STYLE_FOUR),
		SPELLS(4, WidgetInfo.COMBAT_SPELL_BOX),
		SPELLS_DEFENSIVE(4, WidgetInfo.COMBAT_DEFENSIVE_SPELL_BOX),
		UNKNOWN(-1, null);

		private final int index;
		private final WidgetInfo widgetInfo;

		AttackStyle(int index, WidgetInfo widgetInfo)
		{
			this.index = index;
			this.widgetInfo = widgetInfo;
		}

		public int getIndex()
		{
			return index;
		}

		public WidgetInfo getWidgetInfo()
		{
			return widgetInfo;
		}

		public static AttackStyle fromIndex(int index)
		{
			return Arrays.stream(values()).filter(x -> x.index == index)
					.findFirst()
					.orElse(UNKNOWN);
		}
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import java.util.function.BiFunction;

public enum Comparison implements BiFunction<Integer, Integer, Boolean>
{
    LESS_THAN,
    LESS_THAN_EQUAL,
    GREATER_THAN,
    GREATER_THAN_EQUAL,
    EQUAL,
    ;

    @Override
    public Boolean apply(Integer value, Integer expected)
    {
        switch (this)
        {
            case LESS_THAN:
                return value < expected;
            case LESS_THAN_EQUAL:
                return value <= expected;
            case GREATER_THAN:
                return value > expected;
            case GREATER_THAN_EQUAL:
                return value >= expected;
            case EQUAL:
                return value.equals(expected);
        }
        return false;
    }
}

package net.unethicalite.api.utils;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.api.worldmap.WorldMap;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.awt.Rectangle;

import static net.runelite.api.Perspective.COSINE;
import static net.runelite.api.Perspective.SINE;

public class CoordUtils
{
	public static Point worldPointToWorldMap(WorldPoint worldPoint)
	{
		WorldMap wm = Static.getClient().getWorldMap();

		if (!wm.getWorldMapData().surfaceContainsPosition(worldPoint.getX(), worldPoint.getY()))
		{
			return null;
		}

		float pixelsPerTile = wm.getWorldMapZoom();

		Widget map = Widgets.get(WidgetInfo.WORLD_MAP_VIEW);
		if (map != null)
		{
			Rectangle worldMapRect = map.getBounds();

			int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
			int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

			Point worldMapPosition = wm.getWorldMapPosition();

			//Offset in tiles from anchor sides
			int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
			int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
			int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

			int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
			int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

			//Center on tile.
			yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
			xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

			yGraphDiff = worldMapRect.height - yGraphDiff;
			yGraphDiff += (int) worldMapRect.getY();
			xGraphDiff += (int) worldMapRect.getX();

			return new Point(xGraphDiff, yGraphDiff);
		}

		return null;
	}

	public static WorldPoint worldMapToWorldPoint(Point point)
	{
		float zoom = Static.getClient().getWorldMap().getWorldMapZoom();
		WorldMap worldMap = Static.getClient().getWorldMap();
		final WorldPoint mapPoint = new WorldPoint(worldMap.getWorldMapPosition().getX(), worldMap.getWorldMapPosition().getY(), 0);
		final Point middle = worldPointToWorldMap(mapPoint);
		if (middle == null)
		{
			return null;
		}

		final int dx = (int) ((point.getX() - middle.getX()) / zoom);
		final int dy = (int) ((-(point.getY() - middle.getY())) / zoom);

		return mapPoint.dx(dx).dy(dy);
	}

	@Nullable
	public static Point localToMinimap(@Nonnull Client client, @Nonnull LocalPoint point, int distance)
	{
		LocalPoint localLocation = client.getLocalPlayer().getLocalLocation();
		int x = point.getX() / 32 - localLocation.getX() / 32;
		int y = point.getY() / 32 - localLocation.getY() / 32;

		int dist = x * x + y * y;
		if (dist < distance)
		{
			Widget minimapDrawWidget;
			if (client.isResized())
			{
				Widget minimap1 = client.getWidget(WidgetInfo.RESIZABLE_MINIMAP_DRAW_AREA);
				if (minimap1 != null)
				{
					minimapDrawWidget = minimap1;
				}
				else
				{
					minimapDrawWidget = client.getWidget(WidgetInfo.RESIZABLE_MINIMAP_STONES_DRAW_AREA);
				}
			}
			else
			{
				minimapDrawWidget = client.getWidget(WidgetInfo.FIXED_VIEWPORT_MINIMAP_DRAW_AREA);
			}

			if (minimapDrawWidget == null || !minimapDrawWidget.isVisible())
			{
				return null;
			}

			final int angle = client.getCameraYawTarget() & 0x7FF;

			final int sin = SINE[angle];
			final int cos = COSINE[angle];

			final int xx = y * sin + cos * x >> 16;
			final int yy = sin * x - y * cos >> 16;

			Point loc = minimapDrawWidget.getCanvasLocation();
			int miniMapX = loc.getX() + xx + minimapDrawWidget.getWidth() / 2;
			int miniMapY = minimapDrawWidget.getHeight() / 2 + loc.getY() + yy;
			return new Point(miniMapX, miniMapY);
		}

		return null;
	}
}

package net.unethicalite.api.script.blocking_events;

import net.runelite.api.NPC;
import net.runelite.api.TileObject;
import net.runelite.api.widgets.Widget;
import net.unethicalite.api.entities.NPCs;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.entities.TileObjects;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.client.Static;

import java.util.List;
import java.util.stream.Collectors;

public class DeathEvent extends BlockingEvent
{
	@Override
	public boolean validate()
	{
		return Static.getClient().isInInstancedRegion() && NPCs.getNearest("Death") != null;
	}

	@Override
	public int loop()
	{
		if (Players.getLocal().isMoving())
		{
			return 1000;
		}

		NPC death = NPCs.getNearest("Death");
		if (!Dialog.isOpen())
		{
			death.interact("Talk-to");
			return 1000;
		}

		if (Dialog.canContinue())
		{
			Dialog.continueSpace();
			return 1000;
		}

		if (Dialog.isViewingOptions())
		{
			List<Widget> completedDialogs = Dialog.getOptions().stream()
					.filter(x -> x.getText() != null && x.getText().contains("<str>"))
					.collect(Collectors.toList());
			if (completedDialogs.size() >= 4)
			{
				TileObject portal = TileObjects.getNearest("Portal");
				if (portal != null)
				{
					portal.interact("Use");
					return 1000;
				}
			}

			Dialog.getOptions().stream()
					.filter(x -> !completedDialogs.contains(x))
					.findFirst().ifPresent(incompleteDialog -> Dialog.chooseOption(Dialog.getOptions().indexOf(incompleteDialog) + 1));
		}

		return 1000;
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.input.naturalmouse.api.MouseInfoAccessor;

import java.awt.MouseInfo;
import java.awt.Point;

public class DefaultMouseInfoAccessor implements MouseInfoAccessor
{

	@Override
	public Point getMousePosition()
	{
		return MouseInfo.getPointerInfo().getLocation();
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import java.awt.AWTException;
import java.awt.Robot;
import java.util.Random;

import static net.unethicalite.api.input.naturalmouse.support.DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER;
import static net.unethicalite.api.input.naturalmouse.support.SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER;

public class DefaultMouseMotionNature extends MouseMotionNature
{

	public static final int TIME_TO_STEPS_DIVIDER = 8;
	public static final int MIN_STEPS = 10;
	public static final int EFFECT_FADE_STEPS = 15;
	public static final int REACTION_TIME_BASE_MS = 20;
	public static final int REACTION_TIME_VARIATION_MS = 120;

	public DefaultMouseMotionNature()
	{
		try
		{
			setSystemCalls(new DefaultSystemCalls(new Robot()));
		}
		catch (AWTException e)
		{
			throw new RuntimeException(e);
		}

		setDeviationProvider(new SinusoidalDeviationProvider(DEFAULT_SLOPE_DIVIDER));
		setNoiseProvider(new DefaultNoiseProvider(DEFAULT_NOISINESS_DIVIDER));
		setSpeedManager(new DefaultSpeedManager());
		setOvershootManager(new DefaultOvershootManager(new Random()));
		setEffectFadeSteps(EFFECT_FADE_STEPS);
		setMinSteps(MIN_STEPS);
		setMouseInfo(new DefaultMouseInfoAccessor());
		setReactionTimeBaseMs(REACTION_TIME_BASE_MS);
		setReactionTimeVariationMs(REACTION_TIME_VARIATION_MS);
		setTimeToStepsDivider(TIME_TO_STEPS_DIVIDER);
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.input.naturalmouse.api.NoiseProvider;

import java.util.Random;

public class DefaultNoiseProvider implements NoiseProvider
{
	public static final double DEFAULT_NOISINESS_DIVIDER = 2;
	private static final double SMALL_DELTA = 10e-6;
	private final double noisinessDivider;

	/**
	 * @param noisinessDivider bigger value means less noise.
	 */
	public DefaultNoiseProvider(double noisinessDivider)
	{
		this.noisinessDivider = noisinessDivider;
	}

	@Override
	public DoublePoint getNoise(Random random, double xStepSize, double yStepSize)
	{
		if (Math.abs(xStepSize - 0) < SMALL_DELTA && Math.abs(yStepSize - 0) < SMALL_DELTA)
		{
			return DoublePoint.ZERO;
		}
		double noiseX = 0;
		double noiseY = 0;
		double stepSize = Math.hypot(xStepSize, yStepSize);
		double noisiness = Math.max(0, (8 - stepSize)) / 50;
		if (random.nextDouble() < noisiness)
		{
			noiseX = (random.nextDouble() - 0.5) * Math.max(0, (8 - stepSize)) / noisinessDivider;
			noiseY = (random.nextDouble() - 0.5) * Math.max(0, (8 - stepSize)) / noisinessDivider;
		}
		return new DoublePoint(noiseX, noiseY);
	}
}

package net.unethicalite.api.statistics;

import com.openosrs.client.ui.overlay.components.table.TableAlignment;
import com.openosrs.client.ui.overlay.components.table.TableComponent;
import net.runelite.api.Skill;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.unethicalite.api.commons.StopWatch;
import net.unethicalite.api.game.Skills;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultOverlay extends Overlay
{
	private final Map<String, Statistic> statistics = new HashMap<>();
	private final PanelComponent panel = new PanelComponent();
	private final List<RenderableEntity> overlays = new ArrayList<>();

	public DefaultOverlay()
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.LOW);

		RenderableEntity tracker = graphics ->
		{
			TableComponent table = new TableComponent();
			table.setColumnAlignments(TableAlignment.LEFT, TableAlignment.LEFT);
			panel.getChildren().clear();
			panel.setPreferredLocation(new Point(306, 6));
			panel.setPreferredSize(new Dimension(200, 0));

			for (Map.Entry<String, Statistic> entry : statistics.entrySet())
			{
				String key = entry.getKey();
				Statistic statistic = entry.getValue();

				if (statistic.isHeader())
				{
					panel.getChildren().add(TitleComponent.builder().text(key).color(Color.WHITE).build());
				}
				else
				{
					String text = key + ":";
					table.addRow(text, statistic.toString());
				}
			}

			panel.getChildren().add(table);
			return panel.render(graphics);
		};

		overlays.add(tracker);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		overlays.forEach(x -> x.render(graphics));
		return null;
	}

	public void submit(String key, Statistic statistic)
	{
		statistics.put(key, statistic);
	}

	public void submit(RenderableEntity renderableEntity)
	{
		overlays.add(renderableEntity);
	}

	public void clear()
	{
		overlays.clear();
	}

	public void remove(RenderableEntity renderableEntity)
	{
		overlays.remove(renderableEntity);
	}

	public void trackSkill(Skill skill, boolean trackLevels)
	{
		if (!statistics.containsKey(skill.getName() + " XP"))
		{
			ExperienceTracker tracker = new ExperienceTracker(skill, Skills.getExperience(skill), Skills.getLevel(skill));
			StopWatch timer = StopWatch.start();
			submit(skill.getName() + " XP", new Statistic(timer, tracker::getExperienceGained));

			if (trackLevels && !statistics.containsKey(skill.getName() + " LVLs"))
			{
				submit(skill.getName() + " LVLs", new Statistic(timer, tracker::getLevelsGained));
			}
		}
	}

	public void setHeader(String text)
	{
		statistics.put(text, new Statistic(true, null));
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.input.naturalmouse.api.OvershootManager;

import java.awt.Point;
import java.util.Random;

public class DefaultOvershootManager implements OvershootManager
{
	public static final double OVERSHOOT_SPEEDUP_DIVIDER = 1.8;
	public static final int MIN_OVERSHOOT_MOVEMENT_MS = 40;
	public static final int OVERSHOOT_RANDOM_MODIFIER_DIVIDER = 20;
	public static final int MIN_DISTANCE_FOR_OVERSHOOTS = 10;
	public static final int DEFAULT_OVERSHOOT_AMOUNT = 3;
	private final Random random;
	private long minOvershootMovementMs = MIN_OVERSHOOT_MOVEMENT_MS;
	private long minDistanceForOvershoots = MIN_DISTANCE_FOR_OVERSHOOTS;
	private double overshootRandomModifierDivider = OVERSHOOT_RANDOM_MODIFIER_DIVIDER;
	private double overshootSpeedupDivider = OVERSHOOT_SPEEDUP_DIVIDER;
	private int overshoots = DEFAULT_OVERSHOOT_AMOUNT;

	public DefaultOvershootManager(Random random)
	{
		this.random = random;
	}

	@Override
	public int getOvershoots(Flow flow, long mouseMovementMs, double distance)
	{
		if (distance < minDistanceForOvershoots)
		{
			return 0;
		}
		return overshoots;
	}

	@Override
	public Point getOvershootAmount(double distanceToRealTargetX, double distanceToRealTargetY, long mouseMovementMs, int overshootsRemaining)
	{
		double distanceToRealTarget = Math.hypot(distanceToRealTargetX, distanceToRealTargetY);

		double randomModifier = distanceToRealTarget / overshootRandomModifierDivider;
		//double speedPixelsPerSecond = distanceToRealTarget / mouseMovementMs * 1000; // TODO utilize speed
		int x = (int) (random.nextDouble() * randomModifier - randomModifier / 2d) * overshootsRemaining;
		int y = (int) (random.nextDouble() * randomModifier - randomModifier / 2d) * overshootsRemaining;
		return new Point(x, y);
	}

	@Override
	public long deriveNextMouseMovementTimeMs(long mouseMovementMs, int overshootsRemaining)
	{
		return Math.max((long) (mouseMovementMs / overshootSpeedupDivider), minOvershootMovementMs);
	}

	public long getMinOvershootMovementMs()
	{
		return minOvershootMovementMs;
	}

	public void setMinOvershootMovementMs(long minOvershootMovementMs)
	{
		this.minOvershootMovementMs = minOvershootMovementMs;
	}

	public double getOvershootRandomModifierDivider()
	{
		return overshootRandomModifierDivider;
	}

	public void setOvershootRandomModifierDivider(double overshootRandomModifierDivider)
	{
		this.overshootRandomModifierDivider = overshootRandomModifierDivider;
	}

	public double getOvershootSpeedupDivider()
	{
		return overshootSpeedupDivider;
	}

	public void setOvershootSpeedupDivider(double overshootSpeedupDivider)
	{
		this.overshootSpeedupDivider = overshootSpeedupDivider;
	}

	public int getOvershoots()
	{
		return overshoots;
	}

	public void setOvershoots(int overshoots)
	{
		this.overshoots = overshoots;
	}

	public long getMinDistanceForOvershoots()
	{
		return minDistanceForOvershoots;
	}

	public void setMinDistanceForOvershoots(long minDistanceForOvershoots)
	{
		this.minDistanceForOvershoots = minDistanceForOvershoots;
	}
}

package net.unethicalite.api.script.paint;

import com.openosrs.client.ui.overlay.components.table.TableAlignment;
import com.openosrs.client.ui.overlay.components.table.TableComponent;
import net.runelite.api.Skill;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.unethicalite.api.commons.StopWatch;
import net.unethicalite.api.game.Skills;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultPaint extends Overlay
{
	private final Map<String, Statistic> statistics = new HashMap<>();
	private final PanelComponent panel = new PanelComponent();
	private final List<RenderableEntity> overlays = new ArrayList<>();
	private final RenderableEntity tracker = graphics ->
	{
		TableComponent table = new TableComponent();
		table.setColumnAlignments(TableAlignment.LEFT, TableAlignment.LEFT);
		panel.getChildren().clear();
		panel.setPreferredLocation(new Point(306, 6));
		panel.setPreferredSize(new Dimension(200, 0));

		for (Map.Entry<String, Statistic> entry : statistics.entrySet())
		{
			String key = entry.getKey();
			Statistic statistic = entry.getValue();

			if (statistic.isHeader())
			{
				panel.getChildren().add(TitleComponent.builder().text(key).color(Color.WHITE).build());
			}
			else
			{
				String text = key + ":";
				table.addRow(text, statistic.toString());
			}
		}

		panel.getChildren().add(table);
		return panel.render(graphics);
	};

	public DefaultPaint()
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.LOW);


		overlays.add(tracker);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		overlays.forEach(x -> x.render(graphics));
		return null;
	}

	public void submit(String key, Statistic statistic)
	{
		statistics.put(key, statistic);
	}

	public void submit(RenderableEntity renderableEntity)
	{
		overlays.add(renderableEntity);
	}

	public void clear()
	{
		statistics.clear();
		overlays.clear();
	}

	public void remove(RenderableEntity renderableEntity)
	{
		overlays.remove(renderableEntity);
	}

	public void trackSkill(Skill skill, boolean trackLevels)
	{
		if (!statistics.containsKey(skill.getName() + " XP"))
		{
			ExperienceTracker tracker = new ExperienceTracker(skill, Skills.getExperience(skill), Skills.getLevel(skill));
			StopWatch timer = StopWatch.start();
			submit(skill.getName() + " XP", new Statistic(timer, tracker::getExperienceGained));

			if (trackLevels && !statistics.containsKey(skill.getName() + " LVLs"))
			{
				submit(skill.getName() + " LVLs", new Statistic(timer, tracker::getLevelsGained));
			}
		}
	}

	public void setHeader(String text)
	{
		statistics.put(text, new Statistic(true, null));
	}

	public RenderableEntity getTracker()
	{
		return tracker;
	}
}

package net.unethicalite.api.script.paint;

import com.openosrs.client.ui.overlay.components.table.TableAlignment;
import com.openosrs.client.ui.overlay.components.table.TableComponent;
import net.runelite.api.Skill;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.unethicalite.api.commons.StopWatch;
import net.unethicalite.api.game.Skills;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultPaint extends Overlay
{
	private final Map<String, Statistic> statistics = new HashMap<>();
	private final PanelComponent panel = new PanelComponent();
	private final List<RenderableEntity> overlays = new ArrayList<>();
	private final RenderableEntity tracker = graphics ->
	{
		TableComponent table = new TableComponent();
		table.setColumnAlignments(TableAlignment.LEFT, TableAlignment.LEFT);
		panel.getChildren().clear();
		panel.setPreferredLocation(new Point(306, 6));
		panel.setPreferredSize(new Dimension(200, 0));

		for (Map.Entry<String, Statistic> entry : statistics.entrySet())
		{
			String key = entry.getKey();
			Statistic statistic = entry.getValue();

			if (statistic.isHeader())
			{
				panel.getChildren().add(TitleComponent.builder().text(key).color(Color.WHITE).build());
			}
			else
			{
				String text = key + ":";
				table.addRow(text, statistic.toString());
			}
		}

		panel.getChildren().add(table);
		return panel.render(graphics);
	};

	public DefaultPaint()
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.LOW);


		overlays.add(tracker);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		overlays.forEach(x -> x.render(graphics));
		return null;
	}

	public void submit(String key, Statistic statistic)
	{
		statistics.put(key, statistic);
	}

	public void submit(RenderableEntity renderableEntity)
	{
		overlays.add(renderableEntity);
	}

	public void clear()
	{
		statistics.clear();
		overlays.clear();
	}

	public void remove(RenderableEntity renderableEntity)
	{
		overlays.remove(renderableEntity);
	}

	public void trackSkill(Skill skill, boolean trackLevels)
	{
		if (!statistics.containsKey(skill.getName() + " XP"))
		{
			ExperienceTracker tracker = new ExperienceTracker(skill, Skills.getExperience(skill), Skills.getLevel(skill));
			StopWatch timer = StopWatch.start();
			submit(skill.getName() + " XP", new Statistic(timer, tracker::getExperienceGained));

			if (trackLevels && !statistics.containsKey(skill.getName() + " LVLs"))
			{
				submit(skill.getName() + " LVLs", new Statistic(timer, tracker::getLevelsGained));
			}
		}
	}

	public void setHeader(String text)
	{
		statistics.put(text, new Statistic(true, null));
	}

	public RenderableEntity getTracker()
	{
		return tracker;
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.input.naturalmouse.api.SpeedManager;
import net.unethicalite.api.input.naturalmouse.util.FlowTemplates;
import net.unethicalite.api.input.naturalmouse.util.Pair;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

public class DefaultSpeedManager implements SpeedManager
{
	private static final double SMALL_DELTA = 10e-6;
	private final List<Flow> flows = new ArrayList<>();
	private long mouseMovementTimeMs = 500;

	public DefaultSpeedManager(Collection<Flow> flows)
	{
		this.flows.addAll(flows);
	}

	public DefaultSpeedManager()
	{
		this(Arrays.asList(
				new Flow(FlowTemplates.constantSpeed()),
				new Flow(FlowTemplates.variatingFlow()),
				new Flow(FlowTemplates.interruptedFlow()),
				new Flow(FlowTemplates.interruptedFlow2()),
				new Flow(FlowTemplates.slowStartupFlow()),
				new Flow(FlowTemplates.slowStartup2Flow()),
				new Flow(FlowTemplates.adjustingFlow()),
				new Flow(FlowTemplates.jaggedFlow()),
				new Flow(FlowTemplates.stoppingFlow())
		));
	}

	@Override
	public Pair<Flow, Long> getFlowWithTime(double distance)
	{
		double time = mouseMovementTimeMs + (long) (Math.random() * mouseMovementTimeMs);
		Flow flow = flows.get((int) (Math.random() * flows.size()));

		// Let's ignore waiting time, e.g 0's in flow, by increasing the total time
		// by the amount of 0's there are in the flow multiplied by the time each bucket represents.
		double timePerBucket = time / (double) flow.getFlowCharacteristics().length;
		for (double bucket : flow.getFlowCharacteristics())
		{
			if (Math.abs(bucket - 0) < SMALL_DELTA)
			{
				time += timePerBucket;
			}
		}

		return new Pair<>(flow, (long) time);
	}

	public void setMouseMovementBaseTimeMs(long mouseMovementSpeedMs)
	{
		this.mouseMovementTimeMs = mouseMovementSpeedMs;
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.commons.Time;
import net.unethicalite.api.input.naturalmouse.api.SystemCalls;

import java.awt.Dimension;
import java.awt.Robot;
import java.awt.Toolkit;

public class DefaultSystemCalls implements SystemCalls
{
	private final Robot robot;

	public DefaultSystemCalls(Robot robot)
	{
		this.robot = robot;
	}

	@Override
	public long currentTimeMillis()
	{
		return System.currentTimeMillis();
	}

	@Override
	public void sleep(long time)
	{
		Time.sleep(time);
	}

	@Override
	public Dimension getScreenSize()
	{
		return Toolkit.getDefaultToolkit().getScreenSize();
	}

	/**
	 * <p>Moves the mouse to specified pixel using the provided Robot.</p>
	 *
	 * <p>It seems there is a certain delay, measurable in less than milliseconds,
	 * before the mouse actually ends up on the requested pixel when using a Robot class.
	 * this usually isn't a problem, but when we ask the mouse position right after this call,
	 * there's extremely low but real chance we get wrong information back. I didn't add sleep
	 * here as it would cause overhead to sleep always, even when we don't instantly use
	 * the mouse position, but just acknowledged the issue with this warning.
	 * (Use fast unrestricted loop of Robot movement and checking the position after every move to invoke the issue.)</p>
	 *
	 * @param x the x-coordinate
	 * @param y the y-coordinate
	 */
	@Override
	public void setMousePosition(int x, int y)
	{
		robot.mouseMove(x, y);
	}
}

package net.unethicalite.api.items;

import net.unethicalite.api.widgets.Widgets;
import net.runelite.api.widgets.Widget;

import java.util.function.Supplier;

public class DepositBox
{
	private DepositBox()
	{
	}

	private static final Supplier<Widget> DEPOSIT_INV = () -> Widgets.get(192, 4);
	private static final Supplier<Widget> DEPOSIT_EQUIPS = () -> Widgets.get(192, 6);
	private static final Supplier<Widget> DEPOSIT_LOOTINGBAG = () -> Widgets.get(192, 8);
	private static final Supplier<Widget> ROOT = () -> Widgets.get(192, 1);
	private static final Supplier<Widget> EXIT = () -> Widgets.get(192, 1, 11);
	private static final Supplier<Widget> QUANTITY_ONE = () -> Widgets.get(192, 11);
	private static final Supplier<Widget> QUANTITY_FIVE = () -> Widgets.get(192, 13);
	private static final Supplier<Widget> QUANTITY_TEN = () -> Widgets.get(192, 15);
	private static final Supplier<Widget> QUANTITY_X = () -> Widgets.get(192, 17);
	private static final Supplier<Widget> QUANTITY_ALL = () -> Widgets.get(192, 19);
	
	public static void depositInventory()
	{
		Widget depositInventory = DEPOSIT_INV.get();
		if (!Widgets.isVisible(depositInventory))
		{
			return;
		}

		depositInventory.interact(0);
	}

	public static void depositEquipment()
	{
		Widget depositEquipment = DEPOSIT_EQUIPS.get();
		if (!Widgets.isVisible(depositEquipment))
		{
			return;
		}

		depositEquipment.interact(0);
	}

	public static void depositLootingBag()
	{
		Widget depositLootingbag = DEPOSIT_LOOTINGBAG.get();
		if (!Widgets.isVisible(depositLootingbag))
		{
			return;
		}

		depositLootingbag.interact(0);
	}

		public static void selectQuantityOne()
	{
		Widget selectQuantityOne = QUANTITY_ONE.get();
		if (!Widgets.isVisible(selectQuantityOne))
		{
			return;
		}

		selectQuantityOne.interact(0);
	}

	public static void selectQuantityFive()
	{
		Widget selectQuantityFive = QUANTITY_FIVE.get();
		if (!Widgets.isVisible(selectQuantityFive))
		{
			return;
		}

		selectQuantityFive.interact(0);
	}

	public static void selectQuantityTen()
	{
		Widget selectQuantityTen = QUANTITY_TEN.get();
		if (!Widgets.isVisible(selectQuantityTen))
		{
			return;
		}

		selectQuantityTen.interact(0);
	}

	public static void selectQuantityX()
	{
		Widget selectQuantityX = QUANTITY_X.get();
		if (!Widgets.isVisible(selectQuantityX))
		{
			return;
		}

		selectQuantityX.interact(0);
	}

	public static void selectQuantityAll()
	{
		Widget selectQuantityAll = QUANTITY_ALL.get();
		if (!Widgets.isVisible(selectQuantityAll))
		{
			return;
		}

		selectQuantityAll.interact(0);
	}
	
	public static boolean isOpen()
	{
		Widget depositBox = ROOT.get();
		return Widgets.isVisible(depositBox);
	}

	public static void close()
	{
		Widget exitDepositBox = EXIT.get();
		if (!Widgets.isVisible(exitDepositBox))
		{
			return;
		}

		exitDepositBox.interact(0);
	}
}

package net.unethicalite.api.input.naturalmouse.api;

import net.unethicalite.api.input.naturalmouse.support.DoublePoint;

/**
 * Creates arcs or deviation into mouse movement.
 * <p>
 * DeviationProvider implementation should be immutable.
 */
public interface DeviationProvider
{

	/**
	 * Gets the deviation for current trajectory. Deviation is an offset from the original straight trajectory.
	 * <p>
	 * Deviation is different from the Noise because it works like a mathematical function, the resulting
	 * Point is added to single trajectory point and it will not have any effect in the next
	 * mouse movement step, making it easy to implement this as a formula based on the input parameters.
	 * e.g the something like 'deviation = totalDistanceInPixels / completionFraction', resulting in smooth movement.
	 * (Don't actually use this formula), 'Noise' is generating an offset from the original trajectory and is accumulating.
	 * <p>
	 * As deviation should be deterministic and return same result for same parameters, it should not include Random
	 * behaviour, thus Random is not included as a parameter.
	 * <p>
	 * It is recommended that deviation is decreasing when completionFraction nears 1, but MouseMotion itself
	 * also makes sure that the effect of deviation is reduced when the mouse is nearing its destination.
	 *
	 * @param totalDistanceInPixels the total pixels between target and mouse initial position
	 * @param completionFraction    the completed fraction of mouse movement total distance, value from 0...1 (0;1]
	 * @return a point which describes how much the mouse is going to deviate from the straight trajectory between
	 * target and initial position. This is not the final deviation of the mouse as MouseMotion will randomly decide
	 * to either amplify or decrease it over the whole mouse movement, making the resulting arc stand out more or less,
	 * or is flipped negatively.
	 * @see NoiseProvider
	 */
	DoublePoint getDeviation(double totalDistanceInPixels, double completionFraction);
}

package net.unethicalite.api.widgets;

import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.input.Keyboard;
import net.unethicalite.api.items.GrandExchange;
import net.unethicalite.api.packets.DialogPackets;
import net.unethicalite.client.Static;
import net.runelite.api.DialogOption;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class Dialog
{

	private static final Supplier<Widget> SPRITE_CONT = () -> Widgets.get(193, 0);
	private static final Supplier<Widget> SCROLL_BAR = () -> Widgets.get(162, 557);
	private static final Supplier<Widget> WEIRD_CONT = () -> Widgets.get(193, 3);
	private static final Supplier<Widget> WEIRD_CONT_2 = () -> Widgets.get(633, 0);
	private static final Supplier<Widget> NPC_CONT = () -> Widgets.get(WidgetID.DIALOG_NPC_GROUP_ID, 4);
	private static final Supplier<Widget> NPC_TEXT = () -> Widgets.get(WidgetID.DIALOG_NPC_GROUP_ID, 6);
	private static final Supplier<Widget> PLAYER_CONT = () -> Widgets.get(WidgetID.DIALOG_PLAYER_GROUP_ID, 3);
	private static final Supplier<Widget> PLAYER_NAME = () -> Widgets.get(WidgetID.DIALOG_PLAYER_GROUP_ID, 4);
	private static final Supplier<Widget> PLAYER_TEXT = () -> Widgets.get(WidgetID.DIALOG_PLAYER_GROUP_ID, 6);
	private static final Supplier<Widget> DEATH_CONT = () -> Widgets.get(663, 0);
	private static final Supplier<Widget> TUT_CONT = () -> Widgets.get(229, 2);
	private static final Supplier<Widget> OPTIONS = () -> Widgets.get(WidgetID.DIALOG_OPTION_GROUP_ID, 1);

	// Tutorial island continue dialogs
	public static void continueTutorial()
	{
		GameThread.invoke(() -> Static.getClient().runScript(299, 1, 1, 1));
	}

	public static boolean isOpen()
	{
		return SCROLL_BAR.get() == null || !SCROLL_BAR.get().isVisible();
	}

	public static boolean canContinue()
	{
		return canContinueNPC() || canContinuePlayer() || canContinueDeath()
				|| canSpriteContinue() || canSprite2Continue()
				|| canContinue1() || canContinue2()
				|| canContinueTutIsland() || canContinueTutIsland2()
				|| canContinueTutIsland3() || canLevelUpContinue();
	}

	public static boolean canLevelUpContinue()
	{
		return Widgets.isVisible(Widgets.get(WidgetInfo.LEVEL_UP_LEVEL));
	}

	public static boolean canSpriteContinue()
	{
		return Widgets.isVisible(SPRITE_CONT.get());
	}

	public static boolean canSprite2Continue()
	{
		return Widgets.isVisible(Widgets.get(WidgetInfo.DIALOG2_SPRITE_CONTINUE));
	}

	public static boolean canContinue1()
	{
		return Widgets.isVisible(WEIRD_CONT.get());
	}

	public static boolean canContinue2()
	{
		return Widgets.isVisible(WEIRD_CONT_2.get());
	}

	public static boolean canContinueNPC()
	{
		return Widgets.isVisible(NPC_CONT.get());
	}

	public static boolean canContinuePlayer()
	{
		return Widgets.isVisible(PLAYER_CONT.get());
	}

	public static boolean canContinueDeath()
	{
		Widget widget = DEATH_CONT.get();
		return widget != null && widget.isVisible() && widget.getChild(2) != null && !widget.getChild(2).isVisible();
	}

	public static boolean canContinueTutIsland()
	{
		return Widgets.isVisible(TUT_CONT.get());
	}

	public static boolean canContinueTutIsland2()
	{
		Widget widget = Widgets.get(WidgetInfo.DIALOG_SPRITE);
		return widget != null
				&& widget.isVisible() && widget.getChild(2) != null && widget.getChild(2).isVisible();
	}

	public static boolean canContinueTutIsland3()
	{
		Widget widget = Widgets.get(WidgetInfo.CHATBOX_FULL_INPUT);
		return widget != null && widget.isVisible() && widget.getText().toLowerCase().contains("continue");
	}

	public static boolean isEnterInputOpen()
	{
		return Widgets.isVisible(Widgets.get(WidgetInfo.CHATBOX_FULL_INPUT)) && !GrandExchange.isSearchingItem();
	}

	public static void enterName(String input)
	{
		GameThread.invoke(() -> DialogPackets.sendNameInput(input));
	}

	public static void enterText(String input)
	{
		GameThread.invoke(() -> DialogPackets.sendTextInput(input));
	}

	public static void enterAmount(int input)
	{
		GameThread.invoke(() -> DialogPackets.sendNumberInput(input));
	}

	public static boolean isViewingOptions()
	{
		return !getOptions().isEmpty();
	}

	public static void continueSpace()
	{
		if (Dialog.isOpen())
		{
			Keyboard.sendSpace();
		}
	}

	public static boolean chooseOption(int index)
	{
		if (isViewingOptions())
		{
			Keyboard.type(index);
			return true;
		}

		return false;
	}

	public static boolean chooseOption(String... options)
	{
		if (isViewingOptions())
		{
			for (int i = 0; i < getOptions().size(); i++)
			{
				Widget widget = getOptions().get(i);
				for (String option : options)
				{
					if (widget.getText().contains(option))
					{
						return chooseOption(i + 1);
					}
				}
			}
		}

		return false;
	}

	public static List<Widget> getOptions()
	{
		Widget widget = OPTIONS.get();
		if (!Widgets.isVisible(widget))
		{
			return Collections.emptyList();
		}

		List<Widget> out = new ArrayList<>();
		Widget[] children = widget.getChildren();
		if (children == null)
		{
			return out;
		}

		// Skip first child, it's not a dialog option
		for (int i = 1; i < children.length; i++)
		{
			if (children[i].getText().isBlank())
			{
				continue;
			}

			out.add(children[i]);
		}

		return out;
	}

	public static boolean hasOption(String option)
	{
		return hasOption(Predicates.texts(option));
	}

	public static boolean hasOption(Predicate<String> option)
	{
		return getOptions().stream()
				.map(Widget::getText)
				.filter(Objects::nonNull)
				.anyMatch(option);
	}

	public static void invokeDialog(DialogOption... dialogOption)
	{
		GameThread.invokeLater(() ->
		{
			for (DialogOption option : dialogOption)
			{
				Static.getClient().processDialog(option.getWidgetUid(), option.getMenuIndex());
			}

			return true;
		});
	}

	public static void invokeDialog(int widgetId, int menuIndex)
	{
		GameThread.invokeLater(() ->
		{
			Static.getClient().processDialog(widgetId, menuIndex);
			return true;
		});
	}

	public static void close()
	{
		GameThread.invoke(() -> Static.getClient().runScript(138));
	}

	public static String getText()
	{
		Widget widget = null;

		if (canContinueNPC())
		{
			widget = NPC_TEXT.get();
		}
		else if (canContinuePlayer())
		{
			widget = PLAYER_TEXT.get();
		}

		return widget == null ? "" : widget.getText();
	}

	public static String getName()
	{
		Widget widget = null;

		if (canContinueNPC())
		{
			widget = NPC_CONT.get();
		}
		else if (canContinuePlayer())
		{
			widget = PLAYER_NAME.get();
		}

		return widget == null ? "" : widget.getText();
	}
}

package net.unethicalite.api.packets;

import net.runelite.api.Client;
import net.runelite.api.packets.ClientPacket;
import net.runelite.api.packets.PacketBufferNode;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

public class DialogPackets
{
	public static void sendNumberInput(int number)
	{
		Client client = Static.getClient();
		ClientPacket clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.RESUME_COUNTDIALOG(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(number);
		client.getPacketWriter().queuePacket(packetBufferNode);
	}

	public static void sendNameInput(String name)
	{
		Client client = Static.getClient();
		ClientPacket clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.RESUME_NAMEDIALOG(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByte(name.length() + 1);
		packetBufferNode.getPacketBuffer().writeStringCp1252NullTerminated(name);
		client.getPacketWriter().queuePacket(packetBufferNode);
	}

	public static void sendTextInput(String text)
	{
		Client client = Static.getClient();
		ClientPacket clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.RESUME_STRINGDIALOG(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByte(text.length() + 1);
		packetBufferNode.getPacketBuffer().writeStringCp1252NullTerminated(text);
		client.getPacketWriter().queuePacket(packetBufferNode);
	}

	public static void closeInterface()
	{
		Client client = Static.getClient();
		ClientPacket clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.CLOSE_MODAL(), client.getPacketWriter().getIsaacCipher());
		client.getPacketWriter().queuePacket(packetBufferNode);
	}
}
package net.unethicalite.api.input.naturalmouse.support;

public class DoublePoint
{
	public final static DoublePoint ZERO = new DoublePoint(0, 0);
	private final double x;
	private final double y;

	public DoublePoint(double x, double y)
	{
		this.x = x;
		this.y = y;
	}

	public double getX()
	{
		return x;
	}

	public double getY()
	{
		return y;
	}
}

package net.unethicalite.api.utils;

import net.runelite.api.Client;
import net.runelite.api.Locatable;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.unethicalite.api.movement.pathfinder.CollisionMap;
import net.unethicalite.api.movement.pathfinder.TransportLoader;
import net.unethicalite.api.movement.pathfinder.model.Transport;
import net.unethicalite.api.scene.Tiles;
import net.unethicalite.client.Static;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.List;

public class DrawUtils
{
	private static final Color TRANSPORT_COLOR = new Color(0, 255, 0, 128);
	private static final Color TILE_BLOCKED_COLOR = new Color(0, 128, 255, 128);

	public static void drawOnMap(Graphics2D graphics, Locatable locatable, Color color)
	{
		drawOnMap(graphics, locatable.getWorldLocation(), color);
	}

	public static void drawOnMap(Graphics2D graphics, Tile tile, Color color)
	{
		drawOnMap(graphics, tile.getWorldLocation(), color);
	}

	public static void drawOnMap(Graphics2D graphics, WorldPoint point, Color color)
	{
		WorldMap wm = Static.getClient().getWorldMap();

		float pixelsPerTile = wm.getWorldMapZoom();
		int tileCenterPixel = (int) Math.ceil(pixelsPerTile / 2);

		Point tile = CoordUtils.worldPointToWorldMap(point);
		Point bottomRightTile = CoordUtils.worldPointToWorldMap(point.dx(1).dy(-1));

		if (tile == null || bottomRightTile == null)
		{
			return;
		}

		Point topLeft = tile.offset(-tileCenterPixel, -tileCenterPixel);
		Point bottomRight = bottomRightTile.offset(-tileCenterPixel, -tileCenterPixel);

		graphics.setColor(color);
		graphics.fillRect(topLeft.getX(), topLeft.getY(), bottomRight.getX() - topLeft.getX(), bottomRight.getY() - topLeft.getY());
	}

	public static void drawTransports(Graphics2D graphics2D)
	{
		Client client = Static.getClient();
		List<Transport> transports = TransportLoader.buildTransports();

		for (Transport transport : transports)
		{
			OverlayUtil.fillTile(graphics2D, client, transport.getSource(), TRANSPORT_COLOR);
			Point center = Perspective.tileCenter(client, transport.getSource());
			if (center == null)
			{
				continue;
			}

			Point linkCenter = Perspective.tileCenter(client, transport.getDestination());
			if (linkCenter == null)
			{
				continue;
			}

			graphics2D.drawLine(center.getX(), center.getY(), linkCenter.getX(), linkCenter.getY());
		}
	}

	public static void drawPath(Graphics2D graphics2D, List<WorldPoint> path)
	{
		path.forEach(t -> t.outline(Static.getClient(), graphics2D, Color.RED));
	}

	public static void drawCollisions(Graphics2D graphics2D, CollisionMap collisionMap)
	{
		Client client = Static.getClient();
		List<Tile> tiles = Tiles.getAll();

		if (tiles.isEmpty())
		{
			return;
		}

		if (collisionMap == null)
		{
			return;
		}

		for (Tile tile : tiles)
		{
			Polygon poly = Perspective.getCanvasTilePoly(client, tile.getLocalLocation());
			if (poly == null)
			{
				continue;
			}

			StringBuilder sb = new StringBuilder("");
			graphics2D.setColor(Color.WHITE);
			if (!collisionMap.n(tile.getWorldLocation()))
			{
				sb.append("n");
			}

			if (!collisionMap.s(tile.getWorldLocation()))
			{
				sb.append("s");
			}

			if (!collisionMap.w(tile.getWorldLocation()))
			{
				sb.append("w");
			}

			if (!collisionMap.e(tile.getWorldLocation()))
			{
				sb.append("e");
			}

			String s = sb.toString();
			if (s.isEmpty())
			{
				continue;
			}

			if (!s.equals("nswe"))
			{
				graphics2D.setColor(Color.WHITE);
				if (s.contains("n"))
				{
					graphics2D.drawLine(poly.xpoints[3], poly.ypoints[3], poly.xpoints[2], poly.ypoints[2]);
				}

				if (s.contains("s"))
				{
					graphics2D.drawLine(poly.xpoints[0], poly.ypoints[0], poly.xpoints[1], poly.ypoints[1]);
				}

				if (s.contains("w"))
				{
					graphics2D.drawLine(poly.xpoints[0], poly.ypoints[0], poly.xpoints[3], poly.ypoints[3]);
				}

				if (s.contains("e"))
				{
					graphics2D.drawLine(poly.xpoints[1], poly.ypoints[1], poly.xpoints[2], poly.ypoints[2]);
				}

				continue;
			}

			graphics2D.setColor(TILE_BLOCKED_COLOR);
			graphics2D.fill(poly);
		}
	}

	public static void drawCollisions(Graphics2D graphics2D)
	{
		drawCollisions(graphics2D, Static.getGlobalCollisionMap());
	}
}

package net.unethicalite.api.entities;

import net.unethicalite.api.SceneEntity;
import net.unethicalite.api.commons.Predicates;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.client.Static;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.function.Predicate;

public abstract class Entities<T extends SceneEntity>
{
	protected abstract List<T> all(Predicate<? super T> filter);

	protected List<T> all(String... names)
	{
		return all(Predicates.names(names));
	}

	protected List<T> all(int... ids)
	{
		return all(Predicates.ids(ids));
	}

	protected T nearest(WorldPoint to, Predicate<? super T> filter)
	{
		return all(x -> x.getId() != -1 && filter.test(x)).stream()
				.min(Comparator.comparingDouble(t -> t.getWorldLocation().distanceToHypotenuse(to)))
				.orElse(null);
	}

	protected T nearest(WorldPoint to, String... names)
	{
		return nearest(to, Predicates.names(names));
	}

	protected T nearest(WorldPoint to, int... ids)
	{
		return nearest(to, Predicates.ids(ids));
	}

	public static List<? extends SceneEntity> getHoveredEntities()
	{
		MenuEntry[] menuEntries = Static.getClient().getMenuEntries();
		if (menuEntries.length == 0)
		{
			return Collections.emptyList();
		}

		List<SceneEntity> out = new ArrayList<>();

		for (MenuEntry menuEntry : menuEntries)
		{
			MenuAction menuAction = menuEntry.getType();

			switch (menuAction)
			{
				case EXAMINE_OBJECT:
				case ITEM_USE_ON_GAME_OBJECT:
				case WIDGET_TARGET_ON_GAME_OBJECT:
				case GAME_OBJECT_FIRST_OPTION:
				case GAME_OBJECT_SECOND_OPTION:
				case GAME_OBJECT_THIRD_OPTION:
				case GAME_OBJECT_FOURTH_OPTION:
				case GAME_OBJECT_FIFTH_OPTION:
				{
					int x = menuEntry.getParam0();
					int y = menuEntry.getParam1();
					int id = menuEntry.getIdentifier();
					Tile tile = Static.getClient().getScene().getTiles()[Static.getClient().getPlane()][x][y];
					out.addAll(TileObjects.getAt(tile, id));
					break;
				}

				case EXAMINE_NPC:
				case ITEM_USE_ON_NPC:
				case WIDGET_TARGET_ON_NPC:
				case NPC_FIRST_OPTION:
				case NPC_SECOND_OPTION:
				case NPC_THIRD_OPTION:
				case NPC_FOURTH_OPTION:
				case NPC_FIFTH_OPTION:
				{
					int index = menuEntry.getIdentifier();
					out.add(Static.getClient().getCachedNPCs()[index]);
					break;
				}

				case EXAMINE_ITEM_GROUND:
				case ITEM_USE_ON_GROUND_ITEM:
				case WIDGET_TARGET_ON_GROUND_ITEM:
				case GROUND_ITEM_FIRST_OPTION:
				case GROUND_ITEM_SECOND_OPTION:
				case GROUND_ITEM_THIRD_OPTION:
				case GROUND_ITEM_FOURTH_OPTION:
				case GROUND_ITEM_FIFTH_OPTION:
				{
					int x = menuEntry.getParam0();
					int y = menuEntry.getParam1();
					int id = menuEntry.getIdentifier();
					Tile tile = Static.getClient().getScene().getTiles()[Static.getClient().getPlane()][x][y];
					out.addAll(TileItems.getAt(tile, id));
					break;
				}

				case ITEM_USE_ON_PLAYER:
				case WIDGET_TARGET_ON_PLAYER:
				case PLAYER_FIRST_OPTION:
				case PLAYER_SECOND_OPTION:
				case PLAYER_THIRD_OPTION:
				case PLAYER_FOURTH_OPTION:
				case PLAYER_FIFTH_OPTION:
				case PLAYER_SIXTH_OPTION:
				case PLAYER_SEVENTH_OPTION:
				case PLAYER_EIGHTH_OPTION:
				{
					out.add(Static.getClient().getCachedPlayers()[menuEntry.getIdentifier()]);
					break;
				}

				default:
					break;
			}
		}

		return out;
	}
}

package net.unethicalite.api.items;

import net.unethicalite.api.query.items.ItemQuery;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.widgets.WidgetInfo;

import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class Equipment extends Items
{
	private static final Equipment EQUIPMENT = new Equipment();

	private Equipment()
	{
		super(InventoryID.EQUIPMENT, item ->
		{
			WidgetInfo widgetInfo = getEquipmentWidgetInfo(item.getSlot());

			if (widgetInfo != null)
			{
				item.setWidgetId(widgetInfo.getPackedId());
				return true;
			}

			return false;
		});
	}

	public static ItemQuery query()
	{
		return query(Equipment::getAll);
	}

	public static ItemQuery query(Supplier<List<Item>> supplier)
	{
		return new ItemQuery(supplier);
	}

	public static List<Item> getAll()
	{
		return getAll(x -> true);
	}

	public static List<Item> getAll(Predicate<Item> filter)
	{
		return EQUIPMENT.all(filter);
	}

	public static List<Item> getAll(int... ids)
	{
		return EQUIPMENT.all(ids);
	}

	public static List<Item> getAll(String... names)
	{
		return EQUIPMENT.all(names);
	}

	public static Item getFirst(Predicate<Item> filter)
	{
		return EQUIPMENT.first(filter);
	}

	public static Item getFirst(int... ids)
	{
		return EQUIPMENT.first(ids);
	}

	public static Item getFirst(String... names)
	{
		return EQUIPMENT.first(names);
	}

	private static WidgetInfo getEquipmentWidgetInfo(int itemIndex)
	{
		for (EquipmentInventorySlot equipmentInventorySlot : EquipmentInventorySlot.values())
		{
			if (equipmentInventorySlot.getSlotIdx() == itemIndex)
			{
				return equipmentInventorySlot.getWidgetInfo();
			}
		}

		return null;
	}

	public static boolean contains(Predicate<Item> filter)
	{
		return EQUIPMENT.exists(filter);
	}

	public static boolean contains(int... id)
	{
		return EQUIPMENT.exists(id);
	}

	public static boolean contains(String... name)
	{
		return EQUIPMENT.exists(name);
	}

	public static int getCount(boolean stacks, Predicate<Item> filter)
	{
		return EQUIPMENT.count(stacks, filter);
	}

	public static int getCount(boolean stacks, int... ids)
	{
		return EQUIPMENT.count(stacks, ids);
	}

	public static int getCount(boolean stacks, String... names)
	{
		return EQUIPMENT.count(stacks, names);
	}

	public static int getCount(Predicate<Item> filter)
	{
		return EQUIPMENT.count(false, filter);
	}

	public static int getCount(int... ids)
	{
		return EQUIPMENT.count(false, ids);
	}

	public static int getCount(String... names)
	{
		return EQUIPMENT.count(false, names);
	}

	public static Item fromSlot(EquipmentInventorySlot slot)
	{
		return getFirst(x -> slot.getWidgetInfo().getPackedId() == x.getWidgetId());
	}
}

package net.unethicalite.api.statistics;

import net.unethicalite.api.game.Skills;
import lombok.Value;
import net.runelite.api.Skill;

@Value
public class ExperienceTracker
{
	Skill skill;
	int startExp;
	int startLevel;

	public int getExperienceGained()
	{
		return Skills.getExperience(skill) - startExp;
	}

	public int getLevelsGained()
	{
		return Skills.getLevel(skill) - startLevel;
	}
}

package net.unethicalite.api.statistics;

import net.unethicalite.api.game.Skills;
import lombok.Value;
import net.runelite.api.Skill;

@Value
public class ExperienceTracker
{
	Skill skill;
	int startExp;
	int startLevel;

	public int getExperienceGained()
	{
		return Skills.getExperience(skill) - startExp;
	}

	public int getLevelsGained()
	{
		return Skills.getLevel(skill) - startLevel;
	}
}

package net.unethicalite.api.script.paint;

import net.unethicalite.api.game.Skills;
import lombok.Value;
import net.runelite.api.Skill;

@Value
public class ExperienceTracker
{
	Skill skill;
	int startExp;
	int startLevel;

	public int getExperienceGained()
	{
		return Skills.getExperience(skill) - startExp;
	}

	public int getLevelsGained()
	{
		return Skills.getLevel(skill) - startLevel;
	}
}

package net.unethicalite.api.input.naturalmouse.util;

import net.unethicalite.api.input.naturalmouse.api.MouseMotionFactory;
import net.unethicalite.api.input.naturalmouse.api.SpeedManager;
import net.unethicalite.api.input.naturalmouse.support.DefaultMouseMotionNature;
import net.unethicalite.api.input.naturalmouse.support.DefaultNoiseProvider;
import net.unethicalite.api.input.naturalmouse.support.DefaultOvershootManager;
import net.unethicalite.api.input.naturalmouse.support.DefaultSpeedManager;
import net.unethicalite.api.input.naturalmouse.support.DoublePoint;
import net.unethicalite.api.input.naturalmouse.support.Flow;
import net.unethicalite.api.input.naturalmouse.support.MouseMotionNature;
import net.unethicalite.api.input.naturalmouse.support.SinusoidalDeviationProvider;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class FactoryTemplates
{
	/**
	 * <h1>Stereotypical granny using a computer with non-optical mouse from the 90s.</h1>
	 * Low speed, variating flow, lots of noise in movement.
	 *
	 * @return the factory
	 */
	public static MouseMotionFactory createGrannyMotionFactory()
	{
		return createGrannyMotionFactory(new DefaultMouseMotionNature());
	}

	/**
	 * <h1>Stereotypical granny using a computer with non-optical mouse from the 90s.</h1>
	 * Low speed, variating flow, lots of noise in movement.
	 *
	 * @param nature the nature for the template to be configured on
	 * @return the factory
	 */
	public static MouseMotionFactory createGrannyMotionFactory(MouseMotionNature nature)
	{
		MouseMotionFactory factory = new MouseMotionFactory(nature);
		List<Flow> flows = new ArrayList<>(Arrays.asList(
				new Flow(FlowTemplates.jaggedFlow()),
				new Flow(FlowTemplates.random()),
				new Flow(FlowTemplates.interruptedFlow()),
				new Flow(FlowTemplates.interruptedFlow2()),
				new Flow(FlowTemplates.adjustingFlow()),
				new Flow(FlowTemplates.stoppingFlow())
		));
		DefaultSpeedManager manager = new DefaultSpeedManager(flows);
		factory.setDeviationProvider(new SinusoidalDeviationProvider(9));
		factory.setNoiseProvider(new DefaultNoiseProvider(1.6));
		factory.getNature().setReactionTimeBaseMs(100);

		DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
		overshootManager.setOvershoots(3);
		overshootManager.setMinDistanceForOvershoots(3);
		overshootManager.setMinOvershootMovementMs(400);
		overshootManager.setOvershootRandomModifierDivider(DefaultOvershootManager.OVERSHOOT_RANDOM_MODIFIER_DIVIDER / 2);
		overshootManager.setOvershootSpeedupDivider(DefaultOvershootManager.OVERSHOOT_SPEEDUP_DIVIDER * 2);

		factory.getNature().setTimeToStepsDivider(DefaultMouseMotionNature.TIME_TO_STEPS_DIVIDER - 2);
		manager.setMouseMovementBaseTimeMs(1000);
		factory.setSpeedManager(manager);
		return factory;
	}

	/**
	 * <h1>Robotic fluent movement.</h1>
	 * Custom speed, constant movement, no mistakes, no overshoots.
	 *
	 * @param motionTimeMsPer100Pixels approximate time a movement takes per 100 pixels of travelling
	 * @return the factory
	 */
	public static MouseMotionFactory createDemoRobotMotionFactory(long motionTimeMsPer100Pixels)
	{
		return createDemoRobotMotionFactory(new DefaultMouseMotionNature(), motionTimeMsPer100Pixels);
	}

	/**
	 * <h1>Robotic fluent movement.</h1>
	 * Custom speed, constant movement, no mistakes, no overshoots.
	 *
	 * @param nature                   the nature for the template to be configured on
	 * @param motionTimeMsPer100Pixels approximate time a movement takes per 100 pixels of travelling
	 * @return the factory
	 */
	public static MouseMotionFactory createDemoRobotMotionFactory(
			MouseMotionNature nature, long motionTimeMsPer100Pixels
	)
	{
		MouseMotionFactory factory = new MouseMotionFactory(nature);
		final Flow flow = new Flow(FlowTemplates.constantSpeed());
		double timePerPixel = motionTimeMsPer100Pixels / 100d;
		SpeedManager manager = distance -> new Pair<>(flow, (long) (timePerPixel * distance));
		factory.setDeviationProvider((totalDistanceInPixels, completionFraction) -> DoublePoint.ZERO);
		factory.setNoiseProvider(((random, xStepSize, yStepSize) -> DoublePoint.ZERO));

		DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
		overshootManager.setOvershoots(0);

		factory.setSpeedManager(manager);
		return factory;
	}

	/**
	 * <h1>Gamer with fast reflexes and quick mouse movements.</h1>
	 * Quick movement, low noise, some deviation, lots of overshoots.
	 *
	 * @return the factory
	 */
	public static MouseMotionFactory createFastGamerMotionFactory()
	{
		return createFastGamerMotionFactory(new DefaultMouseMotionNature());
	}

	/**
	 * <h1>Gamer with fast reflexes and quick mouse movements.</h1>
	 * Quick movement, low noise, some deviation, lots of overshoots.
	 *
	 * @param nature the nature for the template to be configured on
	 * @return the factory
	 */
	public static MouseMotionFactory createFastGamerMotionFactory(MouseMotionNature nature)
	{
		MouseMotionFactory factory = new MouseMotionFactory(nature);
		List<Flow> flows = new ArrayList<>(Arrays.asList(
				new Flow(FlowTemplates.variatingFlow()),
				new Flow(FlowTemplates.slowStartupFlow()),
				new Flow(FlowTemplates.slowStartup2Flow()),
				new Flow(FlowTemplates.adjustingFlow()),
				new Flow(FlowTemplates.jaggedFlow())
		));
		DefaultSpeedManager manager = new DefaultSpeedManager(flows);
		factory.setDeviationProvider(new SinusoidalDeviationProvider(SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER));
		factory.setNoiseProvider(new DefaultNoiseProvider(DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER));
		factory.getNature().setReactionTimeVariationMs(100);
		manager.setMouseMovementBaseTimeMs(250);

		DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
		overshootManager.setOvershoots(4);

		factory.setSpeedManager(manager);
		return factory;
	}

	/**
	 * <h1>Standard computer user with average speed and movement mistakes</h1>
	 * medium noise, medium speed, medium noise and deviation.
	 *
	 * @return the factory
	 */
	public static MouseMotionFactory createAverageComputerUserMotionFactory()
	{
		return createAverageComputerUserMotionFactory(new DefaultMouseMotionNature());
	}

	/**
	 * <h1>Standard computer user with average speed and movement mistakes</h1>
	 * medium noise, medium speed, medium noise and deviation.
	 *
	 * @param nature the nature for the template to be configured on
	 * @return the factory
	 */
	public static MouseMotionFactory createAverageComputerUserMotionFactory(MouseMotionNature nature)
	{
		MouseMotionFactory factory = new MouseMotionFactory(nature);
		List<Flow> flows = new ArrayList<>(Arrays.asList(
				new Flow(FlowTemplates.variatingFlow()),
				new Flow(FlowTemplates.interruptedFlow()),
				new Flow(FlowTemplates.interruptedFlow2()),
				new Flow(FlowTemplates.slowStartupFlow()),
				new Flow(FlowTemplates.slowStartup2Flow()),
				new Flow(FlowTemplates.adjustingFlow()),
				new Flow(FlowTemplates.jaggedFlow()),
				new Flow(FlowTemplates.stoppingFlow())
		));
		DefaultSpeedManager manager = new DefaultSpeedManager(flows);
		factory.setDeviationProvider(new SinusoidalDeviationProvider(SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER));
		factory.setNoiseProvider(new DefaultNoiseProvider(DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER));
		factory.getNature().setReactionTimeVariationMs(110);
		manager.setMouseMovementBaseTimeMs(400);

		DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
		overshootManager.setOvershoots(4);

		factory.setSpeedManager(manager);
		return factory;
	}
}

package net.unethicalite.api.movement.pathfinder.model;

import lombok.Getter;
import net.runelite.api.MenuAction;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.widgets.Widgets;

import java.util.function.Supplier;

@Getter
public enum FairyRingLocation
{
    AIR("AIR", new WorldPoint(2699, 3249, 0)),
    AIQ("AIQ", new WorldPoint(2995, 3112, 0)),
    AJR("AJR", new WorldPoint(2779, 3615, 0)),
    AJS("AJS", new WorldPoint(2499, 3898, 0)),
    AKP("AKP", new WorldPoint(3283, 2704, 0)),
    AKQ("AKQ", new WorldPoint(2318, 3617, 0)),
    AKS("AKS", new WorldPoint(2570, 2958, 0)),
    ALP("ALP", new WorldPoint(2502, 3638, 0)),
    ALQ("ALQ", new WorldPoint(3598, 3496, 0)),
    ALS("ALS", new WorldPoint(2643, 3497, 0)),
    BIP("BIP", new WorldPoint(3409, 3326, 0)),
    BIQ("BIQ", new WorldPoint(3248, 3095, 0)),
    BIS("BIS", new WorldPoint(2635, 3268, 0)),
    BJP("BJP", new WorldPoint(2264, 2976, 0)),
    BJS("BJS", new WorldPoint(2150, 3071, 0)),
    BKP("BKP", new WorldPoint(2384, 3037, 0)),
    BKR("BKR", new WorldPoint(3468, 3433, 0)),
    BLP("BLP", new WorldPoint(2432, 5127, 0)),
    BLR("BLR", new WorldPoint(2739, 3353, 0)),
    CIP("CIP", new WorldPoint(2512, 3886, 0)),
    CIR("CIR", new WorldPoint(1303, 3762, 0)),
    CIQ("CIQ", new WorldPoint(2527, 3129, 0)),
    CJR("CJR", new WorldPoint(2704, 3578, 0)),
    CKR("CKR", new WorldPoint(2800, 3003, 0)),
    CKS("CKS", new WorldPoint(3446, 3472, 0)),
    CLP("CLP", new WorldPoint(3081, 3208, 0)),
    CLS("CLS", new WorldPoint(2681, 3083, 0)),
    DIP("DIP", new WorldPoint(3039, 4757, 0)),
    DIS("DIS", new WorldPoint(3109, 3149, 0)),
    DJP("DJP", new WorldPoint(2658, 3229, 0)),
    DJR("DJR", new WorldPoint(1452, 3659, 0)),
    DKP("DKP", new WorldPoint(2899, 3113, 0)),
    DKR("DKR", new WorldPoint(3126, 3496, 0)),
    DKS("DKS", new WorldPoint(2743, 3721, 0)),
    DLQ("DLQ", new WorldPoint(3422, 3018, 0)),
    DLR("DLR", new WorldPoint(2212, 3101, 0)),
    CIS("CIS", new WorldPoint(1638, 3868, 0)),
    CLR("CLR", new WorldPoint(2737, 2739, 0)),
    ZANARIS("Zanaris", new WorldPoint(2411, 4436, 0));

    private final String code;
    private final WorldPoint location;

    FairyRingLocation(String code, WorldPoint location)
    {
        this.code = code;
        this.location = location;
    }

    private static final int[][] TURN_INDICES = {{19, 20}, {21, 22}, {23, 24}};
    public static final Supplier<Widget> CONFIRM_WIDGET = () -> Widgets.get(WidgetInfo.FAIRY_RING.getGroupId(), 26);
    private static final String[][] CODES = {{"A", "D", "C", "B"}, {"I", "L", "K", "J"}, {"P", "S", "R", "Q"}};

    public boolean validateCode()
    {
        return getCurrentCode().equalsIgnoreCase(this.code);
    }

    public void setCode()
    {
        String currentCode = getCurrentCode();
        if (currentCode.charAt(0) != this.code.charAt(0))
        {
            Widgets.get(WidgetInfo.FAIRY_RING.getGroupId(), TURN_INDICES[0][0]).interact(0);
            return;
        }

        if (currentCode.charAt(1) != this.code.charAt(1))
        {
            Widgets.get(WidgetInfo.FAIRY_RING.getGroupId(), TURN_INDICES[1][0]).interact(0);
            return;
        }

        if (currentCode.charAt(2) != this.code.charAt(2))
        {
            Widgets.get(WidgetInfo.FAIRY_RING.getGroupId(), TURN_INDICES[2][0]).interact(0);
        }
    }

    public void travel()
    {
        if (validateCode())
        {
            CONFIRM_WIDGET.get().interact(1, MenuAction.CC_OP.getId(), -1, 26083354);
        }
        else
        {
            setCode();
        }
    }

    public static String getCurrentCode()
    {
        return GameThread.invokeLater(() ->
                CODES[0][Vars.getBit(Varbits.FAIRY_RING_DIAL_ADCB)]
                + CODES[1][Vars.getBit(Varbits.FAIRY_RIGH_DIAL_ILJK)]
                + CODES[2][Vars.getBit(Varbits.FAIRY_RING_DIAL_PSRQ)]
        );
    }

}

package net.unethicalite.api.commons;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import net.runelite.client.RuneLite;
import net.runelite.client.plugins.Plugin;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class FileUtil
{
	private static final Logger log = LoggerFactory.getLogger(FileUtil.class);
	private static final File DATA_DIR = new File(RuneLite.RUNELITE_DIR, "data");
	private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

	public static void serialize(Plugin plugin, String fileName, Serializable data)
	{
		serialize(plugin.getClass().getSimpleName(), fileName, data);
	}

	public static void serialize(String dirName, String fileName, Serializable data)
	{
		try (FileOutputStream fos = new FileOutputStream(new File(getDirectory(dirName), fileName));
			 ObjectOutputStream oos = new ObjectOutputStream(fos))
		{
			oos.writeObject(data);
			oos.flush();
		}
		catch (IOException e)
		{
			log.error("Error serializing file: {}", e.getMessage());
		}
	}

	public static <T> T deserialize(Plugin plugin, String fileName)
	{
		return deserialize(plugin.getClass().getSimpleName(), fileName);
	}

	public static <T> T deserialize(String dirName, String fileName)
	{
		try (FileInputStream fis = new FileInputStream(new File(getDirectory(dirName), fileName));
			 ObjectInputStream ois = new ObjectInputStream(fis))
		{
			return (T) ois.readObject();
		}
		catch (IOException | ClassNotFoundException e)
		{
			log.error("Error deserializing file: {}", e.getMessage());
			return null;
		}
	}

	public static void writeJson(Plugin plugin, String fileName, Object data)
	{
		writeJson(plugin.getClass().getSimpleName(), fileName, data);
	}

	public static void writeJson(String dirName, String fileName, Object data)
	{
		try (FileWriter writer = new FileWriter(new File(getDirectory(dirName), fileName)))
		{
			GSON.toJson(data, writer);
			writer.flush();
		}
		catch (IOException e)
		{
			log.error("Error writing json: {}", e.getMessage());
		}
	}

	public static <T> T readJson(Plugin plugin, String fileName, Class<T> type)
	{
		return readJson(plugin.getClass().getSimpleName(), fileName, type);
	}

	public static <T> T readJson(String dirName, String fileName, Class<T> type)
	{
		return readJson(dirName, fileName, TypeToken.get(type));
	}

	public static <T> T readJson(Plugin plugin, String fileName, TypeToken<T> type)
	{
		return readJson(plugin.getClass().getSimpleName(), fileName, type);
	}

	public static <T> T readJson(String dirName, String fileName, TypeToken<T> type)
	{
		try (FileReader reader = new FileReader(new File(getDirectory(dirName), fileName)))
		{
			return GSON.fromJson(reader, type.getType());
		}
		catch (IOException e)
		{
			log.error("Error reading json: {}", e.getMessage());
			return null;
		}
	}

	public static boolean exists(Plugin plugin, String fileName)
	{
		return exists(plugin.getClass().getSimpleName(), fileName);
	}

	public static boolean exists(String dirName, String fileName)
	{
		File pluginDir = new File(DATA_DIR, dirName);
		return new File(pluginDir, fileName).exists();
	}

	public static File getPluginDirectory(Plugin plugin)
	{
		return getDirectory(plugin.getClass().getSimpleName());
	}

	public static File getDirectory(String dirName)
	{
		File dir = new File(DATA_DIR, dirName);
		dir.mkdirs();
		return dir;
	}
}

package net.unethicalite.api.input.naturalmouse.support;

/**
 * Flow for the mouse movement
 * Flow defines how slow or fast the cursor is moving at a particular moment, defining the characteristics
 * of movement itself not the trajectory, but how jagged or smooth, accelerating or decelerating, the movement is.
 */
public class Flow
{
	private static final int AVERAGE_BUCKET_VALUE = 100;

	private final double[] buckets;

	/**
	 * @param characteristics the characteristics array, which can be any size, contain non-negative numbers.
	 *                        The values in the array are translated to flow and all values are relative. For example an
	 *                        array of [1,2,3,4] has the same meaning as [100, 200, 300, 400] or [10, 10, 20, 20, 30, 30, 40, 40]
	 *                        Every array element describes a time of the movement, so that in array of n-elements every element is
	 *                        describing (100 / n)% of the movement. In an array of [1,2,3,4] every element is responsible for
	 *                        25% of time and the movement is accelerating - in the last 25% of time the mouse cursor is 4 times faster
	 *                        than it was in the first 25% of the time.
	 */
	public Flow(double[] characteristics)
	{
		buckets = normalizeBuckets(characteristics);
	}

	/**
	 * Normalizes the characteristics to have an average of AVERAGE_BUCKET_VALUE
	 *
	 * @param flowCharacteristics an array of values which describe how the mouse should move at each moment
	 * @return the normalized bucket array
	 */
	private double[] normalizeBuckets(double[] flowCharacteristics)
	{
		double[] buckets = new double[flowCharacteristics.length];
		long sum = 0;
		for (int i = 0; i < flowCharacteristics.length; i++)
		{
			if (flowCharacteristics[i] < 0)
			{
				throw new IllegalArgumentException("Invalid FlowCharacteristics at [" + i + "] : " + flowCharacteristics[i]);
			}
			sum += flowCharacteristics[i];
		}

		if (sum == 0)
		{
			throw new IllegalArgumentException("Invalid FlowCharacteristics. All array elements can't be 0.");
		}
		/*
		 * By multiplying AVERAGE_BUCKET_VALUE to buckets.length we get a required fill for the buckets,
		 * For example if there are 5 buckets then 100 * 5 gives us 500, which is how much the buckets should
		 * contain on total ideally. Then we divide it by the sum which we got from adding all contents of characteristics
		 * array together. The resulting value describes the FlowCharacteristics array and how much is missing or
		 * overfilled in it. for example when we get 0.5, then we know it contains twice as much as our normalized
		 * buckets array should have and we multiply all characteristics values by 0.5, this preserves the
		 * characteristics, but reduces the values to levels our algorithm knows how to work with.
		 */
		double multiplier = (double) AVERAGE_BUCKET_VALUE * buckets.length / sum;
		for (int i = 0; i < flowCharacteristics.length; i++)
		{
			buckets[i] = flowCharacteristics[i] * multiplier;
		}
		return buckets;
	}

	public double[] getFlowCharacteristics()
	{
		return buckets;
	}

	/**
	 * This returns step size for a single axis.
	 *
	 * @param distance   the total distance current movement has on current axis from beginning to target in pixels
	 * @param steps      number of steps the current movement involves
	 * @param completion value between 0 and 1, the value describes movement completion in time
	 * @return the step size which should be taken next
	 */
	public double getStepSize(double distance, int steps, double completion)
	{
		// This is essentially how big is a single completion step,
		// so we can expect next 'completion' is current completion + completionStep
		double completionStep = 1d / steps;
		// Define the first bucket we read from
		double bucketFrom = (completion * buckets.length);
		// Define the last bucket we read from
		double bucketUntil = ((completion + completionStep) * buckets.length);

		double bucketContents = getBucketsContents(bucketFrom, bucketUntil);
		// This shows how much distance is assigned to single contents value in the buckets.
		// For example if this gets assigned to 0.4, then for every value in the bucket
		// the cursor needs to travel 0.4 pixels, so for a bucket containing 50, the mouse
		// travelling distance is 0.4 * 50 = 20pixels
		double distancePerBucketContent = distance / (buckets.length * AVERAGE_BUCKET_VALUE);

		return bucketContents * distancePerBucketContent;
	}

	/**
	 * Summarizes the bucket contents from bucketFrom to bucketUntil, where
	 * provided parameters may have decimal places. In that case the value
	 * from first or last bucket is just a fragment of it's full value, depending how
	 * large portion the decimal place contains. For example getBucketContents(0.6, 2.4)
	 * returns 0.4 * bucket[0] + 1 * bucket[1] + 0.4 * bucket[2]
	 *
	 * @param bucketFrom  bucket from where to start reading
	 * @param bucketUntil bucket where to read
	 * @return the sum of the contents in the buckets
	 */
	private double getBucketsContents(double bucketFrom, double bucketUntil)
	{
		double sum = 0;
		for (int i = (int) bucketFrom; i < bucketUntil; i++)
		{
			double value = buckets[i];
			double endMultiplier = 1;
			double startMultiplier = 0;
			if (bucketUntil < i + 1)
			{
				endMultiplier = bucketUntil - (int) bucketUntil;
			}
			if ((int) bucketFrom == i)
			{
				startMultiplier = bucketFrom - (int) bucketFrom;
			}
			value *= endMultiplier - startMultiplier;
			sum += value;
		}

		return sum;
	}
}

package net.unethicalite.api.input.naturalmouse.util;

import java.util.Arrays;

public class FlowTemplates
{
	public static double[] variatingFlow()
	{
		return new double[]{
				10, 13, 14, 19, 16, 13, 15, 22, 56, 90, 97, 97, 66, 51, 50, 66, 91, 95, 87, 96, 98,
				88, 70, 62, 57, 63, 79, 93, 98, 97, 100, 104, 83, 49, 37, 53, 68, 73, 61, 51, 64, 107,
				103, 111, 94, 88, 95, 86, 88, 97, 108, 85, 86, 74, 72, 73, 58, 50, 50, 60, 62, 61, 52,
				53, 44, 30, 21, 25, 21, 17, 16, 13, 8, 2, 6, 9, 6, 3, 7, 12, 13, 15, 11, 9,
				9, 7, 6, 4, 1, 2, 3, 2, 2, 11, 15, 7, 1, 0, 0, 1
		};
	}

	public static double[] interruptedFlow()
	{
		return new double[]{
				12, 11, 10, 20, 24, 19, 26, 15, 9, 9, 10, 24, 26, 30, 24, 49, 72, 60, 81, 113, 82,
				99, 67, 10, 7, 7, 7, 10, 8, 7, 9, 6, 6, 7, 10, 11, 12, 8, 7, 3, 0, 2,
				8, 10, 10, 12, 6, 4, 4, 3, 8, 11, 11, 11, 11, 13, 11, 20, 25, 18, 21, 23, 56,
				40, 36, 58, 69, 60, 63, 51, 87, 71, 86, 66, 115, 97, 80, 65, 50, 66, 57, 24, 11, 11,
				7, 3, 0, 0, 1, 3, 3, 5, 6, 12, 11, 7, 11, 17, 17, 23
		};
	}

	public static double[] interruptedFlow2()
	{
		return new double[]{
				12, 11, 10, 20, 24, 19, 26, 15, 9, 9, 10, 24, 26, 30, 24, 49, 72, 60, 81, 113, 82,
				99, 67, 10, 12, 8, 11, 15, 16, 17, 17, 12, 16, 37, 10, 25, 12, 11, 41, 10, 12, 11,
				40, 36, 52, 61, 60, 64, 51, 82, 71, 81, 66, 105, 92, 59, 65, 51, 66, 54, 21, 21, 12,
				40, 36, 58, 69, 60, 63, 51, 87, 71, 86, 66, 115, 97, 80, 65, 50, 66, 57, 24, 11, 11,
				7, 3, 0, 0, 1, 3, 3, 5, 6, 12, 11, 7, 11, 17, 17, 23
		};
	}


	public static double[] slowStartupFlow()
	{
		return new double[]{
				8, 5, 1, 1, 1, 2, 2, 3, 3, 3, 5, 7, 9, 10, 10, 11, 11, 11, 12, 12, 13,
				15, 14, 13, 15, 15, 17, 17, 18, 18, 20, 19, 20, 20, 19, 20, 19, 20, 21, 22, 20, 17,
				20, 22, 18, 20, 21, 18, 20, 20, 18, 20, 19, 21, 19, 19, 19, 19, 20, 19, 20, 21, 19,
				19, 17, 21, 21, 17, 19, 18, 20, 18, 19, 24, 34, 43, 35, 40, 41, 42, 42, 38, 40, 40,
				37, 36, 42, 40, 63, 85, 98, 92, 103, 102, 95, 86, 70, 52, 31, 19
		};
	}


	public static double[] slowStartup2Flow()
	{
		return new double[]{
				7, 2, 1, 2, 2, 3, 5, 9, 10, 10, 11, 13, 13, 10, 4, 1, 1, 2, 3, 4, 6,
				9, 11, 11, 10, 14, 11, 9, 2, 1, 2, 2, 3, 4, 8, 9, 10, 11, 11, 13, 13, 15,
				14, 15, 18, 17, 19, 21, 20, 19, 18, 20, 20, 20, 20, 19, 20, 19, 19, 18, 20, 20, 19,
				20, 18, 20, 21, 19, 21, 18, 19, 25, 37, 37, 35, 41, 43, 41, 41, 40, 48, 81, 108, 91,
				88, 74, 46, 19, 46, 84, 35, 14, 19, 12, 13, 18, 38, 35, 11, 4
		};
	}

	public static double[] jaggedFlow()
	{
		return new double[]{
				52, 106, 122, 8, 6, 117, 32, 2, 68, 34, 21, 81, 61, 86, 55, 4, 104, 21, 51, 8, 93,
				90, 43, 65, 82, 31, 40, 115, 107, 13, 35, 73, 81, 67, 31, 79, 57, 100, 55, 64, 13, 54,
				18, 68, 82, 61, 11, 84, 37, 20, 68, 33, 36, 55, 68, 75, 56, 20, 41, 120, 63, 72, 102,
				49, 4, 48, 69, 50, 35, 49, 54, 19, 95, 121, 26, 78, 31, 62, 53, 123, 73, 22, 39, 72,
				98, 33, 26, 5, 103, 23, 75, 35, 69, 33, 44, 12, 10, 101, 122, 19
		};
	}

	public static double[] stoppingFlow()
	{
		return new double[]{
				8, 20, 39, 48, 66, 71, 79, 57, 29, 5, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 10, 12, 15, 19,
				37, 60, 100, 103, 98, 82, 87, 74, 65, 51, 57, 54, 61, 46, 38, 16
		};
	}

	public static double[] adjustingFlow()
	{
		return new double[]{
				1, 1, 1, 3, 8, 7, 2, 2, 4, 8, 6, 3, 7, 13, 18, 19, 24, 35, 26, 14, 31,
				43, 49, 55, 61, 67, 61, 50, 43, 37, 30, 16, 5, 4, 4, 3, 3, 3, 4, 4, 3,
				2, 2, 3, 10, 14, 10, 7, 5, 5
		};
	}

	public static double[] random()
	{
		double[] result = new double[100];
		for (int i = 0; i < result.length; i++)
		{
			result[i] = (int) (Math.random() * 100);
		}
		return result;
	}

	public static double[] constantSpeed()
	{
		double[] flowBuckets = new double[10];
		Arrays.fill(flowBuckets, 100);
		return flowBuckets;
	}
}

package net.unethicalite.api.input.naturalmouse.util;

import java.util.Arrays;
import java.util.function.Function;

public class FlowUtil
{
	/**
	 * Stretch flow to longer length. Tries to fill the caps with averages.
	 * <p>
	 * This is an unintuitive method, because it turns out that, for example, array size of 3
	 * scales better to array size of 5 than it does to array size of 6. [1, 2, 3] can be
	 * easily scaled to [1, 1.5, 2, 2.5, 3], but it's not possible without recalculating middle number (2)
	 * with array size of 6, simplistic solutions quickly would run to trouble like this  [1, 1.5, 2, 2.5, 3, (3)? ]
	 * or maybe: [1, 1.5, 2, 2.5, ..., 3 ]. The correct solution would correctly scale the middle numbers
	 *
	 * @param flow         the original flow
	 * @param targetLength the resulting flow length
	 * @return the resulting flow
	 */
	public static double[] stretchFlow(double[] flow, int targetLength)
	{
		return stretchFlow(flow, targetLength, a -> a);
	}

	/**
	 * Stretch flow to longer length. Tries to fill the caps with averages.
	 * <p>
	 * This is an unintuitive method, because it turns out that, for example, array size of 3
	 * scales better to array size of 5 than it does to array size of 6. [1, 2, 3] can be
	 * easily scaled to [1, 1.5, 2, 2.5, 3], but it's not possible without recalculating middle number (2)
	 * with array size of 6, simplistic solutions quickly would run to trouble like this  [1, 1.5, 2, 2.5, 3, (3)? ]
	 * or maybe: [1, 1.5, 2, 2.5, ..., 3 ]. The correct solution would correctly scale the middle numbers
	 * over several indexes.
	 *
	 * @param flow         the original flow
	 * @param targetLength the resulting flow length
	 * @param modifier     modifies the resulting values, you can use this to provide noise or amplify
	 *                     the flow characteristics.
	 * @return the resulting flow
	 */
	public static double[] stretchFlow(double[] flow, int targetLength, Function<Double, Double> modifier)
	{
		if (targetLength < flow.length)
		{
			throw new IllegalArgumentException("Target bucket length smaller than flow. " +
					"" + targetLength + " vs " + flow.length);
		}
		double[] result;
		int tempLength = targetLength;

		if (flow.length != 1 && (tempLength - flow.length) % (flow.length - 1) != 0)
		{
			tempLength = (flow.length - 1) * (tempLength - flow.length) + 1;
		}

		result = new double[tempLength];
		int insider = flow.length - 2;
		int stepLength = (int) ((tempLength - 2) / (double) (insider + 1)) + 1;
		int countToNextStep = stepLength;
		int fillValueIndex = 0;
		for (int i = 0; i < tempLength; i++)
		{
			double fillValueBottom = flow[fillValueIndex];
			double fillValueTop = fillValueIndex + 1 < flow.length ? flow[fillValueIndex + 1] : flow[fillValueIndex];

			double completion = (stepLength - countToNextStep) / (double) stepLength;

			result[i] = fillValueBottom * (1 - completion) + fillValueTop * completion;

			countToNextStep--;

			if (countToNextStep == 0)
			{
				countToNextStep = stepLength;
				fillValueIndex++;
			}
		}

		if (tempLength != targetLength)
		{
			result = reduceFlow(result, targetLength);
		}

		return Arrays.stream(result).map(modifier::apply).toArray();
	}

	/**
	 * Reduction causes loss of information, so the resulting flow is always 'good enough', but is not quaranteed
	 * to be equivalent, just a shorter version of the original flow
	 *
	 * @param flow         the original flow
	 * @param targetLength the resulting array length
	 * @return the resulting flow
	 */
	public static double[] reduceFlow(double[] flow, int targetLength)
	{
		if (flow.length <= targetLength)
		{
			throw new IllegalArgumentException("Bad arguments [" + flow.length + ", " + targetLength + "]");
		}

		double multiplier = targetLength / (double) flow.length;
		double[] result = new double[targetLength];
		for (int i = 0; i < flow.length; i++)
		{
			double index = (i * multiplier);
			double untilIndex = (i + 1) * multiplier;
			int indexInt = (int) index;
			int untilIndexInt = (int) untilIndex;
			if (indexInt != untilIndexInt)
			{
				double resultIndexPortion = 1 - (index - indexInt);
				double nextResultIndexPortion = untilIndex - untilIndexInt;
				result[indexInt] += flow[i] * resultIndexPortion;
				if (untilIndexInt < result.length)
				{
					result[untilIndexInt] += flow[i] * nextResultIndexPortion;
				}
			}
			else
			{
				result[indexInt] += flow[i] * (untilIndex - index);
			}
		}

		return result;
	}
}

package net.unethicalite.api.widgets;

import net.runelite.api.Friend;
import net.unethicalite.client.Static;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class Friends
{
	public static List<Friend> getAll(Predicate<Friend> filter)
	{
		return Arrays.stream(Static.getClient().getFriendContainer().getMembers())
				.filter(filter)
				.collect(Collectors.toList());
	}

	public static List<Friend> getAll(String... names)
	{
		return getAll(x ->
		{
			if (x.getName() == null)
			{
				return false;
			}

			for (String name : names)
			{
				if (name.equals(x.getName()))
				{
					return true;
				}
			}

			return false;
		});
	}

	public static List<Friend> getAll(int... worlds)
	{
		return getAll(x ->
		{
			for (int world : worlds)
			{
				if (world == x.getWorld())
				{
					return true;
				}
			}

			return false;
		});
	}

	public static Friend getFirst(Predicate<Friend> filter)
	{
		return getAll(filter).stream()
				.findFirst()
				.orElse(null);
	}

	public static Friend getFirst(String... names)
	{
		return getFirst(x ->
		{
			if (x.getName() == null)
			{
				return false;
			}

			for (String name : names)
			{
				if (name.equals(x.getName()))
				{
					return true;
				}
			}

			return false;
		});
	}

	public static Friend getFirst(int... worlds)
	{
		return getFirst(x ->
		{
			for (int world : worlds)
			{
				if (world == x.getWorld())
				{
					return true;
				}
			}

			return false;
		});
	}

	public static boolean isAdded(String name)
	{
		return Static.getClient().isFriended(name, false);
	}

	public static boolean isOnline(Friend friend)
	{
		return isOnline(friend.getName());
	}

	public static boolean isOnline(String name)
	{
		return Static.getClient().isFriended(name, true);
	}

	public static void add(String name)
	{
		Static.getClient().addFriend(name);
	}

	public static void remove(String name)
	{
		Static.getClient().removeFriend(name);
	}
}

package net.unethicalite.api.game;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.api.account.GameAccount;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.widgets.Tab;
import net.unethicalite.api.widgets.Tabs;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;
import net.runelite.api.GameState;
import net.runelite.api.packets.ClientPacket;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;

public class Game
{
	private static final int MEMBER_DAYS_VARP = 1780;
	private static final int CUTSCENE_VARBIT = 542;
	private static final String LOGOUT_ACTION = "Logout";

	@Getter
	@Setter
	private static GameAccount gameAccount = null;

	@Deprecated
	public static ClientPacket getClientPacket()
	{
		return Static.getClientPacket();
	}

	public static boolean isLoggedIn()
	{
		return getState() == GameState.LOGGED_IN || getState() == GameState.LOADING;
	}

	public static boolean isOnLoginScreen()
	{
		return getState() == GameState.LOGIN_SCREEN
				|| getState() == GameState.LOGIN_SCREEN_AUTHENTICATOR
				|| getState() == GameState.LOGGING_IN;
	}

	public static GameState getState()
	{
		return Static.getClient().getGameState();
	}

	public static int getWildyLevel()
	{
		Widget wildyLevelWidget = Widgets.get(WidgetInfo.PVP_WILDERNESS_LEVEL);
		if (!Widgets.isVisible(wildyLevelWidget))
		{
			return 0;
		}

		// Dmm
		if (wildyLevelWidget.getText().contains("Guarded")
				|| wildyLevelWidget.getText().contains("Protection"))
		{
			return 0;
		}

		if (wildyLevelWidget.getText().contains("Deadman"))
		{
			return Integer.MAX_VALUE;
		}
		String widgetText = wildyLevelWidget.getText();
		if (widgetText.equals(""))
		{
			return 0;
		}
		if (widgetText.equals("Level: --"))
		{
			Player local = Players.getLocal();
			int y = WorldPoint.fromLocal(Static.getClient(), local.getLocalLocation()).getY();
			return 2 + (y - 3528) / 8;
		}
		String levelText = widgetText.contains("<br>") ? widgetText.substring(0, widgetText.indexOf("<br>")) : widgetText;
		return Integer.parseInt(levelText.replace("Level: ", ""));
	}

	public static int getMembershipDays()
	{
		return Vars.getVarp(MEMBER_DAYS_VARP);
	}

	public static boolean isInCutscene()
	{
		return Vars.getBit(CUTSCENE_VARBIT) > 0;
	}

	public static void logout()
	{
		Widget logOutHopper = Widgets.get(WidgetID.WORLD_SWITCHER_GROUP_ID, x -> x.hasAction(LOGOUT_ACTION));
		if (logOutHopper != null)
		{
			logOutHopper.interact(LOGOUT_ACTION);
			return;
		}

		Widget logOut = Widgets.get(WidgetID.LOGOUT_PANEL_ID, x -> x.hasAction(LOGOUT_ACTION));
		if (logOut != null)
		{
			logOut.interact(LOGOUT_ACTION);
			return;
		}

		if (!Tabs.isOpen(Tab.LOG_OUT))
		{
			Tabs.open(Tab.LOG_OUT);
		}
	}
}

package net.unethicalite.api.account;

public class GameAccount
{
	private final String username;
	private final String password;
	private String auth;

	public GameAccount(String username, String password)
	{
		this.username = username;
		this.password = password;
	}

	public String getUsername()
	{
		return username;
	}

	public String getPassword()
	{
		return password;
	}

	public String getAuth()
	{
		return auth;
	}

	public void setAuth(String auth)
	{
		this.auth = auth;
	}
}

package net.unethicalite.api.game;

import net.unethicalite.api.commons.Time;
import net.unethicalite.api.widgets.Tab;
import net.unethicalite.api.widgets.Tabs;
import net.unethicalite.api.widgets.Widgets;
import net.runelite.api.VarPlayer;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.client.Static;

import java.util.function.Supplier;

public class GameSettings
{

	public enum Display
	{
		FIXED(() -> Widgets.get(WidgetInfo.FIXED_VIEWPORT)),
		RESIZABLE_MODERN(() -> Widgets.get(WidgetInfo.RESIZABLE_VIEWPORT_BOTTOM_LINE_MAGIC_TAB)),
		RESIZABLE_CLASSIC(() -> Widgets.get(WidgetInfo.RESIZABLE_VIEWPORT_INTERFACE_CONTAINER)),
		;

		private final Supplier<Widget> widgetSupplier;

		Display(Supplier<Widget> widgetSupplier)
		{
			this.widgetSupplier = widgetSupplier;
		}

		public Supplier<Widget> getWidgetSupplier()
		{
			return widgetSupplier;
		}

		public static void setMode(Display displayMode)
		{
			if (!Tabs.isOpen(Tab.OPTIONS))
			{
				Tabs.open(Tab.OPTIONS);
				Time.sleepUntil(() -> Tabs.isOpen(Tab.OPTIONS), 2000);
			}

			switch (displayMode)
			{
				case FIXED:
					GameThread.invoke(() -> Static.getClient().runScript(3998, 0));
					break;
				case RESIZABLE_MODERN:
					GameThread.invoke(() -> Static.getClient().runScript(3998, 1));
					break;
				case RESIZABLE_CLASSIC:
					GameThread.invoke(() ->
					{
						// I have no fuckin idea but it works
						Static.getClient().runScript(441, 7602188, 7602213, 7602207, 7602209, 7602214, 7602215, 7602176);
						Static.getClient().interact(1, 57, 2, 7602213);
					});
					break;
			}
		}

		public static Display getCurrentMode()
		{
			for (Display display : values())
			{
				Widget widget = display.getWidgetSupplier().get();
				if (Widgets.isVisible(widget))
				{
					return display;
				}
			}

			return null;
		}
	}

	public enum Audio
	{
		MUSIC(() -> Widgets.get(116, 41), VarPlayer.MUSIC_VOLUME.getId()),
		EFFECTS(() -> Widgets.get(116, 55), VarPlayer.SOUND_EFFECT_VOLUME.getId()),
		AREA(() -> Widgets.get(116, 69), VarPlayer.AREA_EFFECT_VOLUME.getId());

		private final Supplier<Widget> widgetSupplier;
		private final int levelVarp;

		Audio(Supplier<Widget> widgetSupplier, int levelVarp)
		{
			this.widgetSupplier = widgetSupplier;
			this.levelVarp = levelVarp;
		}

		public Supplier<Widget> getWidgetSupplier()
		{
			return widgetSupplier;
		}

		public int getLevel()
		{
			return Vars.getVarp(getLevelVarp());
		}

		public void setVolume(int level)
		{
			if (getLevel() != level)
			{
				if (!Tabs.isOpen(Tab.OPTIONS))
				{
					Tabs.open(Tab.OPTIONS);
					Time.sleepUntil(() -> Tabs.isOpen(Tab.OPTIONS), 2000);
				}

				Widget widget = widgetSupplier.get();
				if (widget != null && widget.getChild(level) != null)
				{
					widget.getChild(level).interact(0);
				}
			}
		}

		public static boolean isFullMuted()
		{
			return MUSIC.getLevel() == 0 && AREA.getLevel() == 0 && EFFECTS.getLevel() == 0;
		}

		public static void muteAll()
		{
			for (Audio audio : values())
			{
				audio.setVolume(0);
			}
		}

		public int getLevelVarp()
		{
			return levelVarp;
		}
	}
}

package net.unethicalite.api.game;

import net.unethicalite.client.Static;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

@Slf4j
public class GameThread
{
	private static final long TIMEOUT = 1000;

	public static void invoke(Runnable runnable)
	{
		if (Static.getClient().isClientThread())
		{
			runnable.run();
		}
		else
		{
			Static.getClientThread().invokeLater(runnable);
		}
	}

	public static <T> T invokeLater(Callable<T> callable)
	{
		if (Static.getClient().isClientThread())
		{
			try
			{
				return callable.call();
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}

		try
		{
			FutureTask<T> futureTask = new FutureTask<>(callable);
			Static.getClientThread().invokeLater(futureTask);
			return futureTask.get(TIMEOUT, TimeUnit.MILLISECONDS);
		}
		catch (ExecutionException | InterruptedException | TimeoutException e)
		{
			e.printStackTrace();
			throw new RuntimeException("Client thread invoke timed out after " + TIMEOUT + " ms");
		}
	}
}


package net.unethicalite.api.movement.pathfinder;

import net.runelite.api.coords.Direction;
import net.unethicalite.api.movement.Reachable;
import net.unethicalite.client.Static;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Objects;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

public class GlobalCollisionMap implements CollisionMap
{
	public final BitSet4D[] regions = new BitSet4D[256 * 256];

	public GlobalCollisionMap()
	{
	}

	public GlobalCollisionMap(byte[] data)
	{
		var buffer = ByteBuffer.wrap(data);

		while (buffer.hasRemaining())
		{
			var region = buffer.getShort() & 0xffff;
			regions[region] = new BitSet4D(buffer, 64, 64, 4, 2);
		}
	}

	public File writeToFile()
	{
		byte[] bytes = toBytes();
		File fileLoc = new File("collision-map");
		if (!fileLoc.isFile())
		{
			try
			{
				fileLoc.createNewFile();
			}
			catch (IOException e)
			{
				e.printStackTrace();
			}
		}

		try (ByteArrayOutputStream bos = new ByteArrayOutputStream(bytes.length);
			 GZIPOutputStream gos = new GZIPOutputStream(bos);
			 FileOutputStream fos = new FileOutputStream(fileLoc))
		{
			gos.write(bytes);
			gos.finish();
			fos.write(bos.toByteArray());
			gos.flush();
			fos.flush();
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}

		return fileLoc;
	}

	public byte[] toBytes()
	{
		var regionCount = (int) Arrays.stream(regions).filter(Objects::nonNull).count();
		var buffer = ByteBuffer.allocate(regionCount * (2 + 64 * 64 * 4 * 2 / 8));

		for (var i = 0; i < regions.length; i++)
		{
			if (regions[i] != null)
			{
				buffer.putShort((short) i);
				regions[i].write(buffer);
			}
		}

		return buffer.array();
	}

	public void set(int x, int y, int z, int w, boolean value)
	{
		var region = regions[x / 64 * 256 + y / 64];

		if (region == null)
		{
			return;
		}

		region.set(x % 64, y % 64, z, w, value);
	}

	public BitSet4D getRegion(int x, int y)
	{
		int regionId = x / 64 * 256 + y / 64;
		return regions[regionId];
	}

	public void createRegion(int region)
	{
		regions[region] = new BitSet4D(64, 64, 4, 2);
		regions[region].setAll(true);
	}

	public boolean get(int x, int y, int z, int w)
	{
		var region = getRegion(x, y);

		if (region == null)
		{
			return false;
		}

		int regionX = x % 64;
		int regionY = y % 64;

		return region.get(regionX, regionY, z, w);
	}

	public GlobalCollisionMap copy()
	{
		return new GlobalCollisionMap(this.toBytes());
	}

	public GlobalCollisionMap withLocalCollisions()
	{
		GlobalCollisionMap newMap = this.copy();
		Static.getRegionManager().getTileFlags().forEach(tileFlag ->
		{
			int region = tileFlag.getRegion();
			int x = tileFlag.getX();
			int y = tileFlag.getY();
			int z = tileFlag.getZ();
			int flag = tileFlag.getFlag();

			if (newMap.regions[region] == null)
			{
				newMap.createRegion(region);
			}

			if (Reachable.isObstacle(flag))
			{
				newMap.set(x, y, z, 0, false);
				newMap.set(x, y, z, 1, false);
			}
			else
			{
				newMap.set(x, y, z, 0, true);
				newMap.set(x, y, z, 1, true);

				if (Reachable.isWalled(Direction.NORTH, flag))
				{
					newMap.set(x, y, z, 0, false);
				}

				if (Reachable.isWalled(Direction.EAST, flag))
				{
					newMap.set(x, y, z, 1, false);
				}
			}
		});
		return newMap;
	}

	public void overwrite(GlobalCollisionMap globalCollisionMap)
	{
		System.arraycopy(globalCollisionMap.regions, 0, regions, 0, regions.length);
	}

	@Override
	public boolean n(int x, int y, int z)
	{
		return get(x, y, z, 0);
	}

	@Override
	public boolean e(int x, int y, int z)
	{
		return get(x, y, z, 1);
	}

	public static GlobalCollisionMap fetchFromUrl(String url) throws IOException
	{
		try (InputStream is = Walker.class.getResourceAsStream("/regions"))
		{
			if (is == null)
			{
				return new GlobalCollisionMap();
			}

			return new GlobalCollisionMap(
					new GZIPInputStream(new ByteArrayInputStream(is.readAllBytes())).readAllBytes()
			);
		}
	}
}


package net.unethicalite.api.items;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.Item;
import net.runelite.api.TileObject;
import net.runelite.api.VarClientInt;
import net.runelite.api.VarPlayer;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.commons.Time;
import net.unethicalite.api.entities.TileObjects;
import net.unethicalite.api.game.Game;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class GrandExchange
{
	private static final int F2P_SLOTS = 3;
	private static final int P2P_SLOTS = 8;
	private static final int PRICE_VARBIT = 4398;
	private static final int QUANTITY_VARBIT = 4396;
	private static final Supplier<Widget> COLLECT_BUTTON = () -> Widgets.get(WidgetID.GRAND_EXCHANGE_GROUP_ID, 6, 0);
	private static final Supplier<Widget> CONFIRM_BUTTON = () -> Widgets.get(WidgetID.GRAND_EXCHANGE_GROUP_ID, 29);
	private static final Supplier<Widget> OFFER_PRICE = () -> Widgets.get(WidgetID.GRAND_EXCHANGE_GROUP_ID, 27);
	private static final Supplier<Widget> EXIT = () -> Widgets.get(WidgetID.GRAND_EXCHANGE_GROUP_ID, 2, 11);

	public static View getView()
	{
		Widget setupWindow = Widgets.get(WidgetInfo.GRAND_EXCHANGE_OFFER_CONTAINER);
		if (Widgets.isVisible(setupWindow))
		{
			String text = setupWindow.getChild(18).getText();
			if (text == null || text.isEmpty())
			{
				return View.UNKNOWN;
			}

			if (text.equals("Sell offer"))
			{
				return View.SELLING;
			}

			if (text.equals("Buy offer"))
			{
				return View.BUYING;
			}

			// Widgets broke
			return View.UNKNOWN;
		}

		Widget geWindow = Widgets.get(WidgetInfo.GRAND_EXCHANGE_WINDOW_CONTAINER);
		if (Widgets.isVisible(geWindow))
		{
			return View.OFFERS;
		}

		return View.CLOSED;
	}

	public static boolean isOpen()
	{
		return getView() != View.CLOSED && getView() != View.UNKNOWN;
	}

	public static boolean isSetupOpen()
	{
		return getView() == View.BUYING || getView() == View.SELLING;
	}

	public static void openBank()
	{
		TileObject bank = TileObjects.getFirstSurrounding(3163, 3490, 0, 5, x -> x.getName() != null
				&& x.getName().toLowerCase().contains("exchange booth") && x.hasAction("Bank"));
		if (bank != null)
		{
			bank.interact("Bank");
		}
	}

	public static boolean isSelling()
	{
		return getView() == View.SELLING;
	}

	public static boolean isBuying()
	{
		return getView() == View.BUYING;
	}

	public static int getItemId()
	{
		return Vars.getVarp(VarPlayer.CURRENT_GE_ITEM.getId());
	}

	public static void setItem(int id)
	{
		GameThread.invoke(() -> Static.getClient().runScript(754, id, 84));
	}

	public static int getPrice()
	{
		return Vars.getBit(PRICE_VARBIT);
	}

	public static void setPrice(int price)
	{
		Widget enterPriceButton = Widgets.get(WidgetInfo.GRAND_EXCHANGE_OFFER_CONTAINER);
		if (enterPriceButton != null && enterPriceButton.getChild(12) != null)
		{
			enterPriceButton.getChild(12).interact("Enter price");
			Dialog.enterAmount(price);
		}
	}

	public static int getQuantity()
	{
		return Vars.getBit(QUANTITY_VARBIT);
	}

	public static void setQuantity(int quantity)
	{
		Widget enterPriceButton = Widgets.get(WidgetInfo.GRAND_EXCHANGE_OFFER_CONTAINER);
		if (enterPriceButton != null && enterPriceButton.getChild(7) != null)
		{
			enterPriceButton.getChild(7).interact("Enter quantity");
			Dialog.enterAmount(quantity);
		}
	}

	public static int getGuidePrice()
	{
		Widget priceWidget = OFFER_PRICE.get();
		if (priceWidget != null)
		{
			return Integer.parseInt(priceWidget.getText().replaceAll("[^0-9]", ""));
		}

		return -1;
	}

	public static void open()
	{
		TileObject booth = TileObjects.getFirstSurrounding(3163, 3490, 0, 5, x -> x.hasAction("Exchange"));
		if (booth != null)
		{
			booth.interact("Exchange");
		}
	}

	public static void close()
	{
		Widget exitButton = EXIT.get();
		if (!Widgets.isVisible(exitButton))
		{
			return;
		}

		exitButton.interact("Close");
	}

	public static void sell(Predicate<Item> filter)
	{
		Item item = Inventory.getFirst(filter);
		if (item != null)
		{
			Static.getClient().interact(1, 57, item.getSlot(), 30605312);
		}
	}

	public static void sell(int... ids)
	{
		sell(x -> Arrays.stream(ids).anyMatch(y -> y == x.getId() || y == x.getNotedId()));
	}

	public static void sell(String... names)
	{
		sell(Predicates.names(names));
	}

	public static void createBuyOffer()
	{
		List<Widget> geRoot = Widgets.get(465);

		if (isFull())
		{
			return;
		}

		if (geRoot == null)
		{
			return;
		}

		for (int i = 7; i < 15; i++)
		{
			Widget box = geRoot.get(i);
			if (box == null)
			{
				continue;
			}

			Widget buyButton = box.getChild(3);
			if (!Widgets.isVisible(buyButton))
			{
				continue;
			}

			buyButton.interact(0);
			return;
		}
	}

	public static void abortOffer(int itemId)
	{
		List<Widget> geRoot = Widgets.get(465);

		if (isEmpty())
		{
			return;
		}

		if (geRoot == null)
		{
			return;
		}

		for (int i = 7; i < 15; i++)
		{
			Widget box = geRoot.get(i);
			if (box == null)
			{
				continue;
			}

			Widget abortBox = box.getChild(2);
			if (abortBox == null || !abortBox.hasAction("Abort offer") || !abortBox.isVisible())
			{
				continue;
			}

			Widget itemIdBox = box.getChild(18);
			if (itemIdBox == null || !itemIdBox.isVisible())
			{
				continue;
			}

			if (itemIdBox.getItemId() == itemId)
			{
				abortBox.interact("Abort offer");
				return;
			}
		}
	}

	public static boolean isFull()
	{
		return getEmptySlots() == 0;
	}

	public static boolean isEmpty()
	{
		return getOffers().size() == 0;
	}

	public static int getEmptySlots()
	{
		return Game.getMembershipDays() <= 0 ? F2P_SLOTS - getOffers().size() : P2P_SLOTS - getOffers().size();
	}

	public static List<GrandExchangeOffer> getOffers()
	{
		List<GrandExchangeOffer> out = new ArrayList<>();
		GrandExchangeOffer[] offers = Static.getClient().getGrandExchangeOffers();
		if (offers != null)
		{
			for (GrandExchangeOffer offer : offers)
			{
				if (offer.getItemId() > 0)
				{
					out.add(offer);
				}
			}
		}

		return out;
	}

	public static boolean canCollect()
	{
		return Widgets.isVisible(COLLECT_BUTTON.get());
	}

	public static void collect()
	{
		collect(false);
	}

	public static void collect(boolean toBank)
	{
		Widget collect = COLLECT_BUTTON.get();
		if (Widgets.isVisible(collect))
		{
			collect.interact(toBank ? "Collect to bank" : "Collect to inventory");
		}
	}

	public static void confirm()
	{
		Widget confirm = CONFIRM_BUTTON.get();
		if (Widgets.isVisible(confirm))
		{
			confirm.interact("Confirm");
		}
	}

	public static boolean isSearchingItem()
	{
		return Vars.getVarcInt(VarClientInt.INPUT_TYPE) == 14;
	}

	public static void openItemSearch()
	{
		Static.getClient().interact(1, 57, 0, 30474264);
	}

	public static boolean sell(int itemId, int quantity, int price)
	{
		return exchange(false, itemId, quantity, price, true, false);
	}

	public static boolean sell(int itemId, int quantity, int price, boolean collect, boolean toBank)
	{
		return exchange(false, itemId, quantity, price, collect, toBank);
	}

	public static boolean buy(int itemId, int quantity, int price)
	{
		return exchange(true, itemId, quantity, price, true, false);
	}

	public static boolean buy(int itemId, int quantity, int price, boolean collect, boolean toBank)
	{
		return exchange(true, itemId, quantity, price, collect, toBank);
	}

	public static boolean exchange(boolean buy, int itemId, int quantity, int price)
	{
		return exchange(buy, itemId, quantity, price, true, false);
	}

	public static boolean exchange(boolean buy, int itemId, int quantity, int price, boolean collect, boolean toBank)
	{
		if (!isOpen())
		{
			open();
			return false;
		}

		if (collect && canCollect())
		{
			collect(toBank);
			return false;
		}

		if (buy)
		{
			if (!isBuying())
			{
				createBuyOffer();
				return false;
			}
		}
		else
		{
			if (!isSelling())
			{
				sell(itemId);
				return false;
			}
		}

		int notedId = Static.getClient().isItemDefinitionCached(itemId) ?
			Static.getClient().getItemComposition(itemId).getLinkedNoteId() :
			GameThread.invokeLater(() -> Static.getClient().getItemComposition(itemId).getLinkedNoteId());

		if (getItemId() == -1 || (getItemId() != itemId && getItemId() != notedId))
		{
			if (buy)
			{
				if (!isSearchingItem())
				{
					openItemSearch();
				}

				setItem(itemId);
			}
			else
			{
				sell(itemId);
			}

			return false;
		}

		if (getPrice() != price)
		{
			setPrice(price);
		}

		if (getQuantity() != quantity)
		{
			setQuantity(quantity);
		}

		Time.sleepUntil(() -> getPrice() == price && getQuantity() == quantity, 3000);

		if (getPrice() == price && getQuantity() == quantity)
		{
			confirm();
			return true;
		}

		return false;
	}

	public enum View
	{
		CLOSED, OFFERS, BUYING, SELLING, UNKNOWN
	}
}

package net.unethicalite.api.packets;

import net.runelite.api.TileItem;
import net.runelite.api.packets.PacketBufferNode;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

public class GroundItemPackets
{
	public static void groundItemFirstOption(TileItem item, boolean ctrlDown)
	{
		queueGroundItemAction1Packet(item.getId(), item.getWorldLocation().getX(), item.getWorldLocation().getY(), ctrlDown);
	}

	public static void groundItemSecondOption(TileItem item, boolean ctrlDown)
	{
		queueGroundItemAction2Packet(item.getId(), item.getWorldLocation().getX(), item.getWorldLocation().getY(), ctrlDown);
	}

	public static void groundItemThirdOption(TileItem item, boolean ctrlDown)
	{
		queueGroundItemAction3Packet(item.getId(), item.getWorldLocation().getX(), item.getWorldLocation().getY(), ctrlDown);
	}

	public static void groundItemFourthOption(TileItem item, boolean ctrlDown)
	{
		queueGroundItemAction4Packet(item.getId(), item.getWorldLocation().getX(), item.getWorldLocation().getY(), ctrlDown);
	}

	public static void groundItemFifthOption(TileItem item, boolean ctrlDown)
	{
		queueGroundItemAction5Packet(item.getId(), item.getWorldLocation().getX(), item.getWorldLocation().getY(), ctrlDown);
	}

	public static void groundItemAction(TileItem item, String action, boolean ctrlDown)
	{
		int index = item.getActionIndex(action);
		switch (index)
		{
			case 0:
				groundItemFirstOption(item, ctrlDown);
				break;
			case 1:
				groundItemSecondOption(item, ctrlDown);
				break;
			case 2:
				groundItemThirdOption(item, ctrlDown);
				break;
			case 3:
				groundItemFourthOption(item, ctrlDown);
				break;
			case 4:
				groundItemFifthOption(item, ctrlDown);
				break;
		}
	}

	public static void queueItemUseOnGroundObjectPacket(int groundItemId, int worldPointX, int worldPointY, int itemSlot, int itemId, int itemWidgetId, boolean ctrlDown)
	{
		createItemOnGroundItem(groundItemId, worldPointX, worldPointY, itemSlot, itemId, itemWidgetId, ctrlDown).send();
	}

	public static void queueSpellOnGroundObjectPacket(int groundItemId, int worldPointX, int worldPointY, int spellWidgetId, boolean ctrlDown)
	{
		createSpellOnGroundItem(groundItemId, worldPointX, worldPointY, spellWidgetId, ctrlDown).send();
	}

	public static void queueGroundItemAction1Packet(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createFirstAction(groundItemId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueGroundItemAction2Packet(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createSecondAction(groundItemId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueGroundItemAction3Packet(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createThirdAction(groundItemId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueGroundItemAction4Packet(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createFourthAction(groundItemId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueGroundItemAction5Packet(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createFifthAction(groundItemId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static PacketBufferNode createItemOnGroundItem(int groundItemId, int worldPointX, int worldPointY, int itemSlot, int itemId, int itemWidgetId, boolean ctrlDown)
	{
		return createWidgetOnGroundItem(groundItemId, worldPointX, worldPointY, itemSlot, itemId, itemWidgetId, ctrlDown);
	}

	public static PacketBufferNode createWidgetOnGroundItem(int groundItemId, int worldPointX, int worldPointY, int sourceSlot, int sourceItemId, int sourceWidgetId, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.OPOBJT(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeIntIME(sourceWidgetId);
		packetBufferNode.getPacketBuffer().writeShortAddLE(sourceSlot);
		packetBufferNode.getPacketBuffer().writeShort(groundItemId);
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointX);
		packetBufferNode.getPacketBuffer().writeShortAdd(worldPointY);
		packetBufferNode.getPacketBuffer().writeShortAdd(sourceItemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createSpellOnGroundItem(int groundItemId, int worldPointX, int worldPointY, int spellWidgetId, boolean ctrlDown)
	{
		return createWidgetOnGroundItem(groundItemId, worldPointX, worldPointY, -1, -1, spellWidgetId, ctrlDown);
	}

	public static PacketBufferNode createFirstAction(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.OPOBJ1(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAddLE(groundItemId);
		packetBufferNode.getPacketBuffer().writeShort(worldPointY);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointX);
		return packetBufferNode;
	}

	public static PacketBufferNode createSecondAction(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.OPOBJ2(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(worldPointY);
		packetBufferNode.getPacketBuffer().writeShortAddLE(groundItemId);
		packetBufferNode.getPacketBuffer().writeByte(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointX);
		return packetBufferNode;
	}

	public static PacketBufferNode createThirdAction(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		PacketBufferNode packetBufferNode = Static.getClient().preparePacket(clientPacket.OPOBJ3(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(worldPointX);
		packetBufferNode.getPacketBuffer().writeByte(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAddLE(groundItemId);
		packetBufferNode.getPacketBuffer().writeShortAdd(worldPointY);
		return packetBufferNode;
	}

	public static PacketBufferNode createFourthAction(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPOBJ4(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(worldPointX);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointY);
		packetBufferNode.getPacketBuffer().writeShortLE(groundItemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createFifthAction(int groundItemId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPOBJ5(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointY);
		packetBufferNode.getPacketBuffer().writeByteNeg(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShort(worldPointX);
		packetBufferNode.getPacketBuffer().writeShortLE(groundItemId);
		return packetBufferNode;
	}
}
package net.unethicalite.api.game;

import com.openosrs.client.game.WorldLocation;
import net.runelite.api.coords.WorldPoint;

public class House
{
	public static final int HOUSE_LOCATION_VARBIT = 2187;
	public static final WorldLocation[] HOUSE_LOCATIONS = {
		WorldLocation.RIMMINGTON_PORTAL,
		WorldLocation.TAVERLY_POH_PORTAL,
		WorldLocation.POLLNIVNEACH_POH_PORTAL,
		WorldLocation.RELLEKKA_POH_PORTAL,
		WorldLocation.BRIMHAVEN_POH_PORTAL,
		WorldLocation.YANILLE_POH_PORTAL,
		WorldLocation.PRIFDDINAS_POH_PORTAL,
		WorldLocation.HOSIDIUS_POH_PORTAL
	};

	public static WorldPoint getOutsideLocation()
	{
		if (!Game.isLoggedIn())
		{
			return null;
		}

		int idx = Vars.getBit(HOUSE_LOCATION_VARBIT);
		if (idx >= HOUSE_LOCATIONS.length || idx < 0)
		{
			return null;
		}

		return HOUSE_LOCATIONS[idx - 1].getWorldArea().getCenter();
	}

}

package net.unethicalite.api.movement.pathfinder.model.poh;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
@AllArgsConstructor
public enum HousePortal
{
    ARCEUUS_LIBRARY(new WorldPoint(1634, 3836, 0), "Arceuus Library Portal", "Arceuus Library"),
    DRAYNOR_MANOR(new WorldPoint(3109, 3352, 0), "Draynor Manor Portal", "Draynor Manor"),
    BATTLEFRONT(new WorldPoint(1350, 3740, 0), "Battlefront Portal", "Battlefront"),
    VARROCK(new WorldPoint(3212, 3424, 0), "Varrock Portal", "Varrock"),
    MIND_ALTAR(new WorldPoint(2978, 3508, 0), "Mind Altar Portal", "Mind Altar"),
    LUMBRIDGE(new WorldPoint(3225, 3219, 0), "Lumbridge Portal", "Lumbridge"),
    FALADOR(new WorldPoint(2966, 3379, 0), "Falador Portal", "Falador"),
    SALVE_GRAVEYARD(new WorldPoint(3431, 3460, 0), "Salve Graveyard Portal", "Salve Graveyard"),
    CAMELOT(new WorldPoint(2757, 3479, 0), "Camelot Portal", "Camelot"),
    FENKENSTRAINS_CASTLE(new WorldPoint(3546, 3528, 0), "Fenkenstrain' Castle Portal", "Fenken' Castle"),
    EAST_ARDOUGNE(new WorldPoint(2661, 3300, 0), "Ardougne Portal", "Ardougne"),
    WATCHTOWER(new WorldPoint(2931, 4717, 2), "Yanille Watchtower Portal", "Watchtower"),
    SENNTISTEN(new WorldPoint(3321, 3335, 0), "Senntisten Portal", "Senntisten"),
    WEST_ARDOUGNE(new WorldPoint(2502, 3291, 0), "West Ardougne Portal", "West Ardougne"),
    MARIM(new WorldPoint(2796, 2791, 0), "Marim Portal", "Marim"),
    HARMONY_ISLAND(new WorldPoint(3799, 2867, 0), "Harmony Island Portal", "Harmony Island"),
    KHARYRLL(new WorldPoint(3493, 3474, 0), "Kharyrll Portal", "Kharyrll"),
    LUNAR_ISLE(new WorldPoint(2113, 3917, 0), "Lunar Isle Portal", "Lunar Isle"),
    KOUREND(new WorldPoint(1643, 3673, 0), "Kourend Portal", "Kourend Castle"),
    CEMETERY(new WorldPoint(2978, 3763, 0), "Cemetery Portal", "Cementry"),
    WATERBIRTH_ISLAND(new WorldPoint(2548, 3758, 0), "Waterbirth Island Portal", "Waterbirth Island"),
    BARROWS(new WorldPoint(3563, 3313, 0), "Barrows Portal", "Barrows"),
    CARRALLANGAR(new WorldPoint(3157, 3667, 0), "Carrallangar Portal", "Carrallangar"),
    FISHING_GUILD(new WorldPoint(2610, 3389, 0), "Fishing Guild Portal", "Fishing Guild"),
    CATHERBY(new WorldPoint(2802, 3449, 0), "Catherby Portal", "Catherby"),
    ANNAKARL(new WorldPoint(3288, 3888, 0), "Annakarl Portal", "Annakarl"),
    APE_ATOLL_DUNGEON(new WorldPoint(2769, 9100, 0), "Ape Atoll Dungeon Portal", "Ape Atoll Dungeon"),
    GHORROCK(new WorldPoint(2977, 3872, 0), "Ghorrock Portal", "Ghorrock"),
    TROLL_STRONGHOLD(new WorldPoint(2844, 3693, 0), "Troll Stronghold Portal", "Troll Stronghold"),
    WEISS(new WorldPoint(2846, 3940, 0), "Weiss Portal", "Weiss"),
    ;

    private final WorldPoint destination;
	private final String portalName;
	private final String nexusTarget;
}
package net.unethicalite.api.commons;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import lombok.extern.slf4j.Slf4j;
import net.unethicalite.client.config.UnethicaliteProperties;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

@Slf4j
public class HttpUtil
{
	private static final Gson GSON = new GsonBuilder().create();

	public static <T> T readJson(String url, Class<T> expectedType)
	{
		try
		{
			URL httpUrl = new URL(url);
			URLConnection conn = httpUrl.openConnection();

			conn.setConnectTimeout(UnethicaliteProperties.getConnectionTimeout());
			conn.setReadTimeout(UnethicaliteProperties.getReadTimeout());

			try (InputStream stream = conn.getInputStream())
			{
				return GSON.fromJson(new String(stream.readAllBytes()), expectedType);
			}
			catch (IOException e)
			{
				log.error("Failed to read data", e);
				return null;
			}
		}
		catch (IOException e)
		{
			log.error("Failed to connect to url", e);
			return null;
		}
	}

	public static byte[] readBytes(String url)
	{
		try
		{
			URL httpUrl = new URL(url);
			URLConnection conn = httpUrl.openConnection();

			conn.setConnectTimeout(UnethicaliteProperties.getConnectionTimeout());
			conn.setReadTimeout(UnethicaliteProperties.getReadTimeout());

			try (InputStream stream = conn.getInputStream())
			{
				return stream.readAllBytes();
			}
			catch (IOException e)
			{
				log.error("Failed to read data", e);
				return null;
			}
		}
		catch (IOException e)
		{
			log.error("Failed to connect to url", e);
			return null;
		}
	}
}

package net.unethicalite.api.items;

import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.query.items.ItemQuery;
import net.unethicalite.client.managers.InventoryManager;

import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class Inventory extends Items
{
	private Inventory()
	{
		super(InventoryID.INVENTORY, item ->
		{
			item.setWidgetId(WidgetInfo.INVENTORY.getPackedId());
			return true;
		});
	}

	private static final Inventory INVENTORY = new Inventory();

	public static ItemQuery query()
	{
		return query(Inventory::getAll);
	}

	public static ItemQuery query(Supplier<List<Item>> supplier)
	{
		return new ItemQuery(supplier);
	}

	public static List<Item> getAll(Predicate<Item> filter)
	{
		return INVENTORY.all(filter);
	}

	public static List<Item> getAll()
	{
		return getAll(x -> true);
	}

	public static List<Item> getAll(int... ids)
	{
		return INVENTORY.all(ids);
	}

	public static List<Item> getAll(String... names)
	{
		return INVENTORY.all(names);
	}

	public static Item getFirst(Predicate<Item> filter)
	{
		return INVENTORY.first(filter);
	}

	public static Item getFirst(int... ids)
	{
		return INVENTORY.first(ids);
	}

	public static Item getFirst(String... names)
	{
		return INVENTORY.first(names);
	}

	public static Item getItem(int slot)
	{
		Item[] container = InventoryManager.getCachedContainers().get(InventoryID.INVENTORY.getId());
		if (container == null)
		{
			return null;
		}

		Item item = container[slot];
		if (item == null || item.getId() == -1 || item.getName() == null || item.getName().equals("null"))
		{
			return null;
		}

		item.setWidgetId(WidgetInfo.INVENTORY.getPackedId());
		return item;
	}

	public static boolean contains(Predicate<Item> filter)
	{
		return INVENTORY.exists(filter);
	}

	public static boolean contains(int... id)
	{
		return INVENTORY.exists(id);
	}

	public static boolean contains(String... name)
	{
		return INVENTORY.exists(name);
	}

	public static int getCount(boolean stacks, Predicate<Item> filter)
	{
		return INVENTORY.count(stacks, filter);
	}

	public static int getCount(boolean stacks, int... ids)
	{
		return INVENTORY.count(stacks, ids);
	}

	public static int getCount(boolean stacks, String... names)
	{
		return INVENTORY.count(stacks, names);
	}

	public static int getCount(Predicate<Item> filter)
	{
		return INVENTORY.count(false, filter);
	}

	public static int getCount(int... ids)
	{
		return INVENTORY.count(false, ids);
	}

	public static int getCount(String... names)
	{
		return INVENTORY.count(false, names);
	}

	public static boolean isFull()
	{
		return getFreeSlots() == 0;
	}

	public static boolean isEmpty()
	{
		return getFreeSlots() == 28;
	}

	public static int getFreeSlots()
	{
		return 28 - getAll().size();
	}
}

package net.unethicalite.api.packets;

import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.packets.PacketBufferNode;
import net.runelite.api.widgets.WidgetInfo;

public class ItemPackets
{
	public static void itemAction(Item item, String action)
	{
		int index = item.getActionIndex(action);
		switch (index)
		{
			case 0:
				ItemPackets.itemFirstOption(item);
				break;
			case 1:
				ItemPackets.itemSecondOption(item);
				break;
			case 2:
				ItemPackets.itemThirdOption(item);
				break;
			case 3:
				ItemPackets.itemFourthOption(item);
				break;
			case 4:
				ItemPackets.itemFifthOption(item);
				break;
			case 5:
				ItemPackets.itemSixthOption(item);
				break;
			case 6:
				ItemPackets.itemSeventhOption(item);
				break;
			case 7:
				ItemPackets.itemEighthOption(item);
				break;
			case 8:
				ItemPackets.itemNinthOption(item);
				break;
			case 9:
				ItemPackets.itemTenthOption(item);
				break;
		}
	}

	public static void itemFirstOption(Item item)
	{
		ItemPackets.queueItemAction1Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemSecondOption(Item item)
	{
		ItemPackets.queueItemAction2Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemThirdOption(Item item)
	{
		ItemPackets.queueItemAction3Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemFourthOption(Item item)
	{
		ItemPackets.queueItemAction4Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemFifthOption(Item item)
	{
		ItemPackets.queueItemAction5Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemSixthOption(Item item)
	{
		ItemPackets.queueItemAction6Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemSeventhOption(Item item)
	{
		ItemPackets.queueItemAction7Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemEighthOption(Item item)
	{
		ItemPackets.queueItemAction8Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemNinthOption(Item item)
	{
		ItemPackets.queueItemAction9Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void itemTenthOption(Item item)
	{
		ItemPackets.queueItemAction10Packet(item.getWidgetId(), item.getId(), item.getSlot());
	}

	public static void useItemOnItem(Item item, Item item2)
	{
		if (item.getType().getInventoryID() != InventoryID.INVENTORY || item2.getType().getInventoryID() != InventoryID.INVENTORY)
		{
			return;
		}
		ItemPackets.queueItemOnItemPacket(item.getId(), item.getSlot(), item2.getId(), item2.getSlot());
	}

	public static void queueItemOnItemPacket(int sourceItemId, int sourceItemSlot, int itemId, int itemSlot)
	{
		ItemPackets.createItemOnItem(sourceItemId, sourceItemSlot, itemId, itemSlot).send();
	}

	public static void queueSpellOnItemPacket(int itemId, int itemSlot, int spellWidgetId)
	{
		ItemPackets.createSpellOnItem(itemId, itemSlot, spellWidgetId).send();
	}

	public static void queueItemAction1Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createFirstAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction2Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createSecondAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction3Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createThirdAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction4Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createFourthAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction5Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createFifthAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction6Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createSixthAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction7Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createSeventhAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction8Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createEighthAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction9Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createNinthAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static void queueItemAction10Packet(int itemWidgetId, int itemId, int itemSlot)
	{
		ItemPackets.createTenthAction(itemWidgetId, itemId, itemSlot).send();
	}

	public static PacketBufferNode createItemOnItem(int sourceItemId, int sourceItemSlot, int itemId, int itemSlot)
	{
		return WidgetPackets.createWidgetOnWidget(WidgetInfo.INVENTORY.getId(), sourceItemSlot, sourceItemId, WidgetInfo.INVENTORY.getId(), itemSlot, itemId);
	}

	public static PacketBufferNode createSpellOnItem(int itemId, int itemSlot, int spellWidgetId)
	{
		return WidgetPackets.createWidgetOnWidget(spellWidgetId, -1, -1, WidgetInfo.INVENTORY.getId(), itemSlot, itemId);
	}

	public static PacketBufferNode createFirstAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createFirstAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createSecondAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createSecondAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createThirdAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createThirdAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createFourthAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createFourthAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createFifthAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createFifthAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createSixthAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createSixthAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createSeventhAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createSeventhAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createEighthAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createEighthAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createNinthAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createNinthAction(itemWidgetId, itemId, itemSlot);
	}

	public static PacketBufferNode createTenthAction(int itemWidgetId, int itemId, int itemSlot)
	{
		return WidgetPackets.createTenthAction(itemWidgetId, itemId, itemSlot);
	}
}
package net.unethicalite.api.query.items;

import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.query.Query;
import net.unethicalite.api.query.results.ItemQueryResults;
import net.runelite.api.Item;
import org.apache.commons.lang3.ArrayUtils;

import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;

public class ItemQuery extends Query<Item, ItemQuery, ItemQueryResults>
{
	private int[] ids = null;
	private int[] notedIds = null;
	private int[] slots = null;
	private String[] names = null;
	private String[] actions = null;
	private Boolean tradable = null;
	private Boolean stackable = null;
	private Boolean members = null;
	private Boolean noted = null;
	private Integer storePrice = null;

	public ItemQuery(Supplier<List<Item>> supplier)
	{
		super(supplier);
	}

	public ItemQuery ids(int... ids)
	{
		this.ids = ids;
		return this;
	}

	public ItemQuery notedIds(int... notedIds)
	{
		this.notedIds = notedIds;
		return this;
	}

	public ItemQuery slots(int... slots)
	{
		this.slots = slots;
		return this;
	}

	public ItemQuery names(String... names)
	{
		this.names = names;
		return this;
	}

	public ItemQuery actions(String... actions)
	{
		this.actions = actions;
		return this;
	}

	public ItemQuery tradable(boolean tradable)
	{
		this.tradable = tradable;
		return this;
	}

	public ItemQuery stackable(boolean stackable)
	{
		this.stackable = stackable;
		return this;
	}

	public ItemQuery members(boolean members)
	{
		this.members = members;
		return this;
	}

	public ItemQuery noted(boolean noted)
	{
		this.noted = noted;
		return this;
	}

	public ItemQuery storePrice(int storePrice)
	{
		this.storePrice = storePrice;
		return this;
	}

	@Override
	protected ItemQueryResults results(List<Item> list)
	{
		return new ItemQueryResults(list);
	}

	@Override
	public boolean test(Item item)
	{
		if (ids != null && !ArrayUtils.contains(ids, item.getId()))
		{
			return false;
		}

		if (notedIds != null && !ArrayUtils.contains(notedIds, item.getId()))
		{
			return false;
		}

		if (slots != null && !ArrayUtils.contains(slots, item.getSlot()))
		{
			return false;
		}

		if (names != null && !ArrayUtils.contains(names, item.getName()))
		{
			return false;
		}

		if (actions != null && Arrays.stream(actions).noneMatch(Predicates.texts(item.getActions())))
		{
			return false;
		}

		if (tradable != null && tradable != item.isTradable())
		{
			return false;
		}

		if (stackable != null && stackable != item.isStackable())
		{
			return false;
		}

		if (members != null && members != item.isMembers())
		{
			return false;
		}

		if (noted != null && noted != item.isNoted())
		{
			return false;
		}

		if (storePrice != null && storePrice != item.getStorePrice())
		{
			return false;
		}

		return super.test(item);
	}
}

package net.unethicalite.api.query.results;

import net.runelite.api.Item;

import java.util.List;

public class ItemQueryResults extends QueryResults<Item, ItemQueryResults>
{
	public ItemQueryResults(List<Item> results)
	{
		super(results);
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import lombok.Value;
import net.unethicalite.api.items.Equipment;
import net.unethicalite.api.items.Inventory;

import java.util.List;

@Value
public class ItemRequirement implements Requirement
{
    Reduction reduction;
    boolean equipped;
    List<Integer> ids;
    int amount;

    @Override
    public Boolean get()
    {
        switch (reduction)
        {
            case AND:
                if (equipped)
                {
                    return ids.stream().allMatch(it -> Equipment.getCount(true, it) >= amount);
                }
                else
                {
                    return ids.stream().allMatch(it -> Inventory.getCount(true, it) >= amount);
                }
            case OR:
                if (equipped)
                {
                    return ids.stream().anyMatch(it -> Equipment.getCount(true, it) >= amount);
                }
                else
                {
                    return ids.stream().anyMatch(it -> Inventory.getCount(true, it) >= amount);
                }
        }
        return false;
    }
}

package net.unethicalite.api.items;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.client.Static;
import net.unethicalite.client.managers.InventoryManager;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public abstract class Items
{
	@Getter
	private final InventoryID inventoryID;
	private final Function<Item, Boolean> modification;

	protected Items(InventoryID inventoryID, Function<Item, Boolean> modification)
	{
		this.inventoryID = inventoryID;
		this.modification = modification;
	}

	protected List<Item> all(Predicate<Item> filter)
	{
		List<Item> items = new ArrayList<>();
		Item[] containerItems = InventoryManager.getCachedContainers().get(inventoryID.getId());
		if (containerItems == null)
		{
			return items;
		}

		cacheUncachedItems(containerItems);

		for (int i = 0; i < containerItems.length; i++)
		{
			Item item = containerItems[i];
			if (item == null || item.getId() == -1 || "null".equals(item.getName()))
			{
				continue;
			}

			item.setSlot(i);

			if (modification.apply(item) && filter.test(item))
			{
				items.add(item);
			}
		}

		return items;
	}

	protected List<Item> all(String... names)
	{
		return all(Predicates.names(names));
	}

	protected List<Item> all(int... ids)
	{
		return all(Predicates.ids(ids));
	}

	protected Item first(Predicate<Item> filter)
	{
		return all(filter).stream().findFirst().orElse(null);
	}

	protected Item first(int... ids)
	{
		return first(Predicates.ids(ids));
	}

	protected Item first(String... names)
	{
		return first(Predicates.names(names));
	}

	protected boolean exists(Predicate<Item> filter)
	{
		return first(filter) != null;
	}

	protected boolean exists(String... name)
	{
		return first(name) != null;
	}

	protected boolean exists(int... id)
	{
		return first(id) != null;
	}

	protected int count(boolean stacks, Predicate<Item> filter)
	{
		return all(filter).stream().mapToInt(x -> stacks ? x.getQuantity() : 1).sum();
	}

	protected int count(boolean stacks, int... ids)
	{
		return all(ids).stream().mapToInt(x -> stacks ? x.getQuantity() : 1).sum();
	}

	protected int count(boolean stacks, String... names)
	{
		return all(names).stream().mapToInt(x -> stacks ? x.getQuantity() : 1).sum();
	}

	protected void cacheUncachedItems(Item[] items)
	{
		Client client = Static.getClient();
		List<Item> uncachedItems = Arrays.stream(items)
				.filter(i -> !client.isItemDefinitionCached(i.getId()))
				.collect(Collectors.toList());
		if (!uncachedItems.isEmpty())
		{
			GameThread.invoke(() ->
			{
				for (Item uncachedItem : uncachedItems)
				{
					int id = uncachedItem.getId();
					client.cacheItem(id, client.getItemComposition(id));
				}
			});
		}
	}
}

package net.unethicalite.api.movement.pathfinder.model.poh;

import lombok.Getter;
import net.runelite.api.NullObjectID;

@Getter
public enum JewelryBox
{
    NONE(-1),
    BASIC(NullObjectID.NULL_29154),
    FANCY(NullObjectID.NULL_29155),
    ORNATE(NullObjectID.NULL_29156)
    ;

    private final int objectId;

    JewelryBox(int objectId)
    {
        this.objectId = objectId;
    }

}
package net.unethicalite.api.movement.pathfinder;

import net.unethicalite.api.movement.Reachable;
import net.unethicalite.api.scene.Tiles;
import net.runelite.api.Tile;
import net.runelite.api.coords.Direction;
import net.runelite.api.coords.WorldPoint;

public class LocalCollisionMap implements CollisionMap
{
	private final boolean blockDoors;

	public LocalCollisionMap(boolean blockDoors)
	{
		this.blockDoors = blockDoors;
	}


	@Override
	public boolean n(int x, int y, int z)
	{
		WorldPoint current = new WorldPoint(x, y, z);
		if (Reachable.isObstacle(current))
		{
			return false;
		}

		Tile currentTile = Tiles.getAt(current);
		Tile destinationTile = Tiles.getAt(current.dy(1));

		if (currentTile != null
				&& destinationTile != null
				&& (Reachable.isDoored(currentTile, destinationTile) || Reachable.isDoored(destinationTile, currentTile))
				&& !blockDoors
		)
		{
			return !Reachable.isObstacle(destinationTile.getWorldLocation());
		}

		return Reachable.canWalk(Direction.NORTH, Reachable.getCollisionFlag(current), Reachable.getCollisionFlag(current.dy(1)));
	}

	@Override
	public boolean e(int x, int y, int z)
	{
		WorldPoint current = new WorldPoint(x, y, z);
		if (Reachable.isObstacle(current))
		{
			return false;
		}

		Tile currentTile = Tiles.getAt(current);
		Tile destinationTile = Tiles.getAt(current.dx(1));

		if (currentTile != null
				&& destinationTile != null
				&& (Reachable.isDoored(currentTile, destinationTile) || Reachable.isDoored(destinationTile, currentTile))
				&& !blockDoors
		)
		{
			return !Reachable.isObstacle(destinationTile.getWorldLocation());
		}

		return Reachable.canWalk(Direction.EAST, Reachable.getCollisionFlag(current), Reachable.getCollisionFlag(current.dx(1)));
	}
}

package net.unethicalite.api.account;

import net.unethicalite.api.entities.Players;
import net.unethicalite.api.game.Game;
import net.unethicalite.api.game.Vars;
import net.runelite.api.Player;
import net.runelite.api.VarPlayer;
import net.runelite.api.vars.AccountType;
import net.unethicalite.client.Static;

public class LocalPlayer
{
	public static Player get()
	{
		return Players.getLocal();
	}

	public static String getUsername()
	{
		return Static.getClient().getUsername();
	}

	public static String getPassword()
	{
		return Static.getClient().getPassword();
	}

	public static int getTotalLevel()
	{
		return Static.getClient().getTotalLevel();
	}

	public static int getQuestPoints()
	{
		return Vars.getVarp(VarPlayer.QUEST_POINTS.getId());
	}

	public static int getMembershipDays()
	{
		return Game.getMembershipDays();
	}

	public static boolean isMember()
	{
		return getMembershipDays() > 0;
	}

	public static String getDisplayName()
	{
		return get().getName();
	}

	public static AccountType getAccountType()
	{
		return Static.getClient().getAccountType();
	}
}

package net.unethicalite.api.script.blocking_events;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.unethicalite.api.account.GameAccount;
import net.unethicalite.api.game.Game;
import net.unethicalite.api.game.Worlds;
import net.unethicalite.api.input.Keyboard;
import net.unethicalite.client.Static;
import org.jboss.aerogear.security.otp.Totp;

import java.util.Locale;
import java.util.function.Function;

@Slf4j
@RequiredArgsConstructor
public class LoginEvent extends BlockingEvent
{
	private final BlockingEventManager blockingEventManager;
	private Totp totp = null;
	private long timer = 0;
	private long validateTime = -1;
	private long maxLoginScreenTime = 1_800_000;

	@Override
	public boolean validate()
	{
		boolean validate = !Game.isLoggedIn() && Game.getGameAccount() != null;
		if (validate && validateTime < 0)
		{
			validateTime = System.currentTimeMillis();
		}

		if (!validate)
		{
			validateTime = -1;
		}

		return validate;
	}

	@Override
	public int loop()
	{
		String loginMessage = Static.getClient().getLoginMessage();
		Client client = Static.getClient();

		if (validateTime > -1 && System.currentTimeMillis() - validateTime >= maxLoginScreenTime)
		{
			log.info("Spent longer than 10 mins in login screen, exiting client.");
			System.exit(0);
		}

		if (client.getWorldList() == null)
		{
			Worlds.loadWorlds();
			return 1000;
		}

		if (client.isWorldSelectOpen())
		{
			client.setWorldSelectOpen(false);
			return 1000;
		}

		if (loginMessage.toLowerCase(Locale.ROOT).contains("update"))
		{
			log.info("Game was updated, exiting client.");
			System.exit(0);
		}

		for (var entry : blockingEventManager.getLoginMessageHandlers().entrySet())
		{
			Response response = entry.getKey();
			Function<Response, Integer> handler = entry.getValue();
			if (loginMessage.contains(response.line1))
			{
				return handler.apply(response);
			}
		}

		return login();
	}

	public int login()
	{
		Client client = Static.getClient();
		int loginState = client.getLoginIndex();
		GameAccount gameAccount = Game.getGameAccount();
		if (gameAccount == null)
		{
			log.warn("No account set, stopping login event.");
			return -1000;
		}

		switch (loginState)
		{
			case State.AUTHENTICATOR:
				if (gameAccount.getAuth() != null)
				{
					totp = new Totp(gameAccount.getAuth());
				}
				else
				{
					log.error("We are on auth screen, but auth code was not set.");
					return -1000;
				}

				client.setOtp(totp.now());
				Keyboard.sendEnter();
				return 1000;

			case State.ENTER_CREDENTIALS:
				if (Game.getState() == GameState.LOGGING_IN)
				{
					timer = 0;
					return 1000;
				}

				client.setUsername(gameAccount.getUsername());
				client.setPassword(gameAccount.getPassword());
				Keyboard.sendEnter();
				Keyboard.sendEnter();
				return 1000;

			case State.MAIN_MENU:
			case State.BEEN_DISCONNECTED:
				client.setLoginIndex(State.ENTER_CREDENTIALS);
				return 1000;

			case State.DISABLED:
			case State.INVALID_CREDENTIALS:
				log.warn("Invalid account set.");
				return 5000;

			default:
				log.warn("Cannot handle login state {}", loginState);
				return 1000;
		}
	}

	public interface State
	{
		int MAIN_MENU = 0;
		int BETA_WORLD = 1;
		int ENTER_CREDENTIALS = 2;
		int INVALID_CREDENTIALS = 3;
		int AUTHENTICATOR = 4;
		int DISABLED = 14;
		int BEEN_DISCONNECTED = 24;
	}

	@RequiredArgsConstructor
	@Getter
	public enum Response
	{
		CONNECTION_TIMED_OUT(-3, "Connection timed out.", "Please try using a different world.", ""),
		ERROR_CONNECTING(-2, "", "Error connecting to server.", "Please try using a different world."),
		NO_SERVER_RESPONSE(-1, "No response from server.", "Please try using a different world.", ""),
		INVALID_CREDENTIALS(3, "Invalid credentials.", "", ""),
		ACCOUNT_DISABLED(4, "Your account has been disabled.", "Please visit the support page for assistance.", ""),
		ACCOUNT_NOT_LOGGED_OUT(5, "Your account has not logged out from its last", "session or the server is too busy right now.", "Please try again in a few minutes."),
		RUNESCAPE_UPDATE(6, "RuneScape has been updated!", "Please reload this page.", ""),
		WORLD_FULL(7, "This world is full.", "Please use a different world.", ""),
		LOGIN_SERVER_OFFLINE(8, "Unable to connect.", "Login server offline.", ""),
		LOGIN_LIMIT(9, "Login limit exceeded.", "Too many connections from your address.", ""),
		BAD_SESSION_ID(10, "Unable to connect.", "Bad session id.", ""),
		ACCOUNT_STOLEN(11, "We suspect someone knows your password.", "Press 'change your password' on front page.", ""),
		MEMBERSHIP_REQUIRED(12, "You need a members account to login to this world.", "Please subscribe, or use a different world.", ""),
		COULD_NOT_COMPLETE(13, "Could not complete login.", "Please try using a different world.", ""),
		SERVER_BEING_UPDATED(14, "The server is being updated.", "Please wait 1 minute and try again.", ""),
		TOO_MANY_ATTEMPTS(16, "Too many login attempts.", "Please wait a few minutes before trying again.", ""),
		MEMBERS_ONLY_AREA(17, "You are standing in a members-only area.", "To play on this world move to a free area first", ""),
		ACCOUNT_LOCKED(18, "Account locked as we suspect it has been stolen.", "Please visit the support page for assistance.", ""),
		WORLD_CLOSED_BETA(19, "This world is running a closed Beta.", "Sorry invited players only.", "Please use a different world."),
		INVALID_LOGIN_SERVER(20, "Invalid loginserver requested.", "Please try using a different world.", ""),
		MALFORMED_LOGIN_PACKET(22, "Malformed login packet.", "Please try again.", ""),
		NO_SERVER_REPLY(23, "No reply from loginserver.", "Please wait 1 minute and try again.", ""),
		ERROR_LOADING_PROFILE(24, "Error loading your profile.", "Please contact customer support.", ""),
		UNEXPECTED_SERVER_RESPONSE(25, "Unexpected loginserver response.", "Please try using a different world.", ""),
		COMPUTER_ADDRESS_BLOCKED(26, "This computers address has been blocked", "as it was used to break our rules.", ""),
		SERVICE_UNAVAILABLE(27, "", "Service unavailable.", ""),
		NO_DISPLAY_NAME_SET(31, "Your account must have a displayname set", "in order to play the game.  Please set it", "via the website, or the main game."),
		UNSUCCESSFUL_ACCOUNT_LOGIN_ATTEMPT(32, "Your attempt to log into your account was", "unsuccessful.  Don't worry, you can sort", "this out by visiting the billing system."),
		ACCOUNT_INACCESSIBLE(37, "Your account is currently inaccessible.", "Please try again in a few minutes.", ""),
		VOTE_REQUIRED(38, "You need to vote to play!", "Visit runescape.com and vote,", "and then come back here!"),
		ENTER_AUTH(56, "Enter the 6-digit code generated by your", "authenticator app.", ""),
		INCORRECT_AUTH_CODE(57, "The code you entered was incorrect.", "Please try again.", ""),
		RUNESCAPE_UPDATE_2(68, "RuneScape has been updated!", "Please reload this page.", "");

		private final int code;
		private final String line1;
		private final String line2;
		private final String line3;

		public String getMessage()
		{
			return line1 + " " + line2 + " " + line3;
		}

		public static Response forCode(int code)
		{
			for (Response value : values())
			{
				if (value.code == code)
				{
					return value;
				}
			}

			return null;
		}

		public static Response forMessage(String contained)
		{
			for (Response value : values())
			{
				if (value.getMessage().toLowerCase(Locale.ROOT).contains(contained.toLowerCase(Locale.ROOT)))
				{
					return value;
				}
			}

			return null;
		}
	}
}

package net.unethicalite.api.plugins;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.unethicalite.api.commons.Time;
import net.unethicalite.api.game.Game;

import javax.swing.SwingUtilities;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
public abstract class LoopedPlugin extends Plugin implements Runnable
{
	private static final ScheduledExecutorService EXECUTOR = new LoggableExecutor(1);
	private final AtomicInteger ticks = new AtomicInteger(0);

	private volatile int nextSleep = 1000;
	private int currentSleep = 1000;
	private int sleepUntil = 0;

	protected abstract int loop();

	private Future<?> task;

	@Override
	public void run()
	{
		task = EXECUTOR.schedule(loopTask(), nextSleep, TimeUnit.MILLISECONDS);

		while (isRunning())
		{
			if (task.isDone())
			{
				task = EXECUTOR.schedule(loopTask(), nextSleep, TimeUnit.MILLISECONDS);
				continue;
			}

			Time.sleep(10);
		}
		task = null;
	}

	private Runnable loopTask()
	{
		return () ->
		{
			try
			{
				int currentTick = ticks.get();
				if (sleepUntil > 0 && sleepUntil > currentTick && Game.isLoggedIn())
				{
					return;
				}

				sleepUntil = 0;

				currentSleep = this instanceof Script ? ((Script) this).outerLoop() : loop();
			}
			catch (PluginStoppedException e)
			{
				SwingUtilities.invokeLater(() -> Plugins.stopPlugin(this));
			}
			finally
			{
				if (sleepUntil == 0)
				{
					if (currentSleep < 0 && Game.isLoggedIn())
					{
						int currentTick = ticks.get();
						sleepUntil = currentTick + Math.abs(currentSleep);
						nextSleep = 0;
					}
					else
					{
						nextSleep = currentSleep < 0 ? 1000 : currentSleep;
					}
				}
			}
		};
	}

	public boolean isRunning()
	{
		return task != null && !task.isCancelled();
	}

	public void stop()
	{
		if (isRunning())
		{
			task.cancel(true);
		}
	}

	private static class LoggableExecutor extends ScheduledThreadPoolExecutor
	{
		public LoggableExecutor(int corePoolSize)
		{
			super(corePoolSize);
		}

		protected void afterExecute(Runnable r, Throwable t)
		{
			super.afterExecute(r, t);

			if (t == null && r instanceof Future<?>)
			{
				try
				{
					Future<?> future = (Future<?>) r;
					if (future.isDone())
					{
						future.get();
					}
				}
				catch (CancellationException ignored)
				{

				}
				catch (ExecutionException ee)
				{
					t = ee.getCause();
				}
				catch (InterruptedException ie)
				{
					Thread.currentThread().interrupt();
				}
			}

			if (t != null)
			{
				log.error("Error in loop", t);
			}
		}
	}

	@Subscribe
	private void tickCounter(GameTick gameTick)
	{
		ticks.incrementAndGet();
	}
}

package net.unethicalite.api.magic;

import net.runelite.api.Item;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.TileItem;
import net.runelite.api.TileObject;
import net.runelite.api.VarPlayer;
import net.runelite.api.widgets.Widget;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

public class Magic
{
	private static final int AUTOCAST_VARP = 108;

	public static boolean isAutoCasting()
	{
		return Vars.getVarp(AUTOCAST_VARP) != 0;
	}

	public static boolean isSpellSelected(Spell spell)
	{
		Widget widget = Widgets.get(spell.getWidget());
		if (widget != null)
		{
			return widget.getBorderType() == 2;
		}

		return false;
	}

	public static void cast(Spell spell, Item target)
	{
		selectSpell(spell);
		target.interact(0, MenuAction.WIDGET_TARGET_ON_WIDGET.getId());
	}

	public static void cast(Spell spell, NPC target)
	{
		selectSpell(spell);
		target.interact(0, MenuAction.WIDGET_TARGET_ON_NPC.getId());
	}

	public static void cast(Spell spell, Player target)
	{
		selectSpell(spell);
		target.interact(0, MenuAction.WIDGET_TARGET_ON_PLAYER.getId());
	}

	public static void cast(Spell spell, TileItem target)
	{
		selectSpell(spell);
		target.interact(0, MenuAction.WIDGET_TARGET_ON_GROUND_ITEM.getId());

	}

	public static void cast(Spell spell, TileObject target)
	{
		selectSpell(spell);
		target.interact(0, MenuAction.WIDGET_TARGET_ON_GAME_OBJECT.getId());
	}

	public static void selectSpell(Spell spell)
	{
		Widget widget = Widgets.get(spell.getWidget());
		if (widget != null)
		{
			Static.getClient().setSelectedSpellWidget(widget.getId());
			Static.getClient().setSelectedSpellChildIndex(-1);
			Static.getClient().setSpellSelected(true);
		}
	}

	public static void cast(Spell spell)
	{
		cast(spell, 0);
	}

	public static void cast(Spell spell, int actionIndex)
	{
		Widget widget = Widgets.get(spell.getWidget());
		if (widget != null)
		{
			widget.interact(actionIndex);
		}
	}

	public static void cast(Spell spell, int actionIndex, int opcode)
	{
		Widget widget = Widgets.get(spell.getWidget());
		if (widget != null)
		{
			widget.interact(actionIndex, opcode);
		}
	}

	public static Instant getLastHomeTeleportUsage()
	{
		return Instant.ofEpochSecond(Vars.getVarp(VarPlayer.LAST_HOME_TELEPORT.getId()) * 60L);
	}

	public static boolean isHomeTeleportOnCooldown()
	{
		return getLastHomeTeleportUsage().plus(30, ChronoUnit.MINUTES).isAfter(Instant.now());
	}
}

package net.unethicalite.api.input.naturalmouse.util;

public class MathUtil
{
	/**
	 * Rounds value towards target to exact integer value.
	 *
	 * @param value  the value to be rounded
	 * @param target the target to be rounded towards
	 * @return the rounded value
	 */
	public static int roundTowards(double value, int target)
	{
		if (target > value)
		{
			return (int) Math.ceil(value);
		}
		else
		{
			return (int) Math.floor(value);
		}
	}
}

package net.unethicalite.api.utils;

import net.unethicalite.client.Static;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;

public class MessageUtils
{

    public static void addMessage(String message, ChatColorType colorType, ChatMessageType messageType)
    {
        String chatMessage = new ChatMessageBuilder()
                .append(colorType)
                .append(message)
                .build();

        Static.getChatMessageManager()
                .queue(QueuedMessage.builder()
                        .type(messageType)
                        .runeLiteFormattedMessage(chatMessage)
                        .build());
    }

    public static void addMessage(String message, ChatMessageType messageType)
    {
        addMessage(message, ChatColorType.HIGHLIGHT, messageType);
    }

    public static void addMessage(String message, ChatColorType colorType)
    {
        addMessage(message, colorType, ChatMessageType.CONSOLE);
    }

    public static void addMessage(String message)
    {
        addMessage(message, ChatColorType.HIGHLIGHT, ChatMessageType.CONSOLE);
    }
}

package net.unethicalite.api.widgets;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Quest;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.game.GameThread;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.game.Skills;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.game.Worlds;
import net.unethicalite.api.quests.Quests;
import net.unethicalite.client.Static;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.function.Supplier;

@Slf4j
public class Minigames
{
	private static final Supplier<Widget> MINIGAMES_TAB_BUTTON = () -> Widgets.get(707, 6);
	private static final Supplier<Widget> MINIGAMES_DESTINATION = () -> Widgets.get(76, 11);

	private static final Set<Quest> NMZ_QUESTS = Set.of(
		Quest.THE_ASCENT_OF_ARCEUUS,
		Quest.CONTACT,
		Quest.THE_CORSAIR_CURSE,
		Quest.THE_DEPTHS_OF_DESPAIR,
		Quest.DESERT_TREASURE_I,
		Quest.DRAGON_SLAYER_I,
		Quest.DREAM_MENTOR,
		Quest.FAIRYTALE_I__GROWING_PAINS,
		Quest.FAMILY_CREST,
		Quest.FIGHT_ARENA,
		Quest.THE_FREMENNIK_ISLES,
		Quest.GETTING_AHEAD,
		Quest.THE_GRAND_TREE,
		Quest.THE_GREAT_BRAIN_ROBBERY,
		Quest.GRIM_TALES,
		Quest.HAUNTED_MINE,
		Quest.HOLY_GRAIL,
		Quest.HORROR_FROM_THE_DEEP,
		Quest.IN_SEARCH_OF_THE_MYREQUE,
		Quest.LEGENDS_QUEST,
		Quest.LOST_CITY,
		Quest.LUNAR_DIPLOMACY,
		Quest.MONKEY_MADNESS_I,
		Quest.MOUNTAIN_DAUGHTER,
		Quest.MY_ARMS_BIG_ADVENTURE,
		Quest.ONE_SMALL_FAVOUR,
		Quest.RECIPE_FOR_DISASTER,
		Quest.ROVING_ELVES,
		Quest.SHADOW_OF_THE_STORM,
		Quest.SHILO_VILLAGE,
		Quest.SONG_OF_THE_ELVES,
		Quest.TALE_OF_THE_RIGHTEOUS,
		Quest.TREE_GNOME_VILLAGE,
		Quest.TROLL_ROMANCE,
		Quest.TROLL_STRONGHOLD,
		Quest.VAMPYRE_SLAYER,
		Quest.WHAT_LIES_BELOW,
		Quest.WITCHS_HOUSE
	);

	public static boolean canTeleport()
	{
		return getLastMinigameTeleportUsage().plus(20, ChronoUnit.MINUTES).isBefore(Instant.now());
	}

	public static void teleport(Destination destination)
	{
		if (!canTeleport())
		{
			log.warn("Tried to minigame teleport, but it's on cooldown.");
			return;
		}

		Widget minigamesTeleportButton = Widgets.get(WidgetInfo.MINIGAME_TELEPORT_BUTTON);
		List<Integer> teleportGraphics = List.of(800, 802, 803, 804);
		if (isOpen() && minigamesTeleportButton != null)
		{
			if (Destination.getCurrent() != destination)
			{
				GameThread.invoke(() -> Static.getClient().runScript(124, destination.index));
				return;
			}

			if (teleportGraphics.contains(Players.getLocal().getGraphic()))
			{
				return;
			}

			Widget button = minigamesTeleportButton.getChild(destination.index);
			if (Widgets.isVisible(button))
			{
				button.interact(Predicates.textContains("Teleport to"));
			}
		}
		else
		{
			open();
		}
	}

	public static boolean open()
	{
		if (!isTabOpen())
		{
			Tabs.open(Tab.CLAN_CHAT);
			return false;
		}

		if (!isOpen())
		{
			Widget widget = MINIGAMES_TAB_BUTTON.get();
			if (Widgets.isVisible(widget))
			{
				widget.interact("Grouping");
				return false;
			}
		}

		return isOpen();
	}

	public static boolean isOpen()
	{
		return Widgets.isVisible(Widgets.get(WidgetInfo.MINIGAME_TELEPORT_BUTTON));
	}

	public static boolean isTabOpen()
	{
		return Tabs.isOpen(Tab.CLAN_CHAT);
	}

	public static Instant getLastMinigameTeleportUsage()
	{
		return Instant.ofEpochSecond(Vars.getVarp(VarPlayer.LAST_MINIGAME_TELEPORT.getId()) * 60L);
	}

	@Getter
	@AllArgsConstructor
	public enum Destination
	{
		BARBARIAN_ASSAULT(1, "Barbarian Assault", new WorldPoint(2531, 3577, 0), false),
		BLAST_FURNACE(2, "Blast Furnace", new WorldPoint(2933, 10183, 0), true),
		BURTHORPE_GAMES_ROOM(3, "Burthorpe Games Room", new WorldPoint(2208, 4938, 0), true),
		CASTLE_WARS(4, "Castle Wars", new WorldPoint(2439, 3092, 0), false),
		CLAN_WARS(5, "Clan Wars", new WorldPoint(3151, 3636, 0), false),
		DAGANNOTH_KINGS(6, "Dagannoth Kings", null, true),
		FISHING_TRAWLER(7, "Fishing Trawler", new WorldPoint(2658, 3158, 0), true),
		GIANTS_FOUNDARY(8, "Giants' Foundry", new WorldPoint(3361, 3147, 0), true),
		GOD_WARS(9, "God Wars", null, true),
		GUARDIANS_OF_THE_RIFT(10, "Guardians of the Rift", new WorldPoint(3616, 9478, 0), true),
		LAST_MAN_STANDING(11, "Last Man Standing", new WorldPoint(3149, 3635, 0), false),
		NIGHTMARE_ZONE(12, "Nightmare Zone", new WorldPoint(2611, 3121, 0), true),
		PEST_CONTROL(13, "Pest Control", new WorldPoint(2653, 2655, 0), true),
		PLAYER_OWNED_HOUSES(14, "Player Owned Houses", null, false),
		RAT_PITS(15, "Rat Pits", new WorldPoint(3263, 3406, 0), true),
		SHADES_OF_MORTTON(16, "Shades of Mort'ton", new WorldPoint(3500, 3300, 0), true),
		SHIELD_OF_ARRAV(17, "Shield of Arrav", null, true),
		SHOOTING_STARS(18, "Shooting Stars", null, true),
		SOUL_WARS(19, "Soul Wars", new WorldPoint(2209, 2857, 0), true),
		THEATRE_OF_BLOOD(20, "Theatre of Blood", null, true),
		TITHE_FARM(21, "Tithe Farm", new WorldPoint(1793, 3501, 0), true),
		TROUBLE_BREWING(22, "Trouble Brewing", new WorldPoint(3811, 3021, 0), true),
		TZHAAR_FIGHT_PIT(23, "TzHaar Fight Pit", new WorldPoint(2402, 5181, 0), true),
		VOLCANIC_MINE(24, "Volcanic Mine", null, true),
		NONE(-1, "None", null, false);

		private final int index;
		private final String name;
		private final WorldPoint location;
		private final boolean members;

		public boolean canUse()
		{
			if (!hasDestination())
			{
				return false;
			}

			if (members && !Worlds.inMembersWorld())
			{
				return false;
			}

			switch (this)
			{
				case BURTHORPE_GAMES_ROOM:
				case CASTLE_WARS:
				case CLAN_WARS:
				case LAST_MAN_STANDING:
				case SOUL_WARS:
				case TZHAAR_FIGHT_PIT:
				case GIANTS_FOUNDARY:
					return true;
				case BARBARIAN_ASSAULT:
					return Vars.getBit(3251) >= 1;
				case BLAST_FURNACE:
					return Vars.getBit(575) >= 1;
				case FISHING_TRAWLER:
					return Skills.getLevel(Skill.FISHING) >= 15;
				case GUARDIANS_OF_THE_RIFT:
					return Quests.isFinished(Quest.TEMPLE_OF_THE_EYE);
				case NIGHTMARE_ZONE:
					return NMZ_QUESTS.stream().filter(Quests::isFinished).count() >= 5;
				case PEST_CONTROL:
					return Players.getLocal().getCombatLevel() >= 40;
				case RAT_PITS:
					return Quests.isFinished(Quest.RATCATCHERS);
				case SHADES_OF_MORTTON:
					return Quests.isFinished(Quest.SHADES_OF_MORTTON);
				case TROUBLE_BREWING:
					return Quests.isFinished(Quest.CABIN_FEVER) && Skills.getLevel(Skill.COOKING) >= 40;
				case TITHE_FARM:
					return false;
//					return Skills.getLevel(Skill.FARMING) >= 34 && (Vars.getBit(Varbits.KOUREND_FAVOR_HOSIDIUS) / 10) >= 100;
			}
			return false;
		}

		public boolean hasDestination()
		{
			return location != null;
		}

		public static Destination getCurrent()
		{
			Widget selectedTeleport = MINIGAMES_DESTINATION.get();
			if (Widgets.isVisible(selectedTeleport))
			{
				return byName(selectedTeleport.getText());
			}

			return NONE;
		}

		public static Destination byName(String name)
		{
			return Arrays.stream(values())
					.filter(x -> x.getName().equals(name))
					.findFirst()
					.orElse(NONE);
		}
	}
}

package net.unethicalite.api.input.naturalmouse.api;

import java.awt.Point;

/**
 * Abstraction for getting mouse position.
 */
public interface MouseInfoAccessor
{
	/**
	 * Get the current mouse position.
	 * NB, for optimization reasons this method might return the same Point instance, but is not quaranteed to.
	 * It is recommended not to save this Point anywhere as it may or may not change its coordinates.
	 *
	 * @return the current mouse position
	 */

	Point getMousePosition();
}

package net.unethicalite.api.input.naturalmouse.api;

import net.unethicalite.api.input.naturalmouse.support.DoublePoint;
import net.unethicalite.api.input.naturalmouse.support.Flow;
import net.unethicalite.api.input.naturalmouse.support.MouseMotionNature;
import net.unethicalite.api.input.naturalmouse.support.mousemotion.MouseMovement;
import net.unethicalite.api.input.naturalmouse.support.mousemotion.MovementFactory;
import net.unethicalite.api.input.naturalmouse.util.MathUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.Dimension;
import java.awt.Point;
import java.util.ArrayDeque;
import java.util.Random;

/**
 * Contains instructions to move cursor smoothly to the destination coordinates from where ever the cursor
 * currently is. The class is reusable, meaning user can keep calling it and the cursor returns in a random,
 * but reliable way, described in this class, to the destination.
 */
public class MouseMotion
{
	private static final Logger log = LoggerFactory.getLogger(MouseMotion.class);
	private static final int SLEEP_AFTER_ADJUSTMENT_MS = 2;
	private final int minSteps;
	private final int effectFadeSteps;
	private final int reactionTimeBaseMs;
	private final int reactionTimeVariationMs;
	private final double timeToStepsDivider;
	private final Dimension screenSize;
	private final SystemCalls systemCalls;
	private final DeviationProvider deviationProvider;
	private final NoiseProvider noiseProvider;
	private final SpeedManager speedManager;
	private final OvershootManager overshootManager;
	private final int xDest;
	private final int yDest;
	private final Random random;
	private final MouseInfoAccessor mouseInfo;
	private Point mousePosition;

	/**
	 * @param nature the nature that defines how mouse is moved
	 * @param xDest  the x-coordinate of destination
	 * @param yDest  the y-coordinate of destination
	 * @param random the random used for unpredictability
	 */
	public MouseMotion(MouseMotionNature nature, Random random, int xDest, int yDest)
	{
		this.deviationProvider = nature.getDeviationProvider();
		this.noiseProvider = nature.getNoiseProvider();
		this.systemCalls = nature.getSystemCalls();
		this.screenSize = systemCalls.getScreenSize();
		this.xDest = limitByScreenWidth(xDest);
		this.yDest = limitByScreenHeight(yDest);
		this.random = random;
		this.mouseInfo = nature.getMouseInfo();
		this.speedManager = nature.getSpeedManager();
		this.timeToStepsDivider = nature.getTimeToStepsDivider();
		this.minSteps = nature.getMinSteps();
		this.effectFadeSteps = nature.getEffectFadeSteps();
		this.reactionTimeBaseMs = nature.getReactionTimeBaseMs();
		this.reactionTimeVariationMs = nature.getReactionTimeVariationMs();
		this.overshootManager = nature.getOvershootManager();
	}

	/**
	 * Blocking call, starts to move the cursor to the specified location from where it currently is.
	 *
	 * @throws InterruptedException when interrupted
	 */
	public void move() throws InterruptedException
	{
		move((x, y) ->
		{
		});
	}

	/**
	 * Blocking call, starts to move the cursor to the specified location from where it currently is.
	 *
	 * @param observer Provide observer if you are interested receiving the location of mouse on every step
	 * @throws InterruptedException when interrupted
	 */
	public void move(MouseMotionObserver observer) throws InterruptedException
	{
		updateMouseInfo();

		MovementFactory movementFactory = new MovementFactory(xDest, yDest, speedManager, overshootManager, screenSize);
		ArrayDeque<MouseMovement> movements = movementFactory.createMovements(mousePosition);
		int overshoots = movements.size() - 1;
		while (mousePosition.x != xDest || mousePosition.y != yDest)
		{
			if (movements.isEmpty())
			{
				// This shouldn't usually happen, but it's possible that somehow we won't end up on the target,
				// Then just re-attempt from mouse new position. (There are known JDK bugs, that can cause sending the cursor
				// to wrong pixel)
				updateMouseInfo();
				movements = movementFactory.createMovements(mousePosition);
			}

			MouseMovement movement = movements.removeFirst();
			double distance = movement.distance;
			long mouseMovementMs = movement.time;
			Flow flow = movement.flow;
			double xDistance = movement.xDistance;
			double yDistance = movement.yDistance;

      /* Number of steps is calculated from the movement time and limited by minimal amount of steps
         (should have at least MIN_STEPS) and distance (shouldn't have more steps than pixels travelled) */
			int steps = (int) Math.ceil(Math.min(distance, Math.max(mouseMovementMs / timeToStepsDivider, minSteps)));

			long startTime = systemCalls.currentTimeMillis();
			long stepTime = (long) (mouseMovementMs / (double) steps);

			updateMouseInfo();
			double simulatedMouseX = mousePosition.x;
			double simulatedMouseY = mousePosition.y;

			double deviationMultiplierX = (random.nextDouble() - 0.5) * 2;
			double deviationMultiplierY = (random.nextDouble() - 0.5) * 2;

			double completedXDistance = 0;
			double completedYDistance = 0;
			double noiseX = 0;
			double noiseY = 0;

			for (int i = 0; i < steps; i++)
			{
				// All steps take equal amount of time. This is a value from 0...1 describing how far along the process is.
				double timeCompletion = i / (double) steps;

				double effectFadeStep = Math.max(i - (steps - effectFadeSteps) + 1, 0);
				// value from 0 to 1, when effectFadeSteps remaining steps, starts to decrease to 0 linearly
				// This is here so noise and deviation wouldn't add offset to mouse final position, when we need accuracy.
				double effectFadeMultiplier = (effectFadeSteps - effectFadeStep) / effectFadeSteps;

				double xStepSize = flow.getStepSize(xDistance, steps, timeCompletion);
				double yStepSize = flow.getStepSize(yDistance, steps, timeCompletion);

				completedXDistance += xStepSize;
				completedYDistance += yStepSize;
				double completedDistance = Math.hypot(completedXDistance, completedYDistance);
				double completion = Math.min(1, completedDistance / distance);

				DoublePoint noise = noiseProvider.getNoise(random, xStepSize, yStepSize);
				DoublePoint deviation = deviationProvider.getDeviation(distance, completion);

				noiseX += noise.getX();
				noiseY += noise.getY();
				simulatedMouseX += xStepSize;
				simulatedMouseY += yStepSize;

				long endTime = startTime + stepTime * (i + 1);
				int mousePosX = MathUtil.roundTowards(simulatedMouseX + deviation.getX() * deviationMultiplierX * effectFadeMultiplier + noiseX * effectFadeMultiplier, movement.destX);

				int mousePosY = MathUtil.roundTowards(simulatedMouseY + deviation.getY() * deviationMultiplierY * effectFadeMultiplier + noiseY * effectFadeMultiplier, movement.destY);

				mousePosX = limitByScreenWidth(mousePosX);
				mousePosY = limitByScreenHeight(mousePosY);

				systemCalls.setMousePosition(mousePosX, mousePosY);

				// Allow other action to take place or just observe, we'll later compensate by sleeping less.
				observer.observe(mousePosX, mousePosY);

				long timeLeft = endTime - systemCalls.currentTimeMillis();
				sleepAround(Math.max(timeLeft, 0), 0);
			}
			updateMouseInfo();

			if (mousePosition.x != movement.destX || mousePosition.y != movement.destY)
			{
				// It's possible that mouse is manually moved or for some other reason.
				// Let's start next step from pre-calculated location to prevent errors from accumulating.
				// But print warning as this is not expected behavior.
				systemCalls.setMousePosition(movement.destX, movement.destY);
				// Let's wait a bit before getting mouse info.
				sleepAround(SLEEP_AFTER_ADJUSTMENT_MS, 0);
				updateMouseInfo();
			}

			if (mousePosition.x != xDest || mousePosition.y != yDest)
			{
				// We are dealing with overshoot, let's sleep a bit to simulate human reaction time.
				sleepAround(reactionTimeBaseMs, reactionTimeVariationMs);
			}
		}
	}

	private int limitByScreenWidth(int value)
	{
		return Math.max(0, Math.min(screenSize.width - 1, value));
	}

	private int limitByScreenHeight(int value)
	{
		return Math.max(0, Math.min(screenSize.height - 1, value));
	}

	private void sleepAround(long sleepMin, long randomPart)
	{
		long sleepTime = (long) (sleepMin + random.nextDouble() * randomPart);
		if (log.isTraceEnabled() && sleepTime > 0)
		{
			updateMouseInfo();
		}
		systemCalls.sleep(sleepTime);
	}

	private void updateMouseInfo()
	{
		mousePosition = mouseInfo.getMousePosition();
	}

}

package net.unethicalite.api.input.naturalmouse.api;

import net.unethicalite.api.input.naturalmouse.support.DefaultMouseMotionNature;
import net.unethicalite.api.input.naturalmouse.support.MouseMotionNature;

import java.util.Random;

/**
 * This class should be used for creating new MouseMotion-s
 * The default instance is available via getDefault(), but can create new instance via constructor.
 */
public class MouseMotionFactory
{
	private static final MouseMotionFactory defaultFactory = new MouseMotionFactory();
	private MouseMotionNature nature;
	private Random random = new Random();

	public MouseMotionFactory(MouseMotionNature nature)
	{
		this.nature = nature;
	}

	public MouseMotionFactory()
	{
		this(new DefaultMouseMotionNature());
	}

	/**
	 * Get the default factory implementation.
	 *
	 * @return the factory
	 */
	public static MouseMotionFactory getDefault()
	{
		return defaultFactory;
	}

	/**
	 * Builds the MouseMotion, which can be executed instantly or saved for later.
	 *
	 * @param xDest the end position x-coordinate for the mouse
	 * @param yDest the end position y-coordinate for the mouse
	 * @return the MouseMotion which can be executed instantly or saved for later. (Mouse will be moved from its
	 * current position, not from the position where mouse was during building.)
	 */
	public MouseMotion build(int xDest, int yDest)
	{
		return new MouseMotion(nature, random, xDest, yDest);
	}

	/**
	 * Start moving the mouse to specified location. Blocks until done.
	 *
	 * @param xDest the end position x-coordinate for the mouse
	 * @param yDest the end position y-coordinate for the mouse
	 * @throws InterruptedException if something interrupts the thread.
	 */
	public void move(int xDest, int yDest) throws InterruptedException
	{
		build(xDest, yDest).move();
	}

	/**
	 * see {@link MouseMotionNature#getSystemCalls()}
	 *
	 * @return the systemcalls
	 */
	public SystemCalls getSystemCalls()
	{
		return nature.getSystemCalls();
	}

	/**
	 * see {@link MouseMotionNature#setSystemCalls(SystemCalls)}
	 *
	 * @param systemCalls the systemcalls
	 */
	public void setSystemCalls(SystemCalls systemCalls)
	{
		nature.setSystemCalls(systemCalls);
	}

	/**
	 * see {@link MouseMotionNature#getDeviationProvider()}
	 *
	 * @return the deviation provider
	 */
	public DeviationProvider getDeviationProvider()
	{
		return nature.getDeviationProvider();
	}

	/**
	 * see {@link MouseMotionNature#setDeviationProvider(DeviationProvider)}
	 *
	 * @param deviationProvider the deviation provider
	 */
	public void setDeviationProvider(DeviationProvider deviationProvider)
	{
		nature.setDeviationProvider(deviationProvider);
	}

	/**
	 * see {@link MouseMotionNature#getNoiseProvider()}
	 *
	 * @return the noise provider
	 */
	public NoiseProvider getNoiseProvider()
	{
		return nature.getNoiseProvider();
	}

	/**
	 * see {@link MouseMotionNature#setNoiseProvider(NoiseProvider)}}
	 *
	 * @param noiseProvider the noise provider
	 */
	public void setNoiseProvider(NoiseProvider noiseProvider)
	{
		nature.setNoiseProvider(noiseProvider);
	}

	/**
	 * Get the random used whenever randomized behavior is needed in MouseMotion
	 *
	 * @return the random
	 */
	public Random getRandom()
	{
		return random;
	}

	/**
	 * Set the random used whenever randomized behavior is needed in MouseMotion
	 *
	 * @param random the random
	 */
	public void setRandom(Random random)
	{
		this.random = random;
	}

	/**
	 * see {@link MouseMotionNature#getMouseInfo()}
	 *
	 * @return the mouseInfo
	 */
	public MouseInfoAccessor getMouseInfo()
	{
		return nature.getMouseInfo();
	}

	/**
	 * see {@link MouseMotionNature#setMouseInfo(MouseInfoAccessor)}
	 *
	 * @param mouseInfo the mouseInfo
	 */
	public void setMouseInfo(MouseInfoAccessor mouseInfo)
	{
		nature.setMouseInfo(mouseInfo);
	}

	/**
	 * see {@link MouseMotionNature#getSpeedManager()}
	 *
	 * @return the manager
	 */
	public SpeedManager getSpeedManager()
	{
		return nature.getSpeedManager();
	}

	/**
	 * see {@link MouseMotionNature#setSpeedManager(SpeedManager)}
	 *
	 * @param speedManager the manager
	 */
	public void setSpeedManager(SpeedManager speedManager)
	{
		nature.setSpeedManager(speedManager);
	}

	/**
	 * The Nature of mousemotion covers all aspects how the mouse is moved.
	 *
	 * @return the nature
	 */
	public MouseMotionNature getNature()
	{
		return nature;
	}

	/**
	 * The Nature of mousemotion covers all aspects how the mouse is moved.
	 *
	 * @param nature the new nature
	 */
	public void setNature(MouseMotionNature nature)
	{
		this.nature = nature;
	}

	/**
	 * see {@link MouseMotionNature#getOvershootManager()}
	 *
	 * @return the manager
	 */
	public OvershootManager getOvershootManager()
	{
		return nature.getOvershootManager();
	}

	/**
	 * see {@link MouseMotionNature#setOvershootManager(OvershootManager)}
	 *
	 * @param manager the manager
	 */
	public void setOvershootManager(OvershootManager manager)
	{
		nature.setOvershootManager(manager);
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.input.naturalmouse.api.DeviationProvider;
import net.unethicalite.api.input.naturalmouse.api.MouseInfoAccessor;
import net.unethicalite.api.input.naturalmouse.api.NoiseProvider;
import net.unethicalite.api.input.naturalmouse.api.OvershootManager;
import net.unethicalite.api.input.naturalmouse.api.SpeedManager;
import net.unethicalite.api.input.naturalmouse.api.SystemCalls;

public class MouseMotionNature
{
	private double timeToStepsDivider;
	private int minSteps;

	private int effectFadeSteps;
	private int reactionTimeBaseMs;
	private int reactionTimeVariationMs;
	private DeviationProvider deviationProvider;
	private NoiseProvider noiseProvider;
	private OvershootManager overshootManager;
	private MouseInfoAccessor mouseInfo;
	private SystemCalls systemCalls;
	private SpeedManager speedManager;

	/**
	 * Time to steps is how NaturalMouseMotion calculates how many locations need to be visited between
	 * start and end point. More steps means more smooth movement. Thus increasing this divider means less
	 * steps and decreasing means more steps.
	 *
	 * @return the divider which is used to get amount of steps from the planned movement time
	 */
	public double getTimeToStepsDivider()
	{
		return timeToStepsDivider;
	}

	/**
	 * Time to steps is how NaturalMouseMotion calculates how many locations need to be visited between
	 * start and end point. More steps means more smooth movement. Thus increasing this divider means less
	 * steps and decreasing means more steps. The default value should be as smooth as needed for any real
	 * purpose. So unless this really is the issue, you shouldn't touch this value.
	 *
	 * @param timeToStepsDivider the divider which is used to get amount of steps from the planned movement time
	 */
	public void setTimeToStepsDivider(double timeToStepsDivider)
	{
		this.timeToStepsDivider = timeToStepsDivider;
	}

	/**
	 * Minimum amount of steps that is taken to reach the target, this is used when calculation otherwise would
	 * lead to too few steps for smooth mouse movement, which can happen for very fast movements.
	 *
	 * @return the minimal amount of steps used.
	 */
	public int getMinSteps()
	{
		return minSteps;
	}

	/**
	 * Minimum amount of steps that is taken to reach the target, this is used when calculation otherwise would
	 * lead to too few steps for smooth mouse movement, which can happen for very fast movements.
	 * The default value should cover your needs, usually no need to touch this.
	 *
	 * @param minSteps the minimal amount of steps used
	 */
	public void setMinSteps(int minSteps)
	{
		this.minSteps = minSteps;
	}

	/**
	 * Effect fade decreases the noise and deviation effects linearly to 0 at the end of the mouse movement,
	 * so mouse would end up in the intended target pixel even when noise or deviation would otherwise
	 * add offset to mouse position.
	 *
	 * @return the number of steps before last the effect starts to fade
	 */
	public int getEffectFadeSteps()
	{
		return effectFadeSteps;
	}

	/**
	 * Effect fade decreases the noise and deviation effects linearly to 0 at the end of the mouse movement,
	 * so mouse would end up in the intended target pixel even when noise or deviation would otherwise
	 * add offset to mouse position.
	 *
	 * @param effectFadeSteps the number of steps before last the effect starts to fade
	 */
	public void setEffectFadeSteps(int effectFadeSteps)
	{
		this.effectFadeSteps = effectFadeSteps;
	}

	/**
	 * Get the minimal sleep time when overshoot or some other feature has caused mouse to miss the original target
	 * to prepare for next attempt to move the mouse to target.
	 *
	 * @return the sleep time
	 */
	public int getReactionTimeBaseMs()
	{
		return reactionTimeBaseMs;
	}

	/**
	 * Set the minimal sleep time when overshoot or some other feature has caused mouse to miss the original target
	 * to prepare for next attempt to move the mouse to target.
	 *
	 * @param reactionTimeBaseMs the sleep time
	 */
	public void setReactionTimeBaseMs(int reactionTimeBaseMs)
	{
		this.reactionTimeBaseMs = reactionTimeBaseMs;
	}

	/**
	 * Get the random sleep time when overshoot or some other feature has caused mouse to miss the original target
	 * to prepare for next attempt to move the mouse to target. Random part of this is added to the reactionTimeBaseMs.
	 *
	 * @return reactionTimeVariationMs the sleep time
	 */
	public int getReactionTimeVariationMs()
	{
		return reactionTimeVariationMs;
	}

	/**
	 * Set the random sleep time when overshoot or some other feature has caused mouse to miss the original target
	 * to prepare for next attempt to move the mouse to target. Random part of this is added to the reactionTimeBaseMs.
	 *
	 * @param reactionTimeVariationMs the sleep time
	 */
	public void setReactionTimeVariationMs(int reactionTimeVariationMs)
	{
		this.reactionTimeVariationMs = reactionTimeVariationMs;
	}

	/**
	 * Get the provider which is used to define how the MouseMotion trajectory is being deviated or arced
	 *
	 * @return the provider
	 */
	public DeviationProvider getDeviationProvider()
	{
		return deviationProvider;
	}

	/**
	 * Set the provider which is used to define how the MouseMotion trajectory is being deviated or arced.
	 * Alters the underlying nature instance in this factory.
	 *
	 * @param deviationProvider the provider
	 */
	public void setDeviationProvider(DeviationProvider deviationProvider)
	{
		this.deviationProvider = deviationProvider;
	}

	/**
	 * Get the provider which is used to make random mistakes in the trajectory of the moving mouse
	 *
	 * @return the provider
	 */
	public NoiseProvider getNoiseProvider()
	{
		return noiseProvider;
	}

	/**
	 * set the provider which is used to make random mistakes in the trajectory of the moving mouse.
	 * Alters the underlying nature instance in this factory.
	 *
	 * @param noiseProvider the provider
	 */
	public void setNoiseProvider(NoiseProvider noiseProvider)
	{
		this.noiseProvider = noiseProvider;
	}

	/**
	 * Get the accessor object, which MouseMotion uses to detect the position of mouse on screen.
	 *
	 * @return the accessor
	 */
	public MouseInfoAccessor getMouseInfo()
	{
		return mouseInfo;
	}

	/**
	 * Set the accessor object, which MouseMotion uses to detect the position of mouse on screen.
	 *
	 * @param mouseInfo the accessor object
	 */
	public void setMouseInfo(MouseInfoAccessor mouseInfo)
	{
		this.mouseInfo = mouseInfo;
	}

	/**
	 * Get a system call interface, which MouseMotion uses internally
	 *
	 * @return the interface
	 */
	public SystemCalls getSystemCalls()
	{
		return systemCalls;
	}

	/**
	 * Set a system call interface, which MouseMotion uses internally.
	 *
	 * @param systemCalls the interface
	 */
	public void setSystemCalls(SystemCalls systemCalls)
	{
		this.systemCalls = systemCalls;
	}

	/**
	 * Get the speed manager. SpeedManager controls how long does it take to complete a movement and within that
	 * time how slow or fast the cursor is moving at a particular moment, the flow of movement.
	 *
	 * @return the SpeedManager
	 */
	public SpeedManager getSpeedManager()
	{
		return speedManager;
	}

	/**
	 * Sets the speed manager. SpeedManager controls how long does it take to complete a movement and within that
	 * time how slow or fast the cursor is moving at a particular moment, the flow of movement.
	 *
	 * @param speedManager the SpeedManager
	 */
	public void setSpeedManager(SpeedManager speedManager)
	{
		this.speedManager = speedManager;
	}

	/**
	 * Get the manager that deals with overshoot properties.
	 * Overshoots provide a realistic way to simulate user trying to reach the destination with mouse, but miss.
	 *
	 * @return the manager
	 */
	public OvershootManager getOvershootManager()
	{
		return overshootManager;
	}

	/**
	 * Set the manager that deals with overshoot properties.
	 * Overshoots provide a realistic way to simulate user trying to reach the destination with mouse, but miss.
	 *
	 * @param overshootManager the manager
	 */
	public void setOvershootManager(OvershootManager overshootManager)
	{
		this.overshootManager = overshootManager;
	}
}

package net.unethicalite.api.input.naturalmouse.api;

/**
 * Use to observe mouse movement in MouseMotion
 */
public interface MouseMotionObserver
{
	void observe(int xPos, int yPos);
}

package net.unethicalite.api.input.naturalmouse.support.mousemotion;

import net.unethicalite.api.input.naturalmouse.support.Flow;

public class MouseMovement
{
	public final int destX;
	public final int destY;
	public final double distance;
	public final int xDistance;
	public final int yDistance;
	public final long time;
	public final Flow flow;

	public MouseMovement(int destX, int destY, double distance, int xDistance, int yDistance, long time, Flow flow)
	{
		this.destX = destX;
		this.destY = destY;
		this.distance = distance;
		this.xDistance = xDistance;
		this.yDistance = yDistance;
		this.time = time;
		this.flow = flow;
	}

	@Override
	public String toString()
	{
		return "Movement{" +
				"destX=" + destX +
				", destY=" + destY +
				", xDistance=" + xDistance +
				", yDistance=" + yDistance +
				", time=" + time +
				'}';
	}
}

package net.unethicalite.api.packets;

import net.runelite.api.packets.PacketBufferNode;
import net.unethicalite.api.game.Game;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.client.Static;

public class MousePackets
{
	public static void queueClickPacket(int x, int y)
	{
		Static.getClient().setMouseLastPressedMillis(System.currentTimeMillis());
		int mousePressedTime = ((int) (Static.getClient().getMouseLastPressedMillis() - Static.getClient().getClientMouseLastPressedMillis()));
		if (mousePressedTime < 0)
		{
			mousePressedTime = 0;
		}
		if (mousePressedTime > 32767)
		{
			mousePressedTime = 32767;
		}
		Static.getClient().setClientMouseLastPressedMillis(Static.getClient().getMouseLastPressedMillis());
		int mouseInfo = (mousePressedTime << 1) + 1;
		MousePackets.queueClickPacket(mouseInfo, x, y);
	}

	public static void queueClickPacket(int mouseInfo, int x, int y)
	{
		GameThread.invoke(() -> createClickPacket(mouseInfo, x, y).send());
	}

	public static void queueClickPacket()
	{
		queueClickPacket(0, 0);
	}

	public static PacketBufferNode createClickPacket(int mouseInfo, int x, int y)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.EVENT_MOUSE_CLICK(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShort(mouseInfo);
		packetBufferNode.getPacketBuffer().writeShort(x);
		packetBufferNode.getPacketBuffer().writeShort(y);
		return packetBufferNode;
	}
}
package net.unethicalite.api.movement;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Locatable;
import net.runelite.api.MenuAction;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.movement.pathfinder.Walker;
import net.unethicalite.api.movement.pathfinder.model.BankLocation;
import net.unethicalite.api.scene.Tiles;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

import java.util.Comparator;
import java.util.List;

@Slf4j
public class Movement
{
	private static final int STAMINA_VARBIT = 25;
	private static final int RUN_VARP = 173;

	public static void setDestination(int sceneX, int sceneY)
	{
		Static.getClient().setSelectedSceneTileX(sceneX);
		Static.getClient().setSelectedSceneTileY(sceneY);
		Static.getClient().setViewportWalking(true);
	}

	public static WorldPoint getDestination()
	{
		Client client = Static.getClient();
		if (client.getDestinationX() == 0 && client.getDestinationY() == 0)
		{
			return null;
		}

		return new WorldPoint(
				client.getDestinationX() + client.getBaseX(),
				client.getDestinationY() + client.getBaseY(),
				client.getPlane()
		);
	}

	public static boolean isWalking()
	{
		Player local = Players.getLocal();
		WorldPoint destination = getDestination();
		return local.isMoving()
				&& destination != null
				&& destination.distanceTo(local) > 4;
	}

	public static void walk(WorldPoint worldPoint)
	{
		Client client = Static.getClient();
		Player local = client.getLocalPlayer();
		if (local == null)
		{
			return;
		}

		WorldPoint walkPoint = worldPoint;
		Tile destinationTile = Tiles.getAt(worldPoint);
		// Check if tile is in loaded client scene
		if (destinationTile == null)
		{
			log.debug("Destination {} is not in scene", worldPoint);
			Tile nearestInScene = Tiles.getAll()
					.stream()
					.min(Comparator.comparingInt(x -> x.getWorldLocation().distanceTo(local.getWorldLocation())))
					.orElse(null);
			if (nearestInScene == null)
			{
				log.debug("Couldn't find nearest walkable tile");
				return;
			}

			walkPoint = nearestInScene.getWorldLocation();
		}

		int sceneX = walkPoint.getX() - client.getBaseX();
		int sceneY = walkPoint.getY() - client.getBaseY();
		Point canv = Perspective.localToCanvas(client, LocalPoint.fromScene(sceneX, sceneY), client.getPlane());
		int x = canv != null ? canv.getX() : -1;
		int y = canv != null ? canv.getY() : -1;

		client.interact(
				0,
				MenuAction.WALK.getId(),
				sceneX,
				sceneY,
				x,
				y
		);
	}

	public static boolean walkTo(WorldArea worldArea)
	{
		return Walker.walkTo(worldArea);
	}

	public static void walk(Locatable locatable)
	{
		walk(locatable.getWorldLocation());
	}

	public static boolean walkTo(WorldPoint worldPoint)
	{
		return Walker.walkTo(worldPoint);
	}

	public static boolean walkTo(Locatable locatable)
	{
		return walkTo(locatable.getWorldLocation());
	}

	public static boolean walkTo(BankLocation bankLocation)
	{
		return walkTo(bankLocation.getArea());
	}

	public static boolean walkTo(int x, int y)
	{
		return walkTo(x, y, Static.getClient().getPlane());
	}

	public static boolean walkTo(int x, int y, int plane)
	{
		return walkTo(new WorldPoint(x, y, plane));
	}

	public static boolean isRunEnabled()
	{
		return Vars.getVarp(RUN_VARP) == 1;
	}

	public static void toggleRun()
	{
		Widget widget = Widgets.get(WidgetInfo.MINIMAP_TOGGLE_RUN_ORB);
		if (widget != null)
		{
			widget.interact("Toggle Run");
		}
	}

	public static boolean isStaminaBoosted()
	{
		return Vars.getBit(STAMINA_VARBIT) == 1;
	}

	public static int getRunEnergy()
	{
		return Static.getClient().getEnergy() / 100;
	}

	public static int calculateDistance(WorldArea destination)
	{
		return Walker.calculatePath(destination).size();
	}

	public static int calculateDistance(WorldPoint start, WorldArea destination)
	{
		return calculateDistance(List.of(start), destination);
	}

	public static int calculateDistance(List<WorldPoint> start, WorldArea destination)
	{
		return Walker.calculatePath(start, destination).size();
	}

	public static int calculateDistance(WorldPoint destination)
	{
		return calculateDistance(destination.toWorldArea());
	}

	public static int calculateDistance(WorldPoint start, WorldPoint destination)
	{
		return calculateDistance(start, destination.toWorldArea());
	}

	public static int calculateDistance(List<WorldPoint> start, WorldPoint destination)
	{
		return calculateDistance(start, destination.toWorldArea());
	}
}

package net.unethicalite.api.movement.pathfinder.model;

import net.runelite.api.ItemID;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.movement.pathfinder.TransportLoader;
import org.apache.commons.lang3.tuple.Pair;

import java.util.List;
import java.util.Map;

public class MovementConstants
{
	public static final List<TransportLoader.SpiritTree> SPIRIT_TREES = List.of(
		new TransportLoader.SpiritTree(new WorldPoint(2542, 3170, 0), "Tree Gnome Village"),
		new TransportLoader.SpiritTree(new WorldPoint(2461, 3444, 0), "Gnome Stronghold"),
		new TransportLoader.SpiritTree(new WorldPoint(2555, 3259, 0), "Battlefield of Khazard"),
		new TransportLoader.SpiritTree(new WorldPoint(3185, 3508, 0), "Grand Exchange"),
		new TransportLoader.SpiritTree(new WorldPoint(2488, 2850, 0), "Feldip Hills")
	);
	public static final List<TransportLoader.MagicMushtree> MUSHTREES = List.of(
		new TransportLoader.MagicMushtree(new WorldPoint(3676, 3871, 0), WidgetInfo.FOSSIL_MUSHROOM_MEADOW),
		new TransportLoader.MagicMushtree(new WorldPoint(3764, 3879, 1), WidgetInfo.FOSSIL_MUSHROOM_HOUSE),
		new TransportLoader.MagicMushtree(new WorldPoint(3676, 3755, 0), WidgetInfo.FOSSIL_MUSHROOM_SWAMP),
		new TransportLoader.MagicMushtree(new WorldPoint(3760, 3758, 0), WidgetInfo.FOSSIL_MUSHROOM_VALLEY)
	);

	public static final WorldArea WILDERNESS_ABOVE_GROUND = new WorldArea(2944, 3523, 448, 448, 0);
	public static final WorldArea WILDERNESS_UNDERGROUND = new WorldArea(2944, 9918, 320, 442, 0);
	public static WorldPoint HOUSE_POINT = new WorldPoint(10000, 4000, 1);

	public static final int[] RING_OF_DUELING = new int[]
		{
			ItemID.RING_OF_DUELING8,
			ItemID.RING_OF_DUELING7,
			ItemID.RING_OF_DUELING6,
			ItemID.RING_OF_DUELING5,
			ItemID.RING_OF_DUELING4,
			ItemID.RING_OF_DUELING3,
			ItemID.RING_OF_DUELING2,
			ItemID.RING_OF_DUELING1,
		};

	public static final int[] GAMES_NECKLACE = new int[]
		{
			ItemID.GAMES_NECKLACE8,
			ItemID.GAMES_NECKLACE7,
			ItemID.GAMES_NECKLACE6,
			ItemID.GAMES_NECKLACE5,
			ItemID.GAMES_NECKLACE4,
			ItemID.GAMES_NECKLACE3,
			ItemID.GAMES_NECKLACE2,
			ItemID.GAMES_NECKLACE1,
		};

	public static final int[] COMBAT_BRACELET = new int[]
		{
			ItemID.COMBAT_BRACELET1,
			ItemID.COMBAT_BRACELET2,
			ItemID.COMBAT_BRACELET3,
			ItemID.COMBAT_BRACELET4,
			ItemID.COMBAT_BRACELET5,
			ItemID.COMBAT_BRACELET6,
		};

	public static final int[] RING_OF_WEALTH = new int[]
		{
			ItemID.RING_OF_WEALTH_5,
			ItemID.RING_OF_WEALTH_4,
			ItemID.RING_OF_WEALTH_3,
			ItemID.RING_OF_WEALTH_2,
			ItemID.RING_OF_WEALTH_1,
		};

	public static final int[] AMULET_OF_GLORY = new int[]
		{
			ItemID.AMULET_OF_GLORY6,
			ItemID.AMULET_OF_GLORY5,
			ItemID.AMULET_OF_GLORY4,
			ItemID.AMULET_OF_GLORY3,
			ItemID.AMULET_OF_GLORY2,
			ItemID.AMULET_OF_GLORY1,
		};

	public static final int[] NECKLACE_OF_PASSAGE = new int[]
		{
			ItemID.NECKLACE_OF_PASSAGE1,
			ItemID.NECKLACE_OF_PASSAGE2,
			ItemID.NECKLACE_OF_PASSAGE3,
			ItemID.NECKLACE_OF_PASSAGE4,
			ItemID.NECKLACE_OF_PASSAGE5,
		};

	public static final int[] BURNING_AMULET = new int[]
		{
			ItemID.BURNING_AMULET5,
			ItemID.BURNING_AMULET4,
			ItemID.BURNING_AMULET3,
			ItemID.BURNING_AMULET2,
			ItemID.BURNING_AMULET1,
		};

	public static final int[] XERICS_TALISMAN = new int[]
		{
			ItemID.XERICS_TALISMAN
		};

	public static final int[] SLAYER_RING = new int[]
		{
			ItemID.SLAYER_RING_ETERNAL,
			ItemID.SLAYER_RING_8,
			ItemID.SLAYER_RING_7,
			ItemID.SLAYER_RING_6,
			ItemID.SLAYER_RING_5,
			ItemID.SLAYER_RING_4,
			ItemID.SLAYER_RING_3,
			ItemID.SLAYER_RING_2,
			ItemID.SLAYER_RING_1,
		};

	public static final int[] DIGSITE_PENDANT = new int[]
		{
			ItemID.DIGSITE_PENDANT_5,
			ItemID.DIGSITE_PENDANT_4,
			ItemID.DIGSITE_PENDANT_3,
			ItemID.DIGSITE_PENDANT_2,
			ItemID.DIGSITE_PENDANT_1,
		};

	public static final int[] DRAKANS_MEDALLION = new int[]
		{
			ItemID.DRAKANS_MEDALLION
		};

	public static final int[] SKILLS_NECKLACE = new int[]
		{
			ItemID.SKILLS_NECKLACE6,
			ItemID.SKILLS_NECKLACE5,
			ItemID.SKILLS_NECKLACE4,
			ItemID.SKILLS_NECKLACE3,
			ItemID.SKILLS_NECKLACE2,
			ItemID.SKILLS_NECKLACE1,
		};

	public static final int[] TELEPORT_CRYSTAL = new int[]
		{
			ItemID.ETERNAL_TELEPORT_CRYSTAL,
			ItemID.TELEPORT_CRYSTAL_5,
			ItemID.TELEPORT_CRYSTAL_4,
			ItemID.TELEPORT_CRYSTAL_5,
			ItemID.TELEPORT_CRYSTAL_2,
			ItemID.TELEPORT_CRYSTAL_1
		};

	public static final int[] ENCHANTED_LYRE = new int[]
		{
			ItemID.ENCHANTED_LYREI,
			ItemID.ENCHANTED_LYRE5,
			ItemID.ENCHANTED_LYRE4,
			ItemID.ENCHANTED_LYRE3,
			ItemID.ENCHANTED_LYRE2,
			ItemID.ENCHANTED_LYRE1
		};

	public static final int[] SLASH_ITEMS = new int[]
		{
			ItemID.KNIFE,
			ItemID.WILDERNESS_SWORD_1,
			ItemID.WILDERNESS_SWORD_2,
			ItemID.WILDERNESS_SWORD_3,
			ItemID.WILDERNESS_SWORD_4
		};

	public static final List<Pair<WorldPoint, WorldPoint>> SLASH_WEB_POINTS = List.<Pair<WorldPoint, WorldPoint>>of(
		Pair.of(new WorldPoint(3031, 3852, 0), new WorldPoint(3029, 3852, 0)),
		Pair.of(new WorldPoint(3148, 3727, 0), new WorldPoint(3146, 3727, 0)),
		Pair.of(new WorldPoint(3147, 3728, 0), new WorldPoint(3147, 3726, 0)),
		Pair.of(new WorldPoint(3164, 3736, 0), new WorldPoint(3162, 3736, 0)),
		Pair.of(new WorldPoint(3163, 3737, 0), new WorldPoint(3163, 3735, 0)),
		Pair.of(new WorldPoint(3183, 3734, 0), new WorldPoint(3183, 3732, 0)),
		Pair.of(new WorldPoint(3158, 3952, 0), new WorldPoint(3158, 3950, 0)),
		Pair.of(new WorldPoint(3210, 9899, 0), new WorldPoint(3210, 9897, 0)),
		Pair.of(new WorldPoint(3115, 3860, 0), new WorldPoint(3115, 3858, 0)),
		Pair.of(new WorldPoint(3093, 3957, 0), new WorldPoint(3091, 3957, 0)),
		Pair.of(new WorldPoint(3096, 3957, 0), new WorldPoint(3094, 3957, 0)),
		Pair.of(new WorldPoint(3105, 3959, 0), new WorldPoint(3105, 3957, 0)),
		Pair.of(new WorldPoint(3106, 3959, 0), new WorldPoint(3106, 3957, 0)),
		Pair.of(new WorldPoint(2654, 9767, 0), new WorldPoint(2654, 9765, 0)),
		Pair.of(new WorldPoint(2566, 3124, 0), new WorldPoint(2564, 3124, 0)),
		Pair.of(new WorldPoint(2565, 3125, 0), new WorldPoint(2565, 3123, 0)),
		Pair.of(new WorldPoint(2569, 3119, 0), new WorldPoint(2569, 3117, 0)),
		Pair.of(new WorldPoint(2570, 3119, 0), new WorldPoint(2570, 3117, 0)),
		Pair.of(new WorldPoint(2574, 3125, 0), new WorldPoint(2574, 3123, 0)),
		Pair.of(new WorldPoint(2631, 9248, 0), new WorldPoint(2629, 9248, 0)),
		Pair.of(new WorldPoint(2632, 9264, 0), new WorldPoint(2630, 9264, 0)),
		Pair.of(new WorldPoint(2628, 9231, 1), new WorldPoint(2628, 9229, 1)),
		Pair.of(new WorldPoint(2629, 9239, 1), new WorldPoint(2629, 9237, 1)),
		Pair.of(new WorldPoint(2647, 9118, 0), new WorldPoint(2647, 9116, 0)),
		Pair.of(new WorldPoint(2638, 9092, 1), new WorldPoint(2638, 9090, 1)),
		Pair.of(new WorldPoint(2653, 9124, 1), new WorldPoint(2653, 9122, 1)),
		Pair.of(new WorldPoint(2663, 9110, 1), new WorldPoint(2663, 9108, 1)),
		Pair.of(new WorldPoint(2633, 9200, 0), new WorldPoint(2633, 9198, 0)),
		Pair.of(new WorldPoint(2646, 9190, 0), new WorldPoint(2644, 9190, 0)),
		Pair.of(new WorldPoint(2648, 9199, 0), new WorldPoint(2648, 9197, 0)),
		Pair.of(new WorldPoint(2662, 9206, 0), new WorldPoint(2662, 9204, 0)),
		Pair.of(new WorldPoint(2666, 9160, 0), new WorldPoint(2664, 9160, 0)),
		Pair.of(new WorldPoint(2668, 9194, 0), new WorldPoint(2666, 9194, 0)),
		Pair.of(new WorldPoint(2541, 9069, 1), new WorldPoint(2539, 9069, 1)),
		Pair.of(new WorldPoint(2547, 9064, 1), new WorldPoint(2547, 9062, 1)),
		Pair.of(new WorldPoint(2551, 9054, 1), new WorldPoint(2551, 9052, 1)),
		Pair.of(new WorldPoint(2555, 9039, 1), new WorldPoint(2553, 9039, 1)),
		Pair.of(new WorldPoint(2604, 9273, 1), new WorldPoint(2602, 9273, 1)),
		Pair.of(new WorldPoint(2618, 9211, 1), new WorldPoint(2618, 9209, 1)),
		Pair.of(new WorldPoint(2620, 9205, 1), new WorldPoint(2620, 9203, 1)),
		Pair.of(new WorldPoint(2571, 9051, 0), new WorldPoint(2569, 9051, 0)),
		Pair.of(new WorldPoint(2570, 9052, 0), new WorldPoint(2570, 9050, 0)),
		Pair.of(new WorldPoint(2599, 9080, 1), new WorldPoint(2597, 9080, 1)),
		Pair.of(new WorldPoint(2608, 9079, 1), new WorldPoint(2606, 9079, 1)),
		Pair.of(new WorldPoint(2610, 9047, 1), new WorldPoint(2610, 9045, 1)),
		Pair.of(new WorldPoint(2613, 9057, 1), new WorldPoint(2613, 9055, 1)),
		Pair.of(new WorldPoint(2619, 9071, 1), new WorldPoint(2617, 9071, 1)),
		Pair.of(new WorldPoint(2618, 9072, 1), new WorldPoint(2618, 9070, 1)),
		Pair.of(new WorldPoint(2674, 9039, 0), new WorldPoint(2674, 9037, 0)),
		Pair.of(new WorldPoint(2633, 9049, 1), new WorldPoint(2633, 9047, 1)),
		Pair.of(new WorldPoint(2639, 9062, 1), new WorldPoint(2637, 9062, 1)),
		Pair.of(new WorldPoint(2638, 9063, 1), new WorldPoint(2638, 9061, 1)),
		Pair.of(new WorldPoint(2645, 9056, 1), new WorldPoint(2643, 9056, 1)),
		Pair.of(new WorldPoint(2655, 9073, 1), new WorldPoint(2653, 9073, 1)),
		Pair.of(new WorldPoint(2654, 9074, 1), new WorldPoint(2654, 9072, 1)),
		Pair.of(new WorldPoint(2657, 9082, 1), new WorldPoint(2655, 9082, 1)),
		Pair.of(new WorldPoint(2676, 9074, 1), new WorldPoint(2674, 9074, 1)),
		Pair.of(new WorldPoint(2678, 9061, 1), new WorldPoint(2678, 9059, 1)),
		Pair.of(new WorldPoint(2678, 9068, 1), new WorldPoint(2678, 9066, 1)),
		Pair.of(new WorldPoint(1833, 9945, 0), new WorldPoint(1833, 9943, 0)),
		Pair.of(new WorldPoint(1841, 9934, 0), new WorldPoint(1841, 9932, 0)),
		Pair.of(new WorldPoint(1843, 9933, 0), new WorldPoint(1841, 9933, 0)),
		Pair.of(new WorldPoint(1842, 9934, 0), new WorldPoint(1842, 9932, 0)),
		Pair.of(new WorldPoint(1849, 9935, 0), new WorldPoint(1849, 9933, 0)),
		Pair.of(new WorldPoint(1850, 9935, 0), new WorldPoint(1850, 9933, 0)),
		Pair.of(new WorldPoint(1848, 9919, 0), new WorldPoint(1846, 9919, 0)),
		Pair.of(new WorldPoint(1847, 9920, 0), new WorldPoint(1847, 9918, 0))
	);

	public static final Map<Integer, Pair<WorldPoint, WorldPoint>> DRAYNOR_MANOR_BASEMENT_DOORS = Map.of(
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_1_STATE, Pair.of(new WorldPoint(3108, 9757, 0), new WorldPoint(3108, 9759, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_2_STATE, Pair.of(new WorldPoint(3104, 9760, 0), new WorldPoint(3106, 9760, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_3_STATE, Pair.of(new WorldPoint(3102, 9757, 0), new WorldPoint(3102, 9759, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_4_STATE, Pair.of(new WorldPoint(3101, 9760, 0), new WorldPoint(3098, 9760, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_5_STATE, Pair.of(new WorldPoint(3097, 9762, 0), new WorldPoint(3097, 9764, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_6_STATE, Pair.of(new WorldPoint(3099, 9765, 0), new WorldPoint(3101, 9765, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_7_STATE, Pair.of(new WorldPoint(3104, 9765, 0), new WorldPoint(3106, 9765, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_8_STATE, Pair.of(new WorldPoint(3102, 9764, 0), new WorldPoint(3102, 9762, 0)),
		Varbits.DRAYNOR_MANOR_BASEMENT_DOOR_9_STATE, Pair.of(new WorldPoint(3101, 9755, 0), new WorldPoint(3099, 9755, 0))
	);
}

package net.unethicalite.api.input.naturalmouse.support.mousemotion;

import net.unethicalite.api.input.naturalmouse.api.OvershootManager;
import net.unethicalite.api.input.naturalmouse.api.SpeedManager;
import net.unethicalite.api.input.naturalmouse.support.Flow;
import net.unethicalite.api.input.naturalmouse.util.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.Dimension;
import java.awt.Point;
import java.util.ArrayDeque;
import java.util.Iterator;

public class MovementFactory
{
	private static final Logger log = LoggerFactory.getLogger(MovementFactory.class);
	private final int xDest;
	private final int yDest;
	private final SpeedManager speedManager;
	private final OvershootManager overshootManager;
	private final Dimension screenSize;

	public MovementFactory(int xDest, int yDest, SpeedManager speedManager,
						   OvershootManager overshootManager, Dimension screenSize)
	{
		this.xDest = xDest;
		this.yDest = yDest;
		this.speedManager = speedManager;
		this.overshootManager = overshootManager;
		this.screenSize = screenSize;
	}

	public ArrayDeque<MouseMovement> createMovements(Point currentMousePosition)
	{
		ArrayDeque<MouseMovement> movements = new ArrayDeque<>();
		int lastMousePositionX = currentMousePosition.x;
		int lastMousePositionY = currentMousePosition.y;
		int xDistance = xDest - lastMousePositionX;
		int yDistance = yDest - lastMousePositionY;

		double initialDistance = Math.hypot(xDistance, yDistance);
		Pair<Flow, Long> flowTime = speedManager.getFlowWithTime(initialDistance);
		Flow flow = flowTime.x;
		long mouseMovementMs = flowTime.y;
		int overshoots = overshootManager.getOvershoots(flow, mouseMovementMs, initialDistance);

		if (overshoots == 0)
		{
			movements.add(new MouseMovement(xDest, yDest, initialDistance, xDistance, yDistance, mouseMovementMs, flow));
			return movements;
		}

		for (int i = overshoots; i > 0; i--)
		{
			Point overshoot = overshootManager.getOvershootAmount(
					xDest - lastMousePositionX, yDest - lastMousePositionY, mouseMovementMs, i
			);
			int currentDestinationX = limitByScreenWidth(xDest + overshoot.x);
			int currentDestinationY = limitByScreenHeight(yDest + overshoot.y);
			xDistance = currentDestinationX - lastMousePositionX;
			yDistance = currentDestinationY - lastMousePositionY;
			double distance = Math.hypot(xDistance, yDistance);
			flow = speedManager.getFlowWithTime(distance).x;
			movements.add(
					new MouseMovement(currentDestinationX, currentDestinationY, distance, xDistance, yDistance, mouseMovementMs, flow)
			);
			lastMousePositionX = currentDestinationX;
			lastMousePositionY = currentDestinationY;
			// Apply for the next overshoot if exists.
			mouseMovementMs = overshootManager.deriveNextMouseMovementTimeMs(mouseMovementMs, i - 1);
		}

		Iterator<MouseMovement> it = movements.descendingIterator();

		boolean remove = true;
		// Remove overshoots from the end, which are matching the final destination, but keep those in middle of motion.
		while (it.hasNext() && remove)
		{
			MouseMovement movement = it.next();
			if (movement.destX == xDest && movement.destY == yDest)
			{
				lastMousePositionX = movement.destX - movement.xDistance;
				lastMousePositionY = movement.destY - movement.yDistance;
				it.remove();
			}
			else
			{
				remove = false;
			}
		}

		xDistance = xDest - lastMousePositionX;
		yDistance = yDest - lastMousePositionY;
		double distance = Math.hypot(xDistance, yDistance);
		Pair<Flow, Long> movementToTargetFlowTime = speedManager.getFlowWithTime(distance);
		long finalMovementTime = overshootManager.deriveNextMouseMovementTimeMs(movementToTargetFlowTime.y, 0);
		MouseMovement finalMove = new MouseMovement(
				xDest, yDest, distance, xDistance, yDistance, finalMovementTime, movementToTargetFlowTime.x
		);
		movements.add(finalMove);

		return movements;
	}

	private int limitByScreenWidth(int value)
	{
		return Math.max(0, Math.min(screenSize.width - 1, value));
	}

	private int limitByScreenHeight(int value)
	{
		return Math.max(0, Math.min(screenSize.height - 1, value));
	}


}

package net.unethicalite.api.packets;

import net.runelite.api.coords.WorldPoint;
import net.runelite.api.packets.PacketBufferNode;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

public class MovementPackets
{
	public static void sendMovement(int worldX, int worldY)
	{
		sendMovement(worldX, worldY, false);
	}

	public static void sendMovement(WorldPoint worldPoint, boolean ctrlDown)
	{
		sendMovement(worldPoint.getX(), worldPoint.getY(), ctrlDown);
	}

	public static void sendMovement(WorldPoint worldPoint)
	{
		sendMovement(worldPoint, false);
	}

	public static void sendMovement(int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		createMovement(worldPointX, worldPointY, ctrlDown).send();
	}

	public static PacketBufferNode createMovement(int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.MOVE_GAMECLICK(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByte(5);
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointY);
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointX);
		packetBufferNode.getPacketBuffer().writeByteSub(ctrlDown ? 2 : 0);
		return packetBufferNode;
	}
}
package net.unethicalite.api.input.naturalmouse;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.unethicalite.api.commons.Time;
import net.unethicalite.api.input.Mouse;
import net.unethicalite.api.input.naturalmouse.api.MouseInfoAccessor;
import net.unethicalite.api.input.naturalmouse.api.MouseMotionFactory;
import net.unethicalite.api.input.naturalmouse.api.SystemCalls;
import net.unethicalite.api.input.naturalmouse.support.DefaultMouseMotionNature;
import net.unethicalite.api.input.naturalmouse.support.DefaultNoiseProvider;
import net.unethicalite.api.input.naturalmouse.support.DefaultOvershootManager;
import net.unethicalite.api.input.naturalmouse.support.DefaultSpeedManager;
import net.unethicalite.api.input.naturalmouse.support.Flow;
import net.unethicalite.api.input.naturalmouse.support.MouseMotionNature;
import net.unethicalite.api.input.naturalmouse.support.SinusoidalDeviationProvider;
import net.unethicalite.api.input.naturalmouse.util.FlowTemplates;
import net.unethicalite.api.input.naturalmouse.util.Pair;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Dimension;
import java.awt.Point;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadLocalRandom;

@Singleton
public class NaturalMouse
{
	private final ThreadLocalRandom random = ThreadLocalRandom.current();
	private final MouseMotionNature nature;
	@Inject
	private Client client;
	@Inject
	private ExecutorService executorService;
	@Getter
	@Setter
	private List<Flow> flows = List.of(
			new Flow(FlowTemplates.variatingFlow()),
			new Flow(FlowTemplates.slowStartupFlow()),
			new Flow(FlowTemplates.slowStartup2Flow()),
			new Flow(FlowTemplates.jaggedFlow()),
			new Flow(FlowTemplates.interruptedFlow()),
			new Flow(FlowTemplates.interruptedFlow2()),
			new Flow(FlowTemplates.stoppingFlow()),
			new Flow(FlowTemplates.adjustingFlow()),
			new Flow(FlowTemplates.random())
	);

	@Inject
	private NaturalMouse()
	{
		nature = new DefaultMouseMotionNature();
		nature.setSystemCalls(new SystemCallsImpl());
		nature.setMouseInfo(new MouseInfoImpl());
	}

	public synchronized void moveTo(int dx, int dy)
	{
		if (!client.isClientThread())
		{
			move(dx, dy);
		}
		else
		{
			executorService.submit(() -> move(dx, dy));
		}
	}

	private synchronized void move(int dx, int dy)
	{
		var motion = getFactory().build(dx, dy);
		try
		{
			motion.move();
		}
		catch (InterruptedException e)
		{
			e.printStackTrace();
		}
	}

	public MouseMotionFactory getFactory()
	{
		var factory = new MouseMotionFactory();
		factory.setNature(nature);
		factory.setRandom(random);

		var manager = new SpeedManagerImpl(flows);
		factory.setDeviationProvider(new SinusoidalDeviationProvider(10.0));
		factory.setNoiseProvider(new DefaultNoiseProvider(2.0));
		factory.getNature().setReactionTimeVariationMs(75);
		manager.setMouseMovementBaseTimeMs(150);

		var overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
		overshootManager.setOvershoots(4);
		factory.setSpeedManager(manager);

		return factory;
	}

	public void moveOffScreen()
	{
		// 1 in 4 chance of moving off screen
		if (random.nextInt(4) == 0)
		{
			// Edges of the screen
			int horizontal = random.nextBoolean() ? -1 : client.getCanvasWidth() + 1;
			int vertical = random.nextBoolean() ? -1 : client.getCanvasHeight() + 1;

			boolean exitHorizontally = random.nextBoolean();
			if (exitHorizontally)
			{
				moveTo(horizontal, random.nextInt(0, client.getCanvasHeight() + 1));
			}
			else
			{
				moveTo(random.nextInt(0, client.getCanvasWidth() + 1), vertical);
			}

			if (random.nextInt(4) == 0)
			{
				client.setFocused(false);
			}
		}
	}

	private static class SpeedManagerImpl extends DefaultSpeedManager
	{
		private SpeedManagerImpl(Collection<Flow> flows)
		{
			super(flows);
		}

		@Override
		public Pair<Flow, Long> getFlowWithTime(double distance)
		{
			var pair = super.getFlowWithTime(distance);
			return new Pair<>(pair.x, pair.y);
		}
	}

	private static class MouseInfoImpl implements MouseInfoAccessor
	{
		@Override
		public Point getMousePosition()
		{
			return Mouse.getPosition();
		}
	}

	private class SystemCallsImpl implements SystemCalls
	{
		@Override
		public long currentTimeMillis()
		{
			return System.currentTimeMillis();
		}

		@Override
		public void sleep(long time)
		{
			Time.sleep(time);
		}

		@Override
		public Dimension getScreenSize()
		{
			return client.getCanvas().getSize();
		}

		@Override
		public void setMousePosition(int x, int y)
		{
			client.getMouseHandler().sendMovement(x, y);
		}
	}
}

package net.unethicalite.api.input.naturalmouse.api;

import net.unethicalite.api.input.naturalmouse.support.DoublePoint;

import java.util.Random;

/**
 * Provides noise or mistakes in the mouse movement
 * <p>
 * NoiseProvider implementation should be immutable.
 */
public interface NoiseProvider
{
	/**
	 * Noise is offset from the original trajectory, simulating user and physical errors on mouse movement.
	 * <p>
	 * Noise is accumulating, so on average it should create an equal chance of either positive or negative movement
	 * on each axis, otherwise the mouse movement will always be slightly offset to single direction.
	 * <p>
	 * Deviation from DeviationProvider is different from the Noise
	 * because it works like a mathematical function and is not accumulating.
	 * <p>
	 * Not every step needs to add noise, use randomness to only add noise sometimes, otherwise return Point(0, 0).
	 * <p>
	 * During the final steps of mouse movement, the effect of noise is gradually reduced, so the mouse
	 * would finish on the intended pixel smoothly, thus the implementation of this class can safely ignore
	 * and not know the beginning and end of the movement.
	 *
	 * @param random    use this to generate randomness in the offset
	 * @param xStepSize the step size that is taken horizontally
	 * @param yStepSize the step size that is taken vertically
	 * @return a point which describes how much the mouse offset is increased or decreased this step.
	 * This value must not include the parameters xStepSize and yStepSize. For no change in noise just return (0,0).
	 * @see DeviationProvider
	 */
	DoublePoint getNoise(Random random, double xStepSize, double yStepSize);
}

package net.unethicalite.api.packets;

import net.runelite.api.NPC;
import net.runelite.api.packets.PacketBufferNode;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

public class NPCPackets
{
	public static void npcFirstOption(NPC npc, boolean ctrlDown)
	{
		queueNPCAction1Packet(npc.getIndex(), ctrlDown);
	}

	public static void npcSecondOption(NPC npc, boolean ctrlDown)
	{
		queueNPCAction2Packet(npc.getIndex(), ctrlDown);
	}

	public static void npcThirdOption(NPC npc, boolean ctrlDown)
	{
		queueNPCAction3Packet(npc.getIndex(), ctrlDown);
	}

	public static void npcFourthOption(NPC npc, boolean ctrlDown)
	{
		queueNPCAction4Packet(npc.getIndex(), ctrlDown);
	}

	public static void npcFifthOption(NPC npc, boolean ctrlDown)
	{
		queueNPCAction5Packet(npc.getIndex(), ctrlDown);
	}

	public static void npcAction(NPC npc, String action, boolean ctrlDown)
	{
		int index = npc.getActionIndex(action);
		switch (index)
		{
			case 0:
				npcFirstOption(npc, ctrlDown);
				break;
			case 1:
				npcSecondOption(npc, ctrlDown);
				break;
			case 2:
				npcThirdOption(npc, ctrlDown);
				break;
			case 3:
				npcFourthOption(npc, ctrlDown);
				break;
			case 4:
				npcFifthOption(npc, ctrlDown);
				break;
		}
	}

	public static void spellOnNpc(int widgetId, NPC npc, boolean b)
	{
		queueSpellOnNpcPacket(npc.getIndex(), widgetId, b);
	}

	public static void queueItemOnNpcPacket(int npcIndex, int itemWidgetId, int itemId, int itemSlot, boolean ctrlDown)
	{
		createItemOnNpcPacket(npcIndex, itemWidgetId, itemId, itemSlot, ctrlDown).send();
	}

	public static void queueSpellOnNpcPacket(int npcIndex, int spellWidgetId, boolean ctrlDown)
	{
		createSpellOnNpcPacket(npcIndex, spellWidgetId, ctrlDown).send();
	}

	public static void queueNPCAction1Packet(int npcIndex, boolean ctrlDown)
	{
		createNpcFirstActionPacket(npcIndex, ctrlDown).send();
	}

	public static void queueNPCAction2Packet(int npcIndex, boolean ctrlDown)
	{
		createNpcSecondActionPacket(npcIndex, ctrlDown).send();
	}

	public static void queueNPCAction3Packet(int npcIndex, boolean ctrlDown)
	{
		createNpcThirdActionPacket(npcIndex, ctrlDown).send();
	}

	public static void queueNPCAction4Packet(int npcIndex, boolean ctrlDown)
	{
		createNpcFourthActionPacket(npcIndex, ctrlDown).send();
	}

	public static void queueNPCAction5Packet(int npcIndex, boolean ctrlDown)
	{
		createNpcFifthActionPacket(npcIndex, ctrlDown).send();
	}

	public static PacketBufferNode createItemOnNpcPacket(int npcIndex, int itemWidgetId, int itemId, int itemSlot, boolean ctrlDown)
	{
		return createWidgetOnNpc(npcIndex, itemWidgetId, itemId, itemSlot, ctrlDown);
	}

	public static PacketBufferNode createWidgetOnNpc(int npcIndex, int sourceWidgetId, int sourceItemId, int sourceSlot, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPNPCT(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(sourceItemId);
		packetBufferNode.getPacketBuffer().writeIntIME(sourceWidgetId);
		packetBufferNode.getPacketBuffer().writeShortLE(npcIndex);
		packetBufferNode.getPacketBuffer().writeShortAdd(sourceSlot);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createSpellOnNpcPacket(int npcIndex, int spellWidgetId, boolean ctrlDown)
	{
		return createWidgetOnNpc(npcIndex, spellWidgetId, -1, -1, ctrlDown);
	}

	public static PacketBufferNode createNpcFirstActionPacket(int npcIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPNPC1(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByte(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAddLE(npcIndex);
		return packetBufferNode;
	}

	public static PacketBufferNode createNpcSecondActionPacket(int npcIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPNPC2(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(npcIndex);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createNpcThirdActionPacket(int npcIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPNPC3(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortLE(npcIndex);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createNpcFourthActionPacket(int npcIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPNPC4(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(npcIndex);
		packetBufferNode.getPacketBuffer().writeByteSub(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createNpcFifthActionPacket(int npcIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPNPC5(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByte(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAdd(npcIndex);
		return packetBufferNode;
	}
}
package net.unethicalite.api.query.entities;

import net.unethicalite.api.query.results.SceneEntityQueryResults;
import net.runelite.api.NPC;
import org.apache.commons.lang3.ArrayUtils;

import java.util.List;
import java.util.function.Supplier;

public class NPCQuery extends ActorQuery<NPC, NPCQuery>
{
	private int[] indices = null;

	public NPCQuery(Supplier<List<NPC>> supplier)
	{
		super(supplier);
	}

	public NPCQuery indices(int... indices)
	{
		this.indices = indices;
		return this;
	}

	@Override
	protected SceneEntityQueryResults<NPC> results(List<NPC> list)
	{
		return new SceneEntityQueryResults<>(list);
	}

	@Override
	public boolean test(NPC npc)
	{
		if (indices != null && !ArrayUtils.contains(indices, npc.getIndex()))
		{
			return false;
		}

		return super.test(npc);
	}
}

package net.unethicalite.api.entities;

import net.unethicalite.api.query.entities.NPCQuery;
import net.unethicalite.client.Static;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class NPCs extends Entities<NPC>
{
	private NPCs()
	{
	}

	private static final NPCs NPCS = new NPCs();

	@Override
	protected List<NPC> all(Predicate<? super NPC> filter)
	{
		List<NPC> out = new ArrayList<>();
		List<NPC> npcs = Static.getClient().getNpcs();
		for (NPC npc : npcs)
		{
			if (filter.test(npc))
			{
				out.add(npc);
			}
		}

		return out;
	}

	public static NPCQuery query()
	{
		return query(NPCs::getAll);
	}

	public static NPCQuery query(Supplier<List<NPC>> supplier)
	{
		return new NPCQuery(supplier);
	}

	public static List<NPC> getAll()
	{
		return getAll(x -> true);
	}

	public static List<NPC> getAll(Predicate<NPC> filter)
	{
		return NPCS.all(filter);
	}

	public static List<NPC> getAll(int... ids)
	{
		return NPCS.all(ids);
	}

	public static List<NPC> getAll(String... names)
	{
		return NPCS.all(names);
	}

	public static NPC getNearest(WorldPoint to, Predicate<NPC> filter)
	{
		return NPCS.nearest(to, filter);
	}

	public static NPC getNearest(WorldPoint to, int... ids)
	{
		return NPCS.nearest(to, ids);
	}

	public static NPC getNearest(WorldPoint to, String... names)
	{
		return NPCS.nearest(to, names);
	}

	public static NPC getNearest(Predicate<NPC> filter)
	{
		return getNearest(Players.getLocal().getWorldLocation(), filter);
	}

	public static NPC getNearest(int... ids)
	{
		return getNearest(Players.getLocal().getWorldLocation(), ids);
	}

	public static NPC getNearest(String... names)
	{
		return getNearest(Players.getLocal().getWorldLocation(), names);
	}
}

package net.unethicalite.api.commons;

public class NumericFormat
{
	private static final byte COMMAS = 0x1;
	private static final byte THOUSANDS = 0x40;

	private static final char[] POSTFIXES = new char[]{'K', 'M', 'B', 'T'};
	private static final char HYPHEN = '-';
	private static final char COMMA = ',';
	private static final char ZERO = '0';
	private static final char DOT = '.';

	public static int precision(int precision)
	{
		return precision << 2;
	}

	public static String apply(long value)
	{
		return apply(value, THOUSANDS | COMMAS | precision(2));
	}

	public static String apply(long value, int settings)
	{
		StringBuilder builder = new StringBuilder(32);
		builder.append(value);

		char[] buff = builder.toString().toCharArray();
		boolean commas = (settings & COMMAS) == COMMAS;
		int precision = 0;
		int postfix = 0;

		if (settings >= THOUSANDS)
		{
			postfix = settings >> 6;
			if (postfix > POSTFIXES.length)
			{
				postfix = POSTFIXES.length;
			}
		}

		if (settings > COMMAS)
		{
			precision = settings >> 2 & 0xF;
		}

		builder.setLength(0);

		int negative = 0;
		if (buff[0] == HYPHEN)
		{
			negative = 1;
		}

		int length = buff.length - negative;
		if (postfix * 3 >= length)
		{
			postfix = (int) (length * 0.334);
			if (postfix * 3 == length && precision == 0)
			{
				--postfix;
			}
		}

		int end = length - postfix * 3;
		int start = length % 3;
		if (start == 0)
		{
			start = 3;
		}

		start += negative;

		if (end > 0 && negative == 1)
		{
			builder.append(HYPHEN);
		}

		int max = end + negative;
		for (int i = negative; i < max; i++)
		{
			if (i == start && i + 2 < max && commas)
			{
				start += 3;
				builder.append(COMMA);
			}

			builder.append(buff[i]);
		}

		if (postfix > 0)
		{
			if (end == 0)
			{
				if (negative == 1 && precision > 0)
				{
					builder.append(HYPHEN);
				}

				builder.append(ZERO);
			}

			max = precision + end + negative;

			if (max > buff.length)
			{
				max = buff.length;
			}

			end += negative;

			while (max > end)
			{
				if (buff[max - 1] != ZERO)
				{
					break;
				}
				--max;
			}

			if (max - end != 0)
			{
				builder.append(DOT);
			}

			for (int i = end; i < max; i++)
			{
				builder.append(buff[i]);

			}

			builder.append(POSTFIXES[postfix - 1]);
		}

		return builder.toString();
	}
}

package net.unethicalite.api.packets;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.Point;
import net.runelite.api.TileObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.packets.PacketBufferNode;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

@Slf4j
public class ObjectPackets
{
	public static void tileObjectFirstOption(TileObject object, boolean ctrlDown)
	{
		Point p = object.menuPoint();
		LocalPoint lp = new LocalPoint(p.getX(), p.getY());
		WorldPoint wp = WorldPoint.fromScene(Static.getClient(), lp.getX(), lp.getY(), object.getPlane());
		queueTileObjectAction1Packet(object.getId(), wp.getX(), wp.getY(), ctrlDown);
	}

	public static void tileObjectSecondOption(TileObject object, boolean ctrlDown)
	{
		Point p = object.menuPoint();
		LocalPoint lp = new LocalPoint(p.getX(), p.getY());
		WorldPoint wp = WorldPoint.fromScene(Static.getClient(), lp.getX(), lp.getY(), object.getPlane());
		queueTileObjectAction2Packet(object.getId(), wp.getX(), wp.getY(), ctrlDown);
	}

	public static void tileObjectThirdOption(TileObject object, boolean ctrlDown)
	{
		Point p = object.menuPoint();
		LocalPoint lp = new LocalPoint(p.getX(), p.getY());
		WorldPoint wp = WorldPoint.fromScene(Static.getClient(), lp.getX(), lp.getY(), object.getPlane());
		queueTileObjectAction3Packet(object.getId(), wp.getX(), wp.getY(), ctrlDown);
	}

	public static void tileObjectFourthOption(TileObject object, boolean ctrlDown)
	{
		Point p = object.menuPoint();
		LocalPoint lp = new LocalPoint(p.getX(), p.getY());
		WorldPoint wp = WorldPoint.fromScene(Static.getClient(), lp.getX(), lp.getY(), object.getPlane());
		queueTileObjectAction4Packet(object.getId(), wp.getX(), wp.getY(), ctrlDown);
	}

	public static void tileObjectFifthOption(TileObject object, boolean ctrlDown)
	{
		Point p = object.menuPoint();
		LocalPoint lp = new LocalPoint(p.getX(), p.getY());
		WorldPoint wp = WorldPoint.fromScene(Static.getClient(), lp.getX(), lp.getY(), object.getPlane());
		queueTileObjectAction5Packet(object.getId(), wp.getX(), wp.getY(), ctrlDown);
	}

	public static void tileObjectAction(TileObject object, String action, boolean ctrlDown)
	{
		int index = object.getActionIndex(action);
		switch (index)
		{
			case 0:
				tileObjectFirstOption(object, ctrlDown);
				break;
			case 1:
				tileObjectSecondOption(object, ctrlDown);
				break;
			case 2:
				tileObjectThirdOption(object, ctrlDown);
				break;
			case 3:
				tileObjectFourthOption(object, ctrlDown);
				break;
			case 4:
				tileObjectFifthOption(object, ctrlDown);
				break;
		}
	}

	public static void useItemOnTileObject(Item item, TileObject object)
	{
		Point p = object.menuPoint();
		LocalPoint lp = new LocalPoint(p.getX(), p.getY());
		WorldPoint wp = WorldPoint.fromScene(Static.getClient(), lp.getX(), lp.getY(), object.getPlane());
		queueItemUseOnTileObjectPacket(object.getId(), wp.getX(), wp.getY(), item.getSlot(), item.getId(), item.getWidgetId(), false);
	}

	public static void queueItemUseOnTileObjectPacket(int objectId, int worldPointX, int worldPointY, int itemSlot, int itemId, int itemWidgetId, boolean ctrlDown)
	{
		createItemOnObjectPacket(objectId, worldPointX, worldPointY, itemSlot, itemId, itemWidgetId, ctrlDown).send();
	}

	public static void queueSpellOnTileObjectPacket(int objectId, int worldPointX, int worldPointY, int spellWidgetId, boolean ctrlDown)
	{
		createSpellOnObjectPacket(objectId, worldPointX, worldPointY, spellWidgetId, ctrlDown).send();
	}

	public static void queueTileObjectAction1Packet(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createObjectFirstActionPacket(objectId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueTileObjectAction2Packet(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createObjectSecondActionPacket(objectId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueTileObjectAction3Packet(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createObjectThirdActionPacket(objectId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueTileObjectAction4Packet(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createObjectFourthActionPacket(objectId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static void queueTileObjectAction5Packet(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		createObjectFifthActionPacket(objectId, worldPointX, worldPointY, ctrlDown).send();
	}

	public static PacketBufferNode createItemOnObjectPacket(int objectId, int worldPointX, int worldPointY, int itemSlot, int itemId, int itemWidgetId, boolean ctrlDown)
	{
		return createWidgetOnObjectPacket(objectId, worldPointX, worldPointY, itemSlot, itemId, itemWidgetId, ctrlDown);
	}

	public static PacketBufferNode createWidgetOnObjectPacket(int objectId, int worldPointX, int worldPointY, int sourceSlot, int sourceItemId, int sourceWidgetId, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPLOCT(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortLE(objectId);
		packetBufferNode.getPacketBuffer().writeShortLE(sourceItemId);
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointX);
		packetBufferNode.getPacketBuffer().writeShortAddLE(sourceSlot);
		packetBufferNode.getPacketBuffer().writeIntIME(sourceWidgetId);
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointY);
		return packetBufferNode;
	}

	public static PacketBufferNode createSpellOnObjectPacket(int objectId, int worldPointX, int worldPointY, int spellWidgetId, boolean ctrlDown)
	{
		return createWidgetOnObjectPacket(objectId, worldPointX, worldPointY, -1, -1, spellWidgetId, ctrlDown);
	}

	public static PacketBufferNode createObjectFirstActionPacket(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPLOC1(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointX);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointY);
		packetBufferNode.getPacketBuffer().writeShortAdd(objectId);
		return packetBufferNode;
	}

	public static PacketBufferNode createObjectSecondActionPacket(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPLOC2(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointX);
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointY);
		packetBufferNode.getPacketBuffer().writeShortAddLE(objectId);
		packetBufferNode.getPacketBuffer().writeByteSub(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createObjectThirdActionPacket(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPLOC3(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointX);
		packetBufferNode.getPacketBuffer().writeShortLE(objectId);
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointY);
		packetBufferNode.getPacketBuffer().writeByteNeg(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createObjectFourthActionPacket(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPLOC4(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(objectId);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAdd(worldPointY);
		packetBufferNode.getPacketBuffer().writeShortLE(worldPointX);
		return packetBufferNode;
	}

	public static PacketBufferNode createObjectFifthActionPacket(int objectId, int worldPointX, int worldPointY, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPLOC5(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByteNeg(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortAddLE(objectId);
		packetBufferNode.getPacketBuffer().writeShortAdd(worldPointX);
		packetBufferNode.getPacketBuffer().writeShortAddLE(worldPointY);
		return packetBufferNode;
	}
}
package net.unethicalite.api.input.naturalmouse.api;

import net.unethicalite.api.input.naturalmouse.support.Flow;

import java.awt.Point;

/**
 * Overshoots provide a realistic way to simulate user trying to reach the destination with mouse, but miss.
 * Points around the destination are produced which will be hit before the mouse hits the real destination.
 * If overshoot happens to match the target, then overshooting is cancelled and real destination will be reached.
 */
public interface OvershootManager
{
	/**
	 * Get the maximum amount of overshoots the cursor does before reaching its final destination.
	 *
	 * @param flow            the flow which is planned to be used to reach the target.
	 *                        (If returned overshoots &gt; 0, then a new flow will be calculated for each overshoot.).
	 *                        This flow could be analyzed if overshooting is suitable. It is not available
	 *                        as a parameter in overshootAmount calculation, because flow itself is calculated
	 *                        from the movement distance, which is dependent on the overshoot amount.
	 * @param mouseMovementMs the planned time for reaching the real target
	 * @param distance        the distance between mouse position and real target
	 * @return the number of maximum overshoots used or 0 if no overshoots
	 */
	int getOvershoots(Flow flow, long mouseMovementMs, double distance);

	/**
	 * Returns the overshoot amount which will be added to real target, thus getting the overshoot target.
	 *
	 * @param distanceToRealTargetX distance to real target X-coordinate
	 * @param distanceToRealTargetY distance to real target Y-coordinate
	 * @param mouseMovementMs       the time planned for reaching the real target
	 * @param overshootsRemaining   the amount of overshoots remaining, current included.
	 *                              Values from (n to 1), where n &gt;= 1
	 * @return the amount which will be added to real target, thus getting the overshoot target.
	 */
	Point getOvershootAmount(double distanceToRealTargetX, double distanceToRealTargetY, long mouseMovementMs, int overshootsRemaining);

	/**
	 * Once the mouse reaches the overshoot target, new trajectory with new speed is calculated for next target
	 * (can be real or overshoot target, if the next target is real target, the overshootsRemaining value is 0)
	 *
	 * @param mouseMovementMs     the last mouse movement in ms
	 * @param overshootsRemaining the amount of overshoots remaining, including this.
	 *                            Values from (n to 0), where n &gt;= 0
	 * @return the next mouse movement time in ms
	 */
	long deriveNextMouseMovementTimeMs(long mouseMovementMs, int overshootsRemaining);
}

package net.unethicalite.api.packets;

import net.runelite.api.packets.ClientPacket;
import net.runelite.api.packets.PacketBufferNode;
import net.runelite.api.packets.PacketWriter;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.unethicalite.api.events.MenuAutomated;
import net.unethicalite.api.exception.InteractionException;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

public class Packets
{
	public static void queuePacket(ClientPacket clientPacket, Object... data)
	{
		PacketWriter writer = Static.getClient().getPacketWriter();
		PacketBufferNode packet = Static.getClient().preparePacket(clientPacket, writer.getIsaacCipher());
		for (Object o : data)
		{
			if (o instanceof Byte)
			{
				packet.getPacketBuffer().writeByte(((int) (o)));
				continue;
			}
			if (o instanceof Short)
			{
				packet.getPacketBuffer().writeShort(((int) (o)));
				continue;
			}
			if (o instanceof Integer)
			{
				packet.getPacketBuffer().writeInt(((int) (o)));
				continue;
			}
			if (o instanceof Long)
			{
				packet.getPacketBuffer().writeLong(((long) (o)));
				continue;
			}
			if (o instanceof String)
			{
				packet.getPacketBuffer().writeStringCp1252NullTerminated(((String) (o)));
				continue;
			}
			return;
		}
		packet.send();
		writer.queuePacket(packet);
	}

	public static void queuePacket(PacketBufferNode packet)
	{
		GameThread.invoke(() -> Static.getClient().getPacketWriter().queuePacket(packet));
	}

	public static PacketBufferNode fromAutomatedMenu(MenuAutomated menu)
	{
		var opcode = menu.getOpcode();
		var client = Static.getClient();
		var id = menu.getIdentifier();
		var param0 = menu.getParam0();
		var param1 = menu.getParam1();
		var selectedWidgetItemId = client.getSelectedSpellItemId();
		var selectedWidgetSlot = client.getSelectedSpellChildIndex();
		var selectedWidget = client.getSelectedSpellWidget();
		var selectedSpellWidget = client.getSelectedSpellWidget();
		switch (opcode)
		{
			case ITEM_USE_ON_GAME_OBJECT:
			case WIDGET_TARGET_ON_GAME_OBJECT:
				return ObjectPackets.createWidgetOnObjectPacket(id, param0 + client.getBaseX(), param1 + client.getBaseY(), selectedWidgetSlot, selectedWidgetItemId, selectedWidget, false);
			case GAME_OBJECT_FIRST_OPTION:
				return ObjectPackets.createObjectFirstActionPacket(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GAME_OBJECT_SECOND_OPTION:
				return ObjectPackets.createObjectSecondActionPacket(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GAME_OBJECT_THIRD_OPTION:
				return ObjectPackets.createObjectThirdActionPacket(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GAME_OBJECT_FOURTH_OPTION:
				return ObjectPackets.createObjectFourthActionPacket(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GAME_OBJECT_FIFTH_OPTION:
				return ObjectPackets.createObjectFifthActionPacket(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case ITEM_USE_ON_NPC:
			case WIDGET_TARGET_ON_NPC:
				return NPCPackets.createWidgetOnNpc(id, selectedWidget, selectedWidgetItemId, selectedWidgetSlot, false);
			case NPC_FIRST_OPTION:
				return NPCPackets.createNpcFirstActionPacket(id, false);
			case NPC_SECOND_OPTION:
				return NPCPackets.createNpcSecondActionPacket(id, false);
			case NPC_THIRD_OPTION:
				return NPCPackets.createNpcThirdActionPacket(id, false);
			case NPC_FOURTH_OPTION:
				return NPCPackets.createNpcFourthActionPacket(id, false);
			case NPC_FIFTH_OPTION:
				return NPCPackets.createNpcFifthActionPacket(id, false);
			case ITEM_USE_ON_PLAYER:
			case WIDGET_TARGET_ON_PLAYER:
				return PlayerPackets.createWidgetOnPlayer(id, selectedWidgetItemId, selectedWidgetSlot, selectedWidget, false);
			case PLAYER_FIRST_OPTION:
				return PlayerPackets.createFirstAction(id, false);
			case PLAYER_SECOND_OPTION:
				return PlayerPackets.createSecondAction(id, false);
			case PLAYER_THIRD_OPTION:
				return PlayerPackets.createThirdAction(id, false);
			case PLAYER_FOURTH_OPTION:
				return PlayerPackets.createFourthAction(id, false);
			case PLAYER_FIFTH_OPTION:
				return PlayerPackets.createFifthAction(id, false);
			case PLAYER_SIXTH_OPTION:
				return PlayerPackets.createSixthAction(id, false);
			case PLAYER_SEVENTH_OPTION:
				return PlayerPackets.createSeventhAction(id, false);
			case PLAYER_EIGHTH_OPTION:
				return PlayerPackets.createEighthAction(id, false);
			case ITEM_USE_ON_GROUND_ITEM:
			case WIDGET_TARGET_ON_GROUND_ITEM:
				return GroundItemPackets.createWidgetOnGroundItem(id, param0 + client.getBaseX(), param1 + client.getBaseY(), selectedWidgetSlot, selectedWidgetItemId, selectedWidget, false);
			case GROUND_ITEM_FIRST_OPTION:
				return GroundItemPackets.createFirstAction(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GROUND_ITEM_SECOND_OPTION:
				return GroundItemPackets.createSecondAction(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GROUND_ITEM_THIRD_OPTION:
				return GroundItemPackets.createThirdAction(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GROUND_ITEM_FOURTH_OPTION:
				return GroundItemPackets.createFourthAction(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case GROUND_ITEM_FIFTH_OPTION:
				return GroundItemPackets.createFifthAction(id, param0 + client.getBaseX(), param1 + client.getBaseY(), false);
			case ITEM_USE_ON_ITEM:
			case WIDGET_TARGET_ON_WIDGET:
				Widget targetParent = Widgets.fromId(param1);
				assert targetParent != null;
				Widget targetChild = targetParent.getChild(param0);
				int childItemId = -1;
				if (targetChild != null)
				{
					childItemId = targetChild.getItemId();
				}
				Widget source = client.getWidget(selectedWidget);
				assert source != null;
				if (source.getType() == WidgetType.GRAPHIC)
				{
					selectedWidgetSlot = -1;
					selectedWidgetItemId = -1;
				}
				return WidgetPackets.createWidgetOnWidget(selectedWidget, selectedWidgetSlot, selectedWidgetItemId, childItemId, param0, param1);
			case ITEM_FIRST_OPTION:
				return ItemPackets.createFirstAction(param1, id, param0);
			case ITEM_SECOND_OPTION:
				return ItemPackets.createSecondAction(param1, id, param0);
			case ITEM_THIRD_OPTION:
				return ItemPackets.createThirdAction(param1, id, param0);
			case ITEM_FOURTH_OPTION:
				return ItemPackets.createFourthAction(param1, id, param0);
			case ITEM_FIFTH_OPTION:
				return ItemPackets.createFifthAction(param1, id, param0);
			case WIDGET_FIRST_OPTION:
				return WidgetPackets.createFirstAction(param1, -1, param0);
			case WIDGET_SECOND_OPTION:
				return WidgetPackets.createSecondAction(param1, -1, param0);
			case WIDGET_THIRD_OPTION:
				return WidgetPackets.createThirdAction(param1, -1, param0);
			case WIDGET_FOURTH_OPTION:
				return WidgetPackets.createFourthAction(param1, -1, param0);
			case WIDGET_FIFTH_OPTION:
				return WidgetPackets.createFifthAction(param1, -1, param0);
			case WIDGET_TYPE_1:
				return WidgetPackets.createType1Action(param1);
			case WIDGET_CONTINUE:
				return WidgetPackets.createContinuePacket(param1, param0);
			case WALK:
				client.setDestinationX(param0);
				client.setDestinationY(param1);
				return MovementPackets.createMovement(param0 + client.getBaseX(), param1 + client.getBaseY(), false);
		}
		throw new InteractionException("Couldn't parse packet from opcode: " + opcode);
	}
}
package net.unethicalite.api.script.paint;

import net.runelite.client.config.ConfigManager;
import net.unethicalite.client.devtools.EntityRenderer;
import net.unethicalite.client.minimal.ui.MinimalUI;
import net.unethicalite.client.managers.InputManager;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.RenderableEntity;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class Paint extends Overlay
{
	private final List<RenderableEntity> overlays = new ArrayList<>();
	private boolean enabled = false;

	@Inject
	private EntityRenderer entityRenderer;

	@Inject
	private ConfigManager configManager;

	@Inject
	private InputManager inputManager;

	public final DefaultPaint tracker = new DefaultPaint();

	@Inject
	public Paint(OverlayManager overlayManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.LOW);

		overlayManager.add(this);
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		Font font = g.getFont();

		if (MinimalUI.getFrame() != null)
		{
			if (configManager.getConfiguration("entityinspector", "drawMouse", Boolean.class))
			{
				g.setFont(new Font("Tahoma", Font.BOLD, 18));
				OverlayUtil.renderTextLocation(g, new Point(inputManager.getLastClickX() - (g.getFont().getSize() / 3),
						inputManager.getLastClickY() + (g.getFont().getSize() / 3)), "X", Color.WHITE);
				OverlayUtil.renderTextLocation(g, new Point(inputManager.getLastMoveX() - (g.getFont().getSize() / 3),
						inputManager.getLastMoveY() + (g.getFont().getSize() / 3)), "X", Color.GREEN);
			}

			g.setColor(Color.WHITE);
			g.setFont(font);

			entityRenderer.render(g);
		}

		if (!enabled)
		{
			return null;
		}

		for (RenderableEntity renderableEntity : overlays)
		{
			renderableEntity.render(g);
		}

		return null;
	}

	public void submit(RenderableEntity p)
	{
		overlays.add(p);
	}

	public void clear()
	{
		overlays.clear();
		tracker.clear();
	}

	public void setEnabled(boolean enabled)
	{
		this.enabled = enabled;

		if (enabled)
		{
			submit(tracker.getTracker());
		}
	}
}

package net.unethicalite.api.script.paint;

import net.runelite.client.config.ConfigManager;
import net.unethicalite.client.devtools.EntityRenderer;
import net.unethicalite.client.minimal.ui.MinimalUI;
import net.unethicalite.client.managers.InputManager;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.RenderableEntity;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class Paint extends Overlay
{
	private final List<RenderableEntity> overlays = new ArrayList<>();
	private boolean enabled = false;

	@Inject
	private EntityRenderer entityRenderer;

	@Inject
	private ConfigManager configManager;

	@Inject
	private InputManager inputManager;

	public final DefaultPaint tracker = new DefaultPaint();

	@Inject
	public Paint(OverlayManager overlayManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.LOW);

		overlayManager.add(this);
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		Font font = g.getFont();

		if (MinimalUI.getFrame() != null)
		{
			if (configManager.getConfiguration("entityinspector", "drawMouse", Boolean.class))
			{
				g.setFont(new Font("Tahoma", Font.BOLD, 18));
				OverlayUtil.renderTextLocation(g, new Point(inputManager.getLastClickX() - (g.getFont().getSize() / 3),
						inputManager.getLastClickY() + (g.getFont().getSize() / 3)), "X", Color.WHITE);
				OverlayUtil.renderTextLocation(g, new Point(inputManager.getLastMoveX() - (g.getFont().getSize() / 3),
						inputManager.getLastMoveY() + (g.getFont().getSize() / 3)), "X", Color.GREEN);
			}

			g.setColor(Color.WHITE);
			g.setFont(font);

			entityRenderer.render(g);
		}

		if (!enabled)
		{
			return null;
		}

		for (RenderableEntity renderableEntity : overlays)
		{
			renderableEntity.render(g);
		}

		return null;
	}

	public void submit(RenderableEntity p)
	{
		overlays.add(p);
	}

	public void clear()
	{
		overlays.clear();
		tracker.clear();
	}

	public void setEnabled(boolean enabled)
	{
		this.enabled = enabled;

		if (enabled)
		{
			submit(tracker.getTracker());
		}
	}
}

package net.unethicalite.api.input.naturalmouse.util;

public class Pair<X, Y>
{
	public final X x;
	public final Y y;

	public Pair(X x, Y y)
	{
		this.x = x;
		this.y = y;
	}
}

package net.unethicalite.api.movement.pathfinder;

import lombok.Data;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.api.movement.pathfinder.model.Transport;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.stream.Collectors;

import static net.unethicalite.api.movement.pathfinder.model.MovementConstants.WILDERNESS_ABOVE_GROUND;
import static net.unethicalite.api.movement.pathfinder.model.MovementConstants.WILDERNESS_UNDERGROUND;

@Data
@Slf4j
public class Pathfinder implements Callable<List<WorldPoint>>
{
	final CollisionMap map;
	final Map<WorldPoint, List<Transport>> transports;
	private List<Node> start;
	private WorldArea target;
	private List<WorldPoint> targetTiles;
	private final List<Node> boundary = new LinkedList<>();
	private final Set<WorldPoint> visited = new HashSet<>();
	private Node nearest;
	boolean avoidWilderness;

	private static boolean isInWilderness(WorldPoint location)
	{
		return location.isInArea2D(WILDERNESS_ABOVE_GROUND, WILDERNESS_UNDERGROUND);
	}

	public Pathfinder(CollisionMap collisionMap, Map<WorldPoint, List<Transport>> transports, List<WorldPoint> start, WorldPoint target, boolean avoidWilderness)
	{
		this(collisionMap, transports, start, target.toWorldArea(), avoidWilderness);
	}

	public Pathfinder(CollisionMap collisionMap, Map<WorldPoint, List<Transport>> transports, List<WorldPoint> start, WorldArea target, boolean avoidWilderness)
	{
		this.map = collisionMap;
		this.transports = transports;
		this.target = target;
		this.targetTiles = target.toWorldPointList();
		this.start = new ArrayList<>();
		this.start.addAll(start.stream().map(point -> new Node(point, null)).collect(Collectors.toList()));
		this.nearest = null;
		this.avoidWilderness = avoidWilderness;
		if (targetTiles.stream().allMatch(collisionMap::fullBlock))
		{
			log.warn("Walking to a {}, pathfinder will be slow", targetTiles.size() == 1 ? "blocked tile" : "fully blocked area");
		}
	}

	private void addNeighbors(Node node)
	{
		int x = node.position.getX();
		int y = node.position.getY();
		int plane = node.position.getPlane();

		if (map.w(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x - 1, y, plane));
		}

		if (map.e(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x + 1, y, plane));
		}

		if (map.s(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x, y - 1, plane));
		}

		if (map.n(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x, y + 1, plane));
		}

		if (map.sw(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x - 1, y - 1, plane));
		}

		if (map.se(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x + 1, y - 1, plane));
		}

		if (map.nw(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x - 1, y + 1, plane));
		}

		if (map.ne(x, y, plane))
		{
			addNeighbor(node, new WorldPoint(x + 1, y + 1, plane));
		}

		for (Transport transport : transports.getOrDefault(node.position, new ArrayList<>()))
		{
			addNeighbor(node, transport.getDestination());
		}
	}

	private void addNeighbor(Node node, WorldPoint neighbor)
	{
		if (avoidWilderness && isInWilderness(neighbor) && !isInWilderness(node.position) && targetTiles.stream().noneMatch(Pathfinder::isInWilderness))
		{
			return;
		}

		if (!visited.add(neighbor))
		{
			return;
		}

		boundary.add(new Node(neighbor, node));
	}

	public List<WorldPoint> find()
	{
		long startTime = System.currentTimeMillis();
		List<WorldPoint> path = find(5_000_000);
		String targetStr = targetTiles.size() == 1 ? target.toWorldPoint().toString() :
			String.format("WorldArea(x=%s, y=%s, width=%s, height=%s, plane=%s)",
				target.getX(), target.getY(), target.getWidth(), target.getHeight(), target.getPlane());
		log.debug("Path calculation took {} ms to {}", System.currentTimeMillis() - startTime, targetStr);
		return path;
	}

	public List<WorldPoint> find(int maxSearch)
	{
		boundary.addAll(start);

		int bestDistance = Integer.MAX_VALUE;

		while (!boundary.isEmpty())
		{
			if (Thread.interrupted())
			{
				return List.of();
			}

			if (visited.size() >= maxSearch)
			{
				return nearest.path();
			}

			Node node = boundary.remove(0);

			if (target.contains(node.position))
			{
				return node.path();
			}

			int distance = target.distanceTo(node.position);
			if (nearest == null || distance < bestDistance)
			{
				nearest = node;
				bestDistance = distance;
			}

			addNeighbors(node);
		}

		if (nearest != null)
		{
			return nearest.path();
		}
		return List.of();
	}

	@Override
	public List<WorldPoint> call() throws Exception
	{
		return find();
	}

	@Value
	private static class Node
	{
		WorldPoint position;
		Node previous;


		public List<WorldPoint> path()
		{
			List<WorldPoint> path = new LinkedList<>();
			Node node = this;

			while (node != null)
			{
				path.add(0, node.position);
				node = node.previous;
			}

			return new ArrayList<>(path);
		}
	}
}

package net.unethicalite.api.packets;

import net.runelite.api.packets.PacketBufferNode;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

public class PlayerPackets
{
	public static void queueItemUseOnPlayerPacket(int playerIndex, int itemId, int itemSlot, int itemWidgetId, boolean ctrlDown)
	{
		createItemOnPlayerPacket(playerIndex, itemId, itemSlot, itemWidgetId, ctrlDown).send();
	}

	public static void queueSpellOnPlayerPacket(int playerIndex, int spellWidgetId, boolean ctrlDown)
	{
		createSpellOnPlayer(playerIndex, spellWidgetId, ctrlDown).send();
	}

	public static void queuePlayerAction1Packet(int playerIndex, boolean ctrlDown)
	{
		createFirstAction(playerIndex, ctrlDown).send();
	}

	public static void queuePlayerAction2Packet(int playerIndex, boolean ctrlDown)
	{
		createSecondAction(playerIndex, ctrlDown).send();
	}

	public static void queuePlayerAction3Packet(int playerIndex, boolean ctrlDown)
	{
		createThirdAction(playerIndex, ctrlDown).send();
	}

	public static void queuePlayerAction4Packet(int playerIndex, boolean ctrlDown)
	{
		createFourthAction(playerIndex, ctrlDown).send();
	}

	public static void queuePlayerAction5Packet(int playerIndex, boolean ctrlDown)
	{
		createFifthAction(playerIndex, ctrlDown).send();
	}

	public static void queuePlayerAction6Packet(int playerIndex, boolean ctrlDown)
	{
		createSixthAction(playerIndex, ctrlDown).send();
	}

	public static void queuePlayerAction7Packet(int playerIndex, boolean ctrlDown)
	{
		createSeventhAction(playerIndex, ctrlDown).send();
	}

	public static void queuePlayerAction8Packet(int playerIndex, boolean ctrlDown)
	{
		createEighthAction(playerIndex, ctrlDown).send();
	}

	public static PacketBufferNode createItemOnPlayerPacket(int playerIndex, int itemId, int itemSlot, int itemWidgetId, boolean ctrlDown)
	{
		return createWidgetOnPlayer(playerIndex, itemId, itemSlot, itemWidgetId, ctrlDown);
	}

	public static PacketBufferNode createWidgetOnPlayer(int playerIndex, int sourceItemId, int sourceSlot, int sourceWidgetId, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYERT(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAddLE(sourceSlot);
		packetBufferNode.getPacketBuffer().writeShortAdd(sourceItemId);
		packetBufferNode.getPacketBuffer().writeShortLE(playerIndex);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeInt(sourceWidgetId);
		return packetBufferNode;
	}

	public static PacketBufferNode createSpellOnPlayer(int playerIndex, int spellWidgetId, boolean ctrlDown)
	{
		return createWidgetOnPlayer(playerIndex, -1, -1, spellWidgetId, ctrlDown);
	}

	public static PacketBufferNode createFirstAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER1(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByteSub(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShort(playerIndex);
		return packetBufferNode;
	}

	public static PacketBufferNode createSecondAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER2(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortLE(playerIndex);
		return packetBufferNode;
	}

	public static PacketBufferNode createThirdAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER3(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortLE(playerIndex);
		packetBufferNode.getPacketBuffer().writeByteSub(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createFourthAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER4(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByteNeg(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShortLE(playerIndex);
		return packetBufferNode;
	}

	public static PacketBufferNode createFifthAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER5(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeByteNeg(ctrlDown ? 1 : 0);
		packetBufferNode.getPacketBuffer().writeShort(playerIndex);
		return packetBufferNode;
	}

	public static PacketBufferNode createSixthAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER6(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(playerIndex);
		packetBufferNode.getPacketBuffer().writeByteNeg(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createSeventhAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER7(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAddLE(playerIndex);
		packetBufferNode.getPacketBuffer().writeByteAdd(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}

	public static PacketBufferNode createEighthAction(int playerIndex, boolean ctrlDown)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.OPPLAYER8(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortAdd(playerIndex);
		packetBufferNode.getPacketBuffer().writeByteNeg(ctrlDown ? 1 : 0);
		return packetBufferNode;
	}
}
package net.unethicalite.api.query.entities;

import net.unethicalite.api.query.results.SceneEntityQueryResults;
import net.runelite.api.Player;
import org.apache.commons.lang3.ArrayUtils;

import java.util.List;
import java.util.function.Supplier;

public class PlayerQuery extends ActorQuery<Player, PlayerQuery>
{
	private int[] pids = null;

	public PlayerQuery(Supplier<List<Player>> supplier)
	{
		super(supplier);
	}

	public PlayerQuery playerIds(int... pids)
	{
		this.pids = pids;
		return this;
	}

	@Override
	protected SceneEntityQueryResults<Player> results(List<Player> list)
	{
		return new SceneEntityQueryResults<>(list);
	}

	@Override
	public boolean test(Player player)
	{
		if (pids != null && !ArrayUtils.contains(pids, player.getIndex()))
		{
			return false;
		}

		return super.test(player);
	}
}

package net.unethicalite.api.entities;

import net.unethicalite.api.query.entities.PlayerQuery;
import net.unethicalite.client.Static;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;

import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public class Players extends Entities<Player>
{
	private Players()
	{
	}

	private static final Players PLAYERS = new Players();

	@Override
	protected List<Player> all(Predicate<? super Player> filter)
	{
		return Static.getClient().getPlayers()
				.stream()
				.filter(filter)
				.collect(Collectors.toList());
	}

	public static PlayerQuery query()
	{
		return query(Players::getAll);
	}

	public static PlayerQuery query(Supplier<List<Player>> supplier)
	{
		return new PlayerQuery(supplier);
	}

	public static List<Player> getAll()
	{
		return getAll(player -> true);
	}

	public static List<Player> getAll(Predicate<Player> filter)
	{
		return PLAYERS.all(filter);
	}

	public static List<Player> getAll(String... names)
	{
		return PLAYERS.all(names);
	}

	public static Player getNearest(Predicate<Player> filter)
	{
		return getNearest(getLocal().getWorldLocation(), filter);
	}

	public static Player getNearest(String... names)
	{
		return getNearest(getLocal().getWorldLocation(), names);
	}

	public static Player getNearest(WorldPoint to, Predicate<Player> filter)
	{
		return PLAYERS.nearest(to, filter);
	}

	public static Player getNearest(WorldPoint to, String... names)
	{
		return PLAYERS.nearest(to, names);
	}

	public static Player getHintArrowed()
	{
		return Static.getClient().getHintArrowPlayer();
	}

	public static Player getLocal()
	{
		Player local = Static.getClient().getLocalPlayer();
		if (local == null)
		{
			throw new IllegalStateException("Local player was null, are you logged in?");
		}

		return local;
	}
}

package net.unethicalite.api.plugins;

import net.unethicalite.client.Static;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;

import javax.inject.Singleton;
import javax.swing.SwingUtilities;

@Singleton
@Slf4j
public class Plugins
{
	public static PluginManager getPluginManager()
	{
		return Static.getPluginManager();
	}

	public static boolean isEnabled(Plugin plugin)
	{
		return getPluginManager().isPluginEnabled(plugin);
	}

	public static boolean isEnabled(String configGroup)
	{
		return Static.getConfigManager().getConfiguration(RuneLiteConfig.GROUP_NAME, configGroup, Boolean.class);
	}

	public static boolean stopPlugin(Plugin plugin)
	{
		try
		{
			assert SwingUtilities.isEventDispatchThread();
			getPluginManager().remove(plugin);
			getPluginManager().setPluginEnabled(plugin, false);
			return getPluginManager().stopPlugin(plugin);
		}
		catch (PluginInstantiationException e)
		{
			log.error("Failed to stop plugin {}, error: {}", plugin.getClass().getSimpleName(), e);
			return false;
		}
	}

	public static boolean startPlugin(Plugin plugin)
	{
		try
		{
			getPluginManager().setPluginEnabled(plugin, true);
			return getPluginManager().startPlugin(plugin);
		}
		catch (PluginInstantiationException e)
		{
			log.error("Failed to start plugin {}, error: {}", plugin.getClass().getSimpleName(), e);
			return false;
		}
	}
}

package net.unethicalite.api.plugins;

public class PluginStoppedException extends RuntimeException
{
}

package net.unethicalite.api.coords;

import net.unethicalite.api.commons.Rand;
import net.runelite.api.coords.WorldPoint;

import java.awt.Polygon;
import java.awt.Rectangle;

public class PolygonalArea implements Area
{
	private final Polygon polygon;
	private final int plane;

	public PolygonalArea(int plane, WorldPoint... points)
	{
		this.plane = plane;
		this.polygon = new Polygon();

		for (WorldPoint point : points)
		{
			polygon.addPoint(point.getX(), point.getY());
		}
	}

	@Override
	public boolean contains(WorldPoint worldPoint)
	{
		if (worldPoint.getPlane() == -1 || worldPoint.getPlane() != plane)
		{
			return false;
		}

		return polygon.contains(worldPoint.getX(), worldPoint.getY());
	}

	@Override
	public WorldPoint getRandomTile()
	{
		int x, y;
		Rectangle r = polygon.getBounds();
		do
		{
			x = Rand.nextInt(r.x, r.x + r.width);
			y = Rand.nextInt(r.y, r.y + r.height);
		} while (!polygon.contains(x, y));
		return new WorldPoint(x, y, plane);
	}
}

package net.unethicalite.api.movement.pathfinder.model.poh;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
@AllArgsConstructor
public enum PortalNexus
{
    ARCEUUS_LIBRARY(new WorldPoint(1634, 3836, 0)),
    DRAYNOR_MANOR(new WorldPoint(3109, 3352, 0)),
    BATTLEFRONT(new WorldPoint(1350, 3740, 0)),
    VARROCK(new WorldPoint(3212, 3424, 0)),
    MIND_ALTAR(new WorldPoint(2978, 3508, 0)),
    LUMBRIDGE(new WorldPoint(3225, 3219, 0)),
    FALADOR(new WorldPoint(2966, 3379, 0)),
    SALVE_GRAVEYARD(new WorldPoint(3431, 3460, 0)),
    CAMELOT(new WorldPoint(2757, 3479, 0)),
    FENKENSTRAINS_CASTLE(new WorldPoint(3546, 3528, 0)),
    EAST_ARDOUGNE(new WorldPoint(2661, 3300, 0)),
    WATCHTOWER(new WorldPoint(2931, 4717, 2)),
    SENNTISTEN(new WorldPoint(3321, 3335, 0)),
    WEST_ARDOUGNE(new WorldPoint(2502, 3291, 0)),
    MARIM(new WorldPoint(2796, 2791, 0)),
    HARMONY_ISLAND(new WorldPoint(3799, 2867, 0)),
    KHARYRLL(new WorldPoint(3493, 3474, 0)),
    LUNAR_ISLE(new WorldPoint(2113, 3917, 0)),
    KOUREND(new WorldPoint(1643, 3673, 0)),
    CEMETERY(new WorldPoint(2978, 3763, 0)),
    WATERBIRTH_ISLAND(new WorldPoint(2548, 3758, 0)),
    BARROWS(new WorldPoint(3563, 3313, 0)),
    CARRALLANGAR(new WorldPoint(3157, 3667, 0)),
    FISHING_GUILD(new WorldPoint(2610, 3389, 0)),
    CATHERBY(new WorldPoint(2802, 3449, 0)),
    ANNAKARL(new WorldPoint(3288, 3888, 0)),
    APE_ATOLL_DUNGEON(new WorldPoint(2769, 9100, 0)),
    GHORROCK(new WorldPoint(2977, 3872, 0)),
    TROLL_STRONGHOLD(new WorldPoint(2844, 3693, 0)),
    WEISS(new WorldPoint(2846, 3940, 0)),
    ;

    private final WorldPoint destination;
}

package net.unethicalite.api.widgets;

import net.unethicalite.api.game.Skills;
import net.unethicalite.api.game.Vars;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;

import java.util.Arrays;

public class Prayers
{
	public static boolean isEnabled(Prayer prayer)
	{
		return Vars.getBit(prayer.getVarbit()) == 1;
	}

	public static void toggle(Prayer prayer)
	{
		Widget widget = Widgets.get(prayer.getWidgetInfo());
		if (widget != null)
		{
			widget.interact(0);
		}
	}

	public static int getPoints()
	{
		return Skills.getBoostedLevel(Skill.PRAYER);
	}

	public static void toggleQuickPrayer(boolean enabled)
	{
		Widget widget = Widgets.get(WidgetInfo.MINIMAP_QUICK_PRAYER_ORB);
		if (widget != null)
		{
			widget.interact(enabled ? "Activate" : "Deactivate");
		}
	}

	public static boolean isQuickPrayerEnabled()
	{
		return Vars.getBit(Varbits.QUICK_PRAYER) == 1;
	}

	public static boolean anyActive()
	{
		return Arrays.stream(Prayer.values()).anyMatch(Prayers::isEnabled);
	}

	public static void disableAll()
	{
		Arrays.stream(Prayer.values()).filter(Prayers::isEnabled).forEach(Prayers::toggle);
	}

}

package net.unethicalite.api.game;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import net.unethicalite.client.Static;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.concurrent.ExecutionException;

public class Prices
{
	private static final Logger logger = LoggerFactory.getLogger(Prices.class);

	private static final LoadingCache<Integer, Integer> CACHE = CacheBuilder.newBuilder()
			.expireAfterWrite(Duration.ofMinutes(5))
			.build(new CacheLoader<>()
			{
				@Override
				public Integer load(@NotNull Integer itemId)
				{
					logger.debug("Caching item {} price", itemId);
					return GameThread.invokeLater(() -> Static.getItemManager().getItemPrice(itemId));
				}
			});

	public static int getItemPrice(int id)
	{
		try
		{
			return CACHE.get(id);
		}
		catch (ExecutionException e)
		{
			return -1;
		}
	}
}

package net.unethicalite.api.widgets;

import net.unethicalite.api.input.Keyboard;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;

import java.util.function.Supplier;

public class Production
{
	private static final Supplier<Widget> OPTIONS = () -> Widgets.get(WidgetID.MULTISKILL_MENU_GROUP_ID, 13);
	private static final Supplier<Widget> OTHER_QUANTITY = () -> Widgets.get(WidgetID.MULTISKILL_MENU_GROUP_ID, 11);

	public static boolean isOpen()
	{
		return Widgets.isVisible(Widgets.get(WidgetInfo.MULTI_SKILL_MENU));
	}

	public static void chooseOption(String option)
	{
		if (!isOpen())
		{
			return;
		}

		Widget optionsWidget = OPTIONS.get();
		if (!Widgets.isVisible(optionsWidget))
		{
			return;
		}

		int options = optionsWidget.getChildren() != null ? optionsWidget.getChildren().length : 1;
		for (int i = 0; i < options; i++)
		{
			Widget currentOption = Widgets.get(WidgetID.MULTISKILL_MENU_GROUP_ID, 14 + i);
			if (currentOption != null && currentOption.getName().toLowerCase().contains(option.toLowerCase()))
			{
				chooseOption(i + 1);
				return;
			}
		}
	}

	public static void selectOtherQuantity()
	{
		Widget otherQuantity = OTHER_QUANTITY.get();
		if (Widgets.isVisible(otherQuantity))
		{
			otherQuantity.interact(0);
		}
	}

	public static void chooseOption(int index)
	{
		if (isOpen())
		{
			Keyboard.type(index);
		}
	}

	public static void choosePreviousOption()
	{
		if (isOpen())
		{
			Keyboard.sendSpace();
		}
	}

	public static boolean isEnterInputOpen()
	{
		return Dialog.isEnterInputOpen();
	}

	public static void enterAmount(int amount)
	{
		Dialog.enterAmount(amount);
	}

	public static void enterName(String input)
	{
		Dialog.enterName(input);
	}
}

package net.unethicalite.api.entities;

import net.unethicalite.api.commons.Predicates;
import net.unethicalite.client.Static;
import net.runelite.api.Actor;
import net.runelite.api.Projectile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.function.Predicate;

public class Projectiles
{
	private Projectiles()
	{
	}

	public static List<Projectile> getAll(Predicate<Projectile> filter)
	{
		List<Projectile> out = new ArrayList<>();
		Static.getClient().getProjectiles().forEach(p ->
		{
			if (filter.test(p))
			{
				out.add(p);
			}
		});

		return out;
	}

	public static List<Projectile> getAll(int... ids)
	{
		return getAll(Predicates.ids(ids));
	}

	public static Projectile getNearest(Predicate<Projectile> filter)
	{
		return getAll(filter).stream()
				.min(Comparator.comparingInt(p ->
						WorldPoint.fromLocal(Static.getClient(), (int) p.getX(), (int) p.getY(), Static.getClient().getPlane())
								.distanceTo(Players.getLocal().getWorldLocation()))
				)
				.orElse(null);
	}

	public static Projectile getNearest(int... ids)
	{
		return getNearest(Predicates.ids(ids));
	}

	public static Projectile getNearest(Actor target)
	{
		return getNearest(x -> x.getInteracting() != null && x.getInteracting().equals(target));
	}

	public static Projectile getNearest(WorldPoint startPoint)
	{
		LocalPoint localPoint = LocalPoint.fromWorld(Static.getClient(), startPoint);
		if (localPoint == null)
		{
			return null;
		}

		return getNearest(x -> x.getX1() == localPoint.getX() && x.getY1() == localPoint.getY());
	}
}

package net.unethicalite.api.query;

import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public abstract class Query<T, Q, R> implements Predicate<T>
{
	protected final Supplier<List<T>> supplier;

	private Predicate<T> customFilter = null;

	protected Query(Supplier<List<T>> supplier)
	{
		this.supplier = supplier;
	}

	public R results()
	{
		return results(supplier.get().stream().filter(this).collect(Collectors.toList()));
	}

	public Q filter(Predicate<T> filter)
	{
		if (customFilter != null)
		{
			Predicate<? super T> old = customFilter;
			customFilter = t -> old.test(t) && filter.test(t);
		}
		else
		{
			customFilter = filter;
		}

		return (Q) this;
	}

	@Override
	public boolean test(T t)
	{
		return customFilter == null || customFilter.test(t);
	}

	protected abstract R results(List<T> list);
}

package net.unethicalite.api.query.results;

import net.unethicalite.api.commons.Rand;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;

public abstract class QueryResults<T, R> implements Collection<T>
{
	protected final List<T> results;

	public QueryResults(List<T> results)
	{
		this.results = results;
	}

	public T get(int index)
	{
		return results.get(index);
	}

	public boolean isEmpty()
	{
		return size() == 0;
	}

	public final R sorted(Comparator<? super T> comparator)
	{
		results.sort(comparator);
		return (R) this;
	}

	public int lastIndexOf(T o)
	{
		return results.lastIndexOf(o);
	}

	public boolean addAll(Collection<? extends T> c)
	{
		return results.addAll(c);
	}

	public final R limit(int startIndex, int amount)
	{
		List<T> limit = new ArrayList<>(amount);

		for (int i = startIndex; i < size() && i - startIndex < amount; i++)
		{
			limit.add(get(i));
		}

		results.retainAll(limit);
		return (R) this;
	}

	public List<T> list()
	{
		return results;
	}

	public void clear()
	{
		results.clear();
	}

	public int size()
	{
		return results.size();
	}

	public boolean removeAll(Collection<?> c)
	{
		return results.removeAll(c);
	}

	public boolean remove(Object o)
	{
		return results.remove(o);
	}

	public boolean add(T t)
	{
		return results.add(t);
	}

	public final R reversed()
	{
		Collections.reverse(results);
		return (R) this;
	}

	public T first()
	{
		return this.size() == 0 ? null : this.get(0);
	}

	public int indexOf(T o)
	{
		return results.indexOf(o);
	}

	public final boolean accept(Consumer<T> consumer, Function<R, T> target)
	{
		T value = target.apply((R) this);
		if (value != null)
		{
			consumer.accept(value);
			return true;
		}

		return false;
	}

	public final T random()
	{
		int index = size() - 1;
		return index != -1 ? get(Rand.nextInt(0, index)) : null;
	}

	public boolean contains(Object o)
	{
		return results.contains(o);
	}

	public final R shuffled()
	{
		Collections.shuffle(results);
		return (R) this;
	}

	public boolean containsAll(Collection<?> c)
	{
		return new HashSet<>(results).containsAll(c);
	}

	public Iterator<T> iterator()
	{
		return results.iterator();
	}

	public final R limit(int entries)
	{
		return limit(0, entries);
	}

	public final T last()
	{
		int index = size() - 1;
		return index != -1 ? get(index) : null;
	}

	@Deprecated
	public Object[] toArray()
	{
		return results.toArray();
	}

	public T[] toArray(Object[] o)
	{
		return (T[]) results.toArray(o);
	}

	public boolean retainAll(Collection<?> c)
	{
		return results.retainAll(c);
	}
}

package net.unethicalite.api.quests;

import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.game.Vars;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.QuestState;
import net.runelite.api.ScriptID;
import net.unethicalite.client.Static;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Deprecated
public enum Quest
{
	//Free Quests
	BELOW_ICE_MOUNTAIN(2874, "Below Ice Mountain", QuestVarbits.QUEST_BELOW_ICE_MOUNTAIN, Type.F2P, Difficulty.NOVICE),
	BLACK_KNIGHTS_FORTRESS(299, "Black Knights' Fortress", QuestVarPlayer.QUEST_BLACK_KNIGHTS_FORTRESS, Type.F2P, Difficulty.NOVICE),
	COOKS_ASSISTANT(300, "Cook's Assistant", QuestVarPlayer.QUEST_COOKS_ASSISTANT, Type.F2P, Difficulty.NOVICE),
	THE_CORSAIR_CURSE(301, "The Corsair Curse", QuestVarbits.QUEST_THE_CORSAIR_CURSE, Type.F2P, Difficulty.NOVICE),
	DEMON_SLAYER(302, "Demon Slayer", QuestVarbits.QUEST_DEMON_SLAYER, Type.F2P, Difficulty.NOVICE),
	DORICS_QUEST(3138, "Doric's Quest", QuestVarPlayer.QUEST_DORICS_QUEST, Type.F2P, Difficulty.NOVICE),
	DRAGON_SLAYER_I(3139, "Dragon Slayer I", QuestVarPlayer.QUEST_DRAGON_SLAYER_I, Type.F2P, Difficulty.EXPERIENCED),
	ERNEST_THE_CHICKEN(305, "Ernest the Chicken", QuestVarPlayer.QUEST_ERNEST_THE_CHICKEN, Type.F2P, Difficulty.NOVICE),
	GOBLIN_DIPLOMACY(306, "Goblin Diplomacy", QuestVarbits.QUEST_GOBLIN_DIPLOMACY, Type.F2P, Difficulty.NOVICE),
	IMP_CATCHER(307, "Imp Catcher", QuestVarPlayer.QUEST_IMP_CATCHER, Type.F2P, Difficulty.NOVICE),
	THE_KNIGHTS_SWORD(308, "The Knight's Sword", QuestVarPlayer.QUEST_THE_KNIGHTS_SWORD, Type.F2P, Difficulty.INTERMEDIATE),
	MISTHALIN_MYSTERY(309, "Misthalin Mystery", QuestVarbits.QUEST_MISTHALIN_MYSTERY, Type.F2P, Difficulty.NOVICE),
	PIRATES_TREASURE(310, "Pirate's Treasure", QuestVarPlayer.QUEST_PIRATES_TREASURE, Type.F2P, Difficulty.NOVICE),
	PRINCE_ALI_RESCUE(311, "Prince Ali Rescue", QuestVarPlayer.QUEST_PRINCE_ALI_RESCUE, Type.F2P, Difficulty.INTERMEDIATE),
	THE_RESTLESS_GHOST(312, "The Restless Ghost", QuestVarPlayer.QUEST_THE_RESTLESS_GHOST, Type.F2P, Difficulty.NOVICE),
	ROMEO__JULIET(313, "Romeo & Juliet", QuestVarPlayer.QUEST_ROMEO_AND_JULIET, Type.F2P, Difficulty.NOVICE),
	RUNE_MYSTERIES(314, "Rune Mysteries", QuestVarPlayer.QUEST_RUNE_MYSTERIES, Type.F2P, Difficulty.NOVICE),
	SHEEP_SHEARER(315, "Sheep Shearer", QuestVarPlayer.QUEST_SHEEP_SHEARER, Type.F2P, Difficulty.NOVICE),
	SHIELD_OF_ARRAV_PHOENIX_GANG(316, "Shield of Arrav - Phoenix Gang", QuestVarPlayer.QUEST_SHIELD_OF_ARRAV, Type.F2P, Difficulty.NOVICE),
	SHIELD_OF_ARRAV_BLACK_ARM_GANG(316, "Shield of Arrav - Black Arm Gang", QuestVarPlayer.QUEST_SHIELD_OF_ARRAV_STATE_146, Type.F2P, Difficulty.NOVICE),
	VAMPYRE_SLAYER(1278, "Vampyre Slayer", QuestVarPlayer.QUEST_VAMPYRE_SLAYER, Type.F2P, Difficulty.NOVICE),
	WITCHS_POTION(318, "Witch's Potion", QuestVarPlayer.QUEST_WITCHS_POTION, Type.F2P, Difficulty.NOVICE),
	X_MARKS_THE_SPOT(3155, "X Marks the Spot", QuestVarbits.QUEST_X_MARKS_THE_SPOT, Type.F2P, Difficulty.NOVICE),

	//Members' Quests
	ANIMAL_MAGNETISM(331, "Animal Magnetism", QuestVarbits.QUEST_ANIMAL_MAGNETISM, Type.P2P, Difficulty.INTERMEDIATE),
	ANOTHER_SLICE_OF_HAM(332, "Another Slice of H.A.M.", QuestVarbits.QUEST_ANOTHER_SLICE_OF_HAM, Type.P2P, Difficulty.INTERMEDIATE),
	BETWEEN_A_ROCK(333, "Between a Rock...", QuestVarbits.QUEST_BETWEEN_A_ROCK, Type.P2P, Difficulty.EXPERIENCED),
	BIG_CHOMPY_BIRD_HUNTING(334, "Big Chompy Bird Hunting", QuestVarPlayer.QUEST_BIG_CHOMPY_BIRD_HUNTING, Type.P2P, Difficulty.INTERMEDIATE),
	BIOHAZARD(335, "Biohazard", QuestVarPlayer.QUEST_BIOHAZARD, Type.P2P, Difficulty.NOVICE),
	CABIN_FEVER(336, "Cabin Fever", QuestVarPlayer.QUEST_CABIN_FEVER, Type.P2P, Difficulty.EXPERIENCED),
	CLOCK_TOWER(337, "Clock Tower", QuestVarPlayer.QUEST_CLOCK_TOWER, Type.P2P, Difficulty.NOVICE),
	COLD_WAR(338, "Cold War", QuestVarbits.QUEST_COLD_WAR, Type.P2P, Difficulty.INTERMEDIATE),
	CONTACT(339, "Contact!", QuestVarbits.QUEST_CONTACT, Type.P2P, Difficulty.MASTER),
	CREATURE_OF_FENKENSTRAIN(340, "Creature of Fenkenstrain", QuestVarPlayer.QUEST_CREATURE_OF_FENKENSTRAIN, Type.P2P, Difficulty.INTERMEDIATE),
	DARKNESS_OF_HALLOWVALE(341, "Darkness of Hallowvale", QuestVarbits.QUEST_DARKNESS_OF_HALLOWVALE, Type.P2P, Difficulty.INTERMEDIATE),
	DEATH_PLATEAU(342, "Death Plateau", QuestVarPlayer.QUEST_DEATH_PLATEAU, Type.P2P, Difficulty.NOVICE),
	DEATH_TO_THE_DORGESHUUN(343, "Death to the Dorgeshuun", QuestVarbits.QUEST_DEATH_TO_THE_DORGESHUUN, Type.P2P, Difficulty.INTERMEDIATE),
	THE_DEPTHS_OF_DESPAIR(344, "The Depths of Despair", QuestVarbits.QUEST_THE_DEPTHS_OF_DESPAIR, Type.P2P, Difficulty.NOVICE),
	DESERT_TREASURE(345, "Desert Treasure", QuestVarbits.QUEST_DESERT_TREASURE, Type.P2P, Difficulty.MASTER),
	DEVIOUS_MINDS(346, "Devious Minds", QuestVarbits.QUEST_DEVIOUS_MINDS, Type.P2P, Difficulty.EXPERIENCED),
	THE_DIG_SITE(347, "The Dig Site", QuestVarPlayer.QUEST_THE_DIG_SITE, Type.P2P, Difficulty.INTERMEDIATE),
	DRAGON_SLAYER_II(348, "Dragon Slayer II", QuestVarbits.QUEST_DRAGON_SLAYER_II, Type.P2P, Difficulty.GRANDMASTER),
	DREAM_MENTOR(349, "Dream Mentor", QuestVarbits.QUEST_DREAM_MENTOR, Type.P2P, Difficulty.MASTER),
	DRUIDIC_RITUAL(350, "Druidic Ritual", QuestVarPlayer.QUEST_DRUIDIC_RITUAL, Type.P2P, Difficulty.NOVICE),
	DWARF_CANNON(351, "Dwarf Cannon", QuestVarPlayer.QUEST_DWARF_CANNON, Type.P2P, Difficulty.NOVICE),
	EADGARS_RUSE(352, "Eadgar's Ruse", QuestVarPlayer.QUEST_EADGARS_RUSE, Type.P2P, Difficulty.EXPERIENCED),
	EAGLES_PEAK(353, "Eagles' Peak", QuestVarbits.QUEST_EAGLES_PEAK, Type.P2P, Difficulty.NOVICE),
	ELEMENTAL_WORKSHOP_I(354, "Elemental Workshop I", QuestVarPlayer.QUEST_ELEMENTAL_WORKSHOP_I, Type.P2P, Difficulty.NOVICE),
	ELEMENTAL_WORKSHOP_II(355, "Elemental Workshop II", QuestVarbits.QUEST_ELEMENTAL_WORKSHOP_II, Type.P2P, Difficulty.INTERMEDIATE),
	ENAKHRAS_LAMENT(356, "Enakhra's Lament", QuestVarbits.QUEST_ENAKHRAS_LAMENT, Type.P2P, Difficulty.EXPERIENCED),
	ENLIGHTENED_JOURNEY(357, "Enlightened Journey", QuestVarbits.QUEST_ENLIGHTENED_JOURNEY, Type.P2P, Difficulty.INTERMEDIATE),
	THE_EYES_OF_GLOUPHRIE(358, "The Eyes of Glouphrie", QuestVarbits.QUEST_THE_EYES_OF_GLOUPHRIE, Type.P2P, Difficulty.INTERMEDIATE),
	FAIRYTALE_I__GROWING_PAINS(359, "Fairytale I - Growing Pains", QuestVarbits.QUEST_FAIRYTALE_I_GROWING_PAINS, Type.P2P, Difficulty.EXPERIENCED),
	FAIRYTALE_II__CURE_A_QUEEN(360, "Fairytale II - Cure a Queen", QuestVarbits.QUEST_FAIRYTALE_II_CURE_A_QUEEN, Type.P2P, Difficulty.EXPERIENCED),
	FAMILY_CREST(361, "Family Crest", QuestVarPlayer.QUEST_FAMILY_CREST, Type.P2P, Difficulty.EXPERIENCED),
	THE_FEUD(362, "The Feud", QuestVarbits.QUEST_THE_FEUD, Type.P2P, Difficulty.INTERMEDIATE),
	FIGHT_ARENA(363, "Fight Arena", QuestVarPlayer.QUEST_FIGHT_ARENA, Type.P2P, Difficulty.EXPERIENCED),
	FISHING_CONTEST(364, "Fishing Contest", QuestVarPlayer.QUEST_FISHING_CONTEST, Type.P2P, Difficulty.NOVICE),
	FORGETTABLE_TALE(365, "Forgettable Tale...", QuestVarbits.QUEST_FORGETTABLE_TALE, Type.P2P, Difficulty.INTERMEDIATE),
	BONE_VOYAGE(3135, "Bone Voyage", QuestVarbits.QUEST_BONE_VOYAGE, Type.P2P, Difficulty.INTERMEDIATE),
	THE_FREMENNIK_ISLES(367, "The Fremennik Isles", QuestVarbits.QUEST_THE_FREMENNIK_ISLES, Type.P2P, Difficulty.EXPERIENCED),
	THE_FREMENNIK_TRIALS(368, "The Fremennik Trials", QuestVarPlayer.QUEST_THE_FREMENNIK_TRIALS, Type.P2P, Difficulty.INTERMEDIATE),
	GARDEN_OF_TRANQUILLITY(369, "Garden of Tranquillity", QuestVarbits.QUEST_GARDEN_OF_TRANQUILLITY, Type.P2P, Difficulty.INTERMEDIATE),
	GERTRUDES_CAT(370, "Gertrude's Cat", QuestVarPlayer.QUEST_GERTRUDES_CAT, Type.P2P, Difficulty.NOVICE),
	GHOSTS_AHOY(371, "Ghosts Ahoy", QuestVarbits.QUEST_GHOSTS_AHOY, Type.P2P, Difficulty.INTERMEDIATE),
	THE_GIANT_DWARF(372, "The Giant Dwarf", QuestVarbits.QUEST_THE_GIANT_DWARF, Type.P2P, Difficulty.INTERMEDIATE),
	THE_GOLEM(373, "The Golem", QuestVarbits.QUEST_THE_GOLEM, Type.P2P, Difficulty.INTERMEDIATE),
	THE_GRAND_TREE(374, "The Grand Tree", QuestVarPlayer.QUEST_THE_GRAND_TREE, Type.P2P, Difficulty.EXPERIENCED),
	THE_GREAT_BRAIN_ROBBERY(375, "The Great Brain Robbery", QuestVarPlayer.QUEST_THE_GREAT_BRAIN_ROBBERY, Type.P2P, Difficulty.EXPERIENCED),
	GRIM_TALES(376, "Grim Tales", QuestVarbits.QUEST_GRIM_TALES, Type.P2P, Difficulty.MASTER),
	THE_HAND_IN_THE_SAND(377, "The Hand in the Sand", QuestVarbits.QUEST_THE_HAND_IN_THE_SAND, Type.P2P, Difficulty.INTERMEDIATE),
	HAUNTED_MINE(378, "Haunted Mine", QuestVarPlayer.QUEST_HAUNTED_MINE, Type.P2P, Difficulty.EXPERIENCED),
	HAZEEL_CULT(379, "Hazeel Cult", QuestVarPlayer.QUEST_HAZEEL_CULT, Type.P2P, Difficulty.NOVICE),
	HEROES_QUEST(3142, "Heroes' Quest", QuestVarPlayer.QUEST_HEROES_QUEST, Type.P2P, Difficulty.EXPERIENCED),
	HOLY_GRAIL(381, "Holy Grail", QuestVarPlayer.QUEST_HOLY_GRAIL, Type.P2P, Difficulty.INTERMEDIATE),
	HORROR_FROM_THE_DEEP(382, "Horror from the Deep", QuestVarbits.QUEST_HORROR_FROM_THE_DEEP, Type.P2P, Difficulty.EXPERIENCED),
	ICTHLARINS_LITTLE_HELPER(383, "Icthlarin's Little Helper", QuestVarbits.QUEST_ICTHLARINS_LITTLE_HELPER, Type.P2P, Difficulty.INTERMEDIATE),
	IN_AID_OF_THE_MYREQUE(384, "In Aid of the Myreque", QuestVarbits.QUEST_IN_AID_OF_THE_MYREQUE, Type.P2P, Difficulty.INTERMEDIATE),
	IN_SEARCH_OF_THE_MYREQUE(385, "In Search of the Myreque", QuestVarPlayer.QUEST_IN_SEARCH_OF_THE_MYREQUE, Type.P2P, Difficulty.INTERMEDIATE),
	JUNGLE_POTION(386, "Jungle Potion", QuestVarPlayer.QUEST_JUNGLE_POTION, Type.P2P, Difficulty.NOVICE),
	KINGS_RANSOM(387, "King's Ransom", QuestVarbits.QUEST_KINGS_RANSOM, Type.P2P, Difficulty.EXPERIENCED),
	LEGENDS_QUEST(3145, "Legends' Quest", QuestVarPlayer.QUEST_LEGENDS_QUEST, Type.P2P, Difficulty.MASTER),
	LOST_CITY(389, "Lost City", QuestVarPlayer.QUEST_LOST_CITY, Type.P2P, Difficulty.EXPERIENCED),
	THE_LOST_TRIBE(390, "The Lost Tribe", QuestVarbits.QUEST_THE_LOST_TRIBE, Type.P2P, Difficulty.INTERMEDIATE),
	LUNAR_DIPLOMACY(391, "Lunar Diplomacy", QuestVarbits.QUEST_LUNAR_DIPLOMACY, Type.P2P, Difficulty.EXPERIENCED),
	MAKING_FRIENDS_WITH_MY_ARM(392, "Making Friends with My Arm", QuestVarbits.QUEST_MAKING_FRIENDS_WITH_MY_ARM, Type.P2P, Difficulty.MASTER),
	MAKING_HISTORY(393, "Making History", QuestVarbits.QUEST_MAKING_HISTORY, Type.P2P, Difficulty.INTERMEDIATE),
	MERLINS_CRYSTAL(394, "Merlin's Crystal", QuestVarPlayer.QUEST_MERLINS_CRYSTAL, Type.P2P, Difficulty.INTERMEDIATE),
	MONKEY_MADNESS_I(395, "Monkey Madness I", QuestVarPlayer.QUEST_MONKEY_MADNESS_I, Type.P2P, Difficulty.MASTER),
	MONKEY_MADNESS_II(396, "Monkey Madness II", QuestVarbits.QUEST_MONKEY_MADNESS_II, Type.P2P, Difficulty.GRANDMASTER),
	MONKS_FRIEND(397, "Monk's Friend", QuestVarPlayer.QUEST_MONKS_FRIEND, Type.P2P, Difficulty.NOVICE),
	MOUNTAIN_DAUGHTER(398, "Mountain Daughter", QuestVarbits.QUEST_MOUNTAIN_DAUGHTER, Type.P2P, Difficulty.INTERMEDIATE),
	MOURNINGS_END_PART_I(3147, "Mourning's End Part I", QuestVarPlayer.QUEST_MOURNINGS_END_PART_I, Type.P2P, Difficulty.MASTER),
	MOURNINGS_END_PART_II(3148, "Mourning's End Part II", QuestVarbits.QUEST_MOURNINGS_END_PART_II, Type.P2P, Difficulty.MASTER),
	MURDER_MYSTERY(401, "Murder Mystery", QuestVarPlayer.QUEST_MURDER_MYSTERY, Type.P2P, Difficulty.NOVICE),
	MY_ARMS_BIG_ADVENTURE(402, "My Arm's Big Adventure", QuestVarbits.QUEST_MY_ARMS_BIG_ADVENTURE, Type.P2P, Difficulty.INTERMEDIATE),
	NATURE_SPIRIT(403, "Nature Spirit", QuestVarPlayer.QUEST_NATURE_SPIRIT, Type.P2P, Difficulty.NOVICE),
	OBSERVATORY_QUEST(3149, "Observatory Quest", QuestVarPlayer.QUEST_OBSERVATORY_QUEST, Type.P2P, Difficulty.NOVICE),
	OLAFS_QUEST(3150, "Olaf's Quest", QuestVarbits.QUEST_OLAFS_QUEST, Type.P2P, Difficulty.INTERMEDIATE),
	ONE_SMALL_FAVOUR(406, "One Small Favour", QuestVarPlayer.QUEST_ONE_SMALL_FAVOUR, Type.P2P, Difficulty.EXPERIENCED),
	PLAGUE_CITY(407, "Plague City", QuestVarPlayer.QUEST_PLAGUE_CITY, Type.P2P, Difficulty.NOVICE),
	PRIEST_IN_PERIL(408, "Priest in Peril", QuestVarPlayer.QUEST_PRIEST_IN_PERIL, Type.P2P, Difficulty.NOVICE),
	THE_QUEEN_OF_THIEVES(409, "The Queen of Thieves", QuestVarbits.QUEST_THE_QUEEN_OF_THIEVES, Type.P2P, Difficulty.NOVICE),
	RAG_AND_BONE_MAN_I(3152, "Rag and Bone Man I", QuestVarPlayer.QUEST_RAG_AND_BONE_MAN_I, Type.P2P, Difficulty.NOVICE),
	RAG_AND_BONE_MAN_II(411, "Rag and Bone Man II", QuestVarPlayer.QUEST_RAG_AND_BONE_MAN_II, Type.P2P, Difficulty.INTERMEDIATE),
	RATCATCHERS(412, "Ratcatchers", QuestVarbits.QUEST_RATCATCHERS, Type.P2P, Difficulty.INTERMEDIATE),
	RECIPE_FOR_DISASTER(413, "Recipe for Disaster", QuestVarbits.QUEST_RECIPE_FOR_DISASTER, Type.P2P, Difficulty.GRANDMASTER),
	RECIPE_FOR_DISASTER_START(413, "RFD - Start", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER, Type.P2P, Difficulty.NOVICE),
	RECIPE_FOR_DISASTER_DWARF(413, "RFD - Dwarf", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_DWARF, Type.P2P, Difficulty.NOVICE),
	RECIPE_FOR_DISASTER_WARTFACE_AND_BENTNOZE(413, "RFD - Wartface & Bentnoze", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_WARTFACE_AND_BENTNOZE, Type.P2P, Difficulty.NOVICE),
	RECIPE_FOR_DISASTER_PIRATE_PETE(413, "RFD - Pirate Pete", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_PIRATE_PETE, Type.P2P, Difficulty.INTERMEDIATE),
	RECIPE_FOR_DISASTER_LUMBRIDGE_GUIDE(413, "RFD - Lumbridge Guide", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_LUMBRIDGE_GUIDE, Type.P2P, Difficulty.INTERMEDIATE),
	RECIPE_FOR_DISASTER_EVIL_DAVE(413, "RFD - Evil Dave", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_EVIL_DAVE, Type.P2P, Difficulty.INTERMEDIATE),
	RECIPE_FOR_DISASTER_MONKEY_AMBASSADOR(413, "RFD - Monkey Ambassador", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_MONKEY_AMBASSADOR, Type.P2P, Difficulty.MASTER),
	RECIPE_FOR_DISASTER_SIR_AMIK_VARZE(413, "RFD - Sir Amik Varze", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_SIR_AMIK_VARZE, Type.P2P, Difficulty.MASTER),
	RECIPE_FOR_DISASTER_SKRACH_UGLOGWEE(413, "RFD - Skrach Uglogwee", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER_SKRACH_UGLOGWEE, Type.P2P, Difficulty.INTERMEDIATE),
	RECIPE_FOR_DISASTER_FINALE(413, "RFD - Finale", Arrays.asList("recipe", "for", "disaster"), QuestVarbits.QUEST_RECIPE_FOR_DISASTER, Type.P2P, Difficulty.GRANDMASTER),
	RECRUITMENT_DRIVE(414, "Recruitment Drive", QuestVarbits.QUEST_RECRUITMENT_DRIVE, Type.P2P, Difficulty.NOVICE),
	REGICIDE(415, "Regicide", QuestVarPlayer.QUEST_REGICIDE, Type.P2P, Difficulty.MASTER),
	ROVING_ELVES(416, "Roving Elves", QuestVarPlayer.QUEST_ROVING_ELVES, Type.P2P, Difficulty.MASTER),
	ROYAL_TROUBLE(417, "Royal Trouble", QuestVarbits.QUEST_ROYAL_TROUBLE, Type.P2P, Difficulty.EXPERIENCED),
	RUM_DEAL(418, "Rum Deal", QuestVarPlayer.QUEST_RUM_DEAL, Type.P2P, Difficulty.EXPERIENCED),
	SCORPION_CATCHER(419, "Scorpion Catcher", QuestVarPlayer.QUEST_SCORPION_CATCHER, Type.P2P, Difficulty.INTERMEDIATE),
	SEA_SLUG(420, "Sea Slug", QuestVarPlayer.QUEST_SEA_SLUG, Type.P2P, Difficulty.INTERMEDIATE),
	SHADES_OF_MORTTON(421, "Shades of Mort'ton", QuestVarPlayer.QUEST_SHADES_OF_MORTTON, Type.P2P, Difficulty.INTERMEDIATE),
	SHADOW_OF_THE_STORM(422, "Shadow of the Storm", QuestVarbits.QUEST_SHADOW_OF_THE_STORM, Type.P2P, Difficulty.INTERMEDIATE),
	SHEEP_HERDER(423, "Sheep Herder", QuestVarPlayer.QUEST_SHEEP_HERDER, Type.P2P, Difficulty.NOVICE),
	SHILO_VILLAGE(424, "Shilo Village", QuestVarPlayer.QUEST_SHILO_VILLAGE, Type.P2P, Difficulty.EXPERIENCED),
	THE_SLUG_MENACE(425, "The Slug Menace", QuestVarbits.QUEST_THE_SLUG_MENACE, Type.P2P, Difficulty.INTERMEDIATE),
	A_SOULS_BANE(426, "A Soul's Bane", QuestVarbits.QUEST_A_SOULS_BANE, Type.P2P, Difficulty.NOVICE),
	SPIRITS_OF_THE_ELID(427, "Spirits of the Elid", QuestVarbits.QUEST_SPIRITS_OF_THE_ELID, Type.P2P, Difficulty.INTERMEDIATE),
	SWAN_SONG(428, "Swan Song", QuestVarbits.QUEST_SWAN_SONG, Type.P2P, Difficulty.MASTER),
	TAI_BWO_WANNAI_TRIO(429, "Tai Bwo Wannai Trio", QuestVarPlayer.QUEST_TAI_BWO_WANNAI_TRIO, Type.P2P, Difficulty.INTERMEDIATE),
	A_TAIL_OF_TWO_CATS(430, "A Tail of Two Cats", QuestVarbits.QUEST_A_TAIL_OF_TWO_CATS, Type.P2P, Difficulty.INTERMEDIATE),
	TALE_OF_THE_RIGHTEOUS(431, "Tale of the Righteous", QuestVarbits.QUEST_TALE_OF_THE_RIGHTEOUS, Type.P2P, Difficulty.NOVICE),
	A_TASTE_OF_HOPE(432, "A Taste of Hope", QuestVarbits.QUEST_A_TASTE_OF_HOPE, Type.P2P, Difficulty.EXPERIENCED),
	TEARS_OF_GUTHIX(433, "Tears of Guthix", QuestVarbits.QUEST_TEARS_OF_GUTHIX, Type.P2P, Difficulty.INTERMEDIATE),
	TEMPLE_OF_IKOV(434, "Temple of Ikov", QuestVarPlayer.QUEST_TEMPLE_OF_IKOV, Type.P2P, Difficulty.EXPERIENCED),
	THRONE_OF_MISCELLANIA(435, "Throne of Miscellania", QuestVarPlayer.QUEST_THRONE_OF_MISCELLANIA, Type.P2P, Difficulty.EXPERIENCED),
	THE_TOURIST_TRAP(436, "The Tourist Trap", QuestVarPlayer.QUEST_THE_TOURIST_TRAP, Type.P2P, Difficulty.INTERMEDIATE),
	TOWER_OF_LIFE(437, "Tower of Life", QuestVarbits.QUEST_TOWER_OF_LIFE, Type.P2P, Difficulty.NOVICE),
	TREE_GNOME_VILLAGE(438, "Tree Gnome Village", QuestVarPlayer.QUEST_TREE_GNOME_VILLAGE, Type.P2P, Difficulty.INTERMEDIATE),
	TRIBAL_TOTEM(439, "Tribal Totem", QuestVarPlayer.QUEST_TRIBAL_TOTEM, Type.P2P, Difficulty.INTERMEDIATE),
	TROLL_ROMANCE(440, "Troll Romance", QuestVarPlayer.QUEST_TROLL_ROMANCE, Type.P2P, Difficulty.EXPERIENCED),
	TROLL_STRONGHOLD(441, "Troll Stronghold", QuestVarPlayer.QUEST_TROLL_STRONGHOLD, Type.P2P, Difficulty.EXPERIENCED),
	UNDERGROUND_PASS(442, "Underground Pass", QuestVarPlayer.QUEST_UNDERGROUND_PASS, Type.P2P, Difficulty.EXPERIENCED),
	CLIENT_OF_KOUREND(3136, "Client of Kourend", QuestVarbits.QUEST_CLIENT_OF_KOUREND, Type.P2P, Difficulty.NOVICE),
	WANTED(444, "Wanted!", QuestVarbits.QUEST_WANTED, Type.P2P, Difficulty.INTERMEDIATE),
	WATCHTOWER(445, "Watchtower", QuestVarPlayer.QUEST_WATCHTOWER, Type.P2P, Difficulty.INTERMEDIATE),
	WATERFALL_QUEST(3154, "Waterfall Quest", QuestVarPlayer.QUEST_WATERFALL_QUEST, Type.P2P, Difficulty.INTERMEDIATE),
	WHAT_LIES_BELOW(447, "What Lies Below", QuestVarbits.QUEST_WHAT_LIES_BELOW, Type.P2P, Difficulty.INTERMEDIATE),
	WITCHS_HOUSE(448, "Witch's House", QuestVarPlayer.QUEST_WITCHS_HOUSE, Type.P2P, Difficulty.INTERMEDIATE),
	ZOGRE_FLESH_EATERS(449, "Zogre Flesh Eaters", QuestVarbits.QUEST_ZOGRE_FLESH_EATERS, Type.P2P, Difficulty.INTERMEDIATE),
	THE_ASCENT_OF_ARCEUUS(542, "The Ascent of Arceuus", QuestVarbits.QUEST_THE_ASCENT_OF_ARCEUUS, Type.P2P, Difficulty.NOVICE),
	THE_FORSAKEN_TOWER(543, "The Forsaken Tower", QuestVarbits.QUEST_THE_FORSAKEN_TOWER, Type.P2P, Difficulty.NOVICE),
	SONG_OF_THE_ELVES(603, "Song of the Elves", QuestVarbits.QUEST_SONG_OF_THE_ELVES, Type.P2P, Difficulty.GRANDMASTER),
	THE_FREMENNIK_EXILES(3141, "The Fremennik Exiles", QuestVarbits.QUEST_THE_FREMENNIK_EXILES, Type.P2P, Difficulty.MASTER),
	SINS_OF_THE_FATHER(1276, "Sins of the Father", QuestVarbits.QUEST_SINS_OF_THE_FATHER, Type.P2P, Difficulty.MASTER),
	GETTING_AHEAD(752, "Getting Ahead", QuestVarbits.QUEST_GETTING_AHEAD, Type.P2P, Difficulty.INTERMEDIATE),
	A_PORCINE_OF_INTEREST(3151, "A Porcine of Interest", QuestVarbits.QUEST_A_PORCINE_OF_INTEREST, Type.P2P, Difficulty.NOVICE),
	A_KINGDOM_DIVIDED(2971, "A Kingdom Divided", QuestVarbits.QUEST_A_KINGDOM_DIVIDED, Type.P2P, Difficulty.EXPERIENCED),
	A_NIGHT_AT_THE_THEATRE(949, "A Night at the Theatre", QuestVarbits.QUEST_A_NIGHT_AT_THE_THEATRE, Type.P2P, Difficulty.MASTER),


	//Miniquests
	ENTER_THE_ABYSS(3140, "Enter the Abyss", QuestVarPlayer.QUEST_ENTER_THE_ABYSS, Type.MINIQUEST, Difficulty.MINIQUEST),
	ARCHITECTURAL_ALLIANCE(320, "Architectural Alliance", QuestVarbits.QUEST_ARCHITECTURAL_ALLIANCE, Type.MINIQUEST, Difficulty.MINIQUEST),
	BEAR_YOUR_SOUL(1275, "Bear your Soul", QuestVarbits.QUEST_BEAR_YOUR_SOUL, Type.MINIQUEST, Difficulty.MINIQUEST),
	ALFRED_GRIMHANDS_BARCRAWL(322, "Alfred Grimhand's Barcrawl", QuestVarPlayer.QUEST_ALFRED_GRIMHANDS_BARCRAWL, Type.MINIQUEST, Difficulty.MINIQUEST),
	CURSE_OF_THE_EMPTY_LORD(3137, "Curse of the Empty Lord", QuestVarbits.QUEST_CURSE_OF_THE_EMPTY_LORD, Type.MINIQUEST, Difficulty.MINIQUEST),
	ENCHANTED_KEY(324, "Enchanted Key", QuestVarbits.QUEST_ENCHANTED_KEY, Type.MINIQUEST, Difficulty.MINIQUEST),
	THE_GENERALS_SHADOW(325, "The General's Shadow", QuestVarbits.QUEST_THE_GENERALS_SHADOW, Type.MINIQUEST, Difficulty.MINIQUEST),
	SKIPPY_AND_THE_MOGRES(3153, "Skippy and the Mogres", QuestVarbits.QUEST_SKIPPY_AND_THE_MOGRES, Type.MINIQUEST, Difficulty.MINIQUEST),
	THE_MAGE_ARENA(3146, "The Mage Arena", QuestVarPlayer.QUEST_THE_MAGE_ARENA, Type.MINIQUEST, Difficulty.MINIQUEST),
	LAIR_OF_TARN_RAZORLOR(3144, "Lair of Tarn Razorlor", QuestVarbits.QUEST_LAIR_OF_TARN_RAZORLOR, Type.MINIQUEST, Difficulty.MINIQUEST),
	FAMILY_PEST(329, "Family Pest", QuestVarbits.QUEST_FAMILY_PEST, Type.MINIQUEST, Difficulty.MINIQUEST),
	THE_MAGE_ARENA_II(330, "The Mage Arena II", QuestVarbits.QUEST_THE_MAGE_ARENA_II, Type.MINIQUEST, Difficulty.MINIQUEST),
	IN_SEARCH_OF_KNOWLEDGE(3143, "In Search of Knowledge", QuestVarbits.QUEST_IN_SEARCH_OF_KNOWLEDGE, Type.MINIQUEST, Difficulty.MINIQUEST),
	DADDYS_HOME(1688, "Daddy's Home", QuestVarbits.QUEST_DADDYS_HOME, Type.MINIQUEST, Difficulty.MINIQUEST),

	// Fake miniquests
	KNIGHT_WAVES_TRAINING_GROUNDS("Knight Waves Training Grounds", QuestVarbits.KNIGHT_WAVES_TRAINING_GROUNDS, 8,
			Type.MINIQUEST, Difficulty.MINIQUEST),

	// Achievement diaries

	// Ardougne
	ARDOUGNE_EASY("Ardougne Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_ARDOUGNE_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	ARDOUGNE_MEDIUM("Ardougne Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_ARDOUGNE_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	ARDOUGNE_HARD("Ardougne Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_ARDOUGNE_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	ARDOUGNE_ELITE("Ardougne Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_ARDOUGNE_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Desert
	DESERT_EASY("Desert Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_DESERT_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	DESERT_MEDIUM("Desert Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_DESERT_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	DESERT_HARD("Desert Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_DESERT_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	DESERT_ELITE("Desert Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_DESERT_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Falador
	FALADOR_EASY("Falador Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_FALADOR_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	FALADOR_MEDIUM("Falador Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_FALADOR_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	FALADOR_HARD("Falador Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_FALADOR_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	FALADOR_ELITE("Falador Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_FALADOR_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Fremennik
	FREMENNIK_EASY("Fremennik Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_FREMENNIK_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	FREMENNIK_MEDIUM("Fremennik Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_FREMENNIK_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	FREMENNIK_HARD("Fremennik Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_FREMENNIK_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	FREMENNIK_ELITE("Fremennik Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_FREMENNIK_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Kandarin
	KANDARIN_EASY("Kandarin Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_KANDARIN_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KANDARIN_MEDIUM("Kandarin Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_KANDARIN_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KANDARIN_HARD("Kandarin Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_KANDARIN_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KANDARIN_ELITE("Kandarin Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_KANDARIN_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Karamja
	KARAMJA_EASY("Karamja Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_KARAMJA_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KARAMJA_MEDIUM("Karamja Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_KARAMJA_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KARAMJA_HARD("Karamja Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_KARAMJA_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KARAMJA_ELITE("Karamja Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_KARAMJA_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Kourend & Kebos
	KOUREND_EASY("Kourend Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_KOUREND_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KOUREND_MEDIUM("Kourend Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_KOUREND_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KOUREND_HARD("Kourend Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_KOUREND_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	KOUREND_ELITE("Kourend Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_KOUREND_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Lumbridge & Draynor
	LUMBRIDGE_EASY("Lumbridge Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_LUMBRIDGE_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	LUMBRIDGE_MEDIUM("Lumbridge Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_LUMBRIDGE_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	LUMBRIDGE_HARD("Lumbridge Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_LUMBRIDGE_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	LUMBRIDGE_ELITE("Lumbridge Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_LUMBRIDGE_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Morytania
	MORYTANIA_EASY("Morytania Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_MORYTANIA_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	MORYTANIA_MEDIUM("Morytania Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_MORYTANIA_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	MORYTANIA_HARD("Morytania Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_MORYTANIA_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	MORYTANIA_ELITE("Morytania Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_MORYTANIA_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Varrock
	VARROCK_EASY("Varrock Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_VARROCK_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	VARROCK_MEDIUM("Varrock Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_VARROCK_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	VARROCK_HARD("Varrock Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_VARROCK_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	VARROCK_ELITE("Varrock Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_VARROCK_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Western Provinces
	WESTERN_EASY("Western Provinces Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_WESTERN_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	WESTERN_MEDIUM("Western Provinces Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_WESTERN_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	WESTERN_HARD("Western Provinces Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_WESTERN_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	WESTERN_ELITE("Western Provinces Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_WESTERN_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),

	// Wilderness
	WILDERNESS_EASY("Wilderness Easy Diary", QuestVarbits.ACHIEVEMENT_DIARY_WILDERNESS_EASY, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	WILDERNESS_MEDIUM("Wilderness Medium Diary", QuestVarbits.ACHIEVEMENT_DIARY_WILDERNESS_MEDIUM, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	WILDERNESS_HARD("Wilderness Hard Diary", QuestVarbits.ACHIEVEMENT_DIARY_WILDERNESS_HARD, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),
	WILDERNESS_ELITE("Wilderness Elite Diary", QuestVarbits.ACHIEVEMENT_DIARY_WILDERNESS_ELITE, 1, Type.ACHIEVEMENT_DIARY,
			Difficulty.ACHIEVEMENT_DIARY),


	// Generic
	MA2_LOCATOR("Mage Arena II Locator", QuestVarbits.QUEST_THE_MAGE_ARENA_II, -1, Type.GENERIC,
			Difficulty.GENERIC),

	;

	@Getter
	private final int id;

	@Getter
	private final String name;

	@Getter
	private final List<String> keywords;

	@Getter
	private final Type questType;

	@Getter
	private final Difficulty difficulty;

	private final QuestVarbits varbit;

	@Getter
	private final QuestVarPlayer varPlayer;

	private final int completeValue;

	Quest(int id, String name, QuestVarbits varbit, Type questType, Difficulty difficulty)
	{
		this.id = id;
		this.name = name;
		this.keywords = titleToKeywords(name);
		this.varbit = varbit;
		this.varPlayer = null;
		this.questType = questType;
		this.difficulty = difficulty;
		this.completeValue = -1;
	}

	Quest(int id, String name, QuestVarPlayer varPlayer, Type questType, Difficulty difficulty)
	{
		this.id = id;
		this.name = name;
		this.keywords = titleToKeywords(name);
		this.varbit = null;
		this.varPlayer = varPlayer;
		this.questType = questType;
		this.difficulty = difficulty;
		this.completeValue = -1;
	}

	Quest(int id, String name, List<String> keywords, QuestVarbits varbit, Type questType, Difficulty difficulty)
	{
		this.id = id;
		this.name = name;
		this.keywords = Stream.concat(titleToKeywords(name).stream(), keywords.stream()).collect(Collectors.toList());
		this.varbit = varbit;
		this.varPlayer = null;
		this.questType = questType;
		this.difficulty = difficulty;
		this.completeValue = -1;
	}

	Quest(String name, QuestVarbits varbit, int completeValue, Type questType, Difficulty difficulty)
	{
		this.id = -1;
		this.name = name;
		this.keywords = titleToKeywords(name);
		this.varbit = varbit;
		this.varPlayer = null;
		this.questType = questType;
		this.difficulty = difficulty;
		this.completeValue = completeValue;
	}

	private List<String> titleToKeywords(String title)
	{
		return Arrays.asList(title.toLowerCase().split(" "));
	}

	public QuestState getState()
	{
		Client client = Static.getClient();
		if (getProgress() == -1)
		{
			return QuestState.IN_PROGRESS;
		}

		if (completeValue != -1)
		{
			int currentState = getProgress();
			if (currentState == completeValue)
			{
				return QuestState.FINISHED;
			}
			if (currentState == 0)
			{
				return QuestState.NOT_STARTED;
			}
			return QuestState.IN_PROGRESS;
		}

		return GameThread.invokeLater(() ->
		{
			client.runScript(ScriptID.QUEST_STATUS_GET, id);
			switch (client.getIntStack()[0])
			{
				case 2:
					return QuestState.FINISHED;
				case 1:
					return QuestState.NOT_STARTED;
				default:
					return QuestState.IN_PROGRESS;
			}
		});
	}

	public int getProgress()
	{
		if (varbit != null)
		{
			return Vars.getBit(varbit.getId());
		}
		else if (varPlayer != null)
		{
			return Vars.getVarp(varPlayer.getId());
		}
		else
		{
			return -1;
		}
	}

	public enum Difficulty
	{
		ALL,
		NOVICE,
		INTERMEDIATE,
		EXPERIENCED,
		MASTER,
		GRANDMASTER,
		MINIQUEST,
		ACHIEVEMENT_DIARY,
		GENERIC,
		SKILL
	}

	public enum Type
	{
		F2P,
		P2P,
		MINIQUEST,
		ACHIEVEMENT_DIARY,
		GENERIC,
		SKILL
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import lombok.Value;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.unethicalite.api.quests.Quests;

import java.util.Set;

@Value
public class QuestRequirement implements Requirement
{
    Quest quest;
    Set<QuestState> states;

    @Override
    public Boolean get()
    {
        return states.contains(Quests.getState(quest));
    }
}

package net.unethicalite.api.quests;

import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.unethicalite.client.managers.QuestManager;

public class Quests
{

    public static QuestState getState(Quest quest)
    {
        return QuestManager.getQuestStates().get(quest);
    }

    public static boolean isFinished(Quest quest)
    {
        return QuestManager.getQuestStates().get(quest) == QuestState.FINISHED;
    }

}

package net.unethicalite.api.quests;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum QuestVarbits
{
	QUEST_TAB(8168),

	/**
	 * f2p Quest varbits, these don't hold the completion value.
	 */
	QUEST_BELOW_ICE_MOUNTAIN(12063),
	QUEST_DEMON_SLAYER(2561),
	QUEST_GOBLIN_DIPLOMACY(2378),
	QUEST_MISTHALIN_MYSTERY(3468),
	QUEST_THE_CORSAIR_CURSE(6071),
	QUEST_X_MARKS_THE_SPOT(8063),

	/**
	 * member Quest varbits, these don't hold the completion value.
	 */
	QUEST_ANIMAL_MAGNETISM(3185),
	QUEST_BETWEEN_A_ROCK(299),
	QUEST_CONTACT(3274),
	QUEST_ZOGRE_FLESH_EATERS(487),
	QUEST_DARKNESS_OF_HALLOWVALE(2573),
	QUEST_DEATH_TO_THE_DORGESHUUN(2258),
	QUEST_DESERT_TREASURE(358),
	QUEST_DEVIOUS_MINDS(1465),
	QUEST_EAGLES_PEAK(2780),
	QUEST_ELEMENTAL_WORKSHOP_II(2639),
	QUEST_ENAKHRAS_LAMENT(1560),
	QUEST_ENLIGHTENED_JOURNEY(2866),
	QUEST_THE_EYES_OF_GLOUPHRIE(2497),
	QUEST_FAIRYTALE_I_GROWING_PAINS(1803),
	QUEST_FAIRYTALE_II_CURE_A_QUEEN(2326),
	QUEST_THE_FEUD(334),
	QUEST_FORGETTABLE_TALE(822),
	QUEST_GARDEN_OF_TRANQUILLITY(961),
	QUEST_GHOSTS_AHOY(217),
	QUEST_THE_GIANT_DWARF(571),
	QUEST_THE_GOLEM(346),
	QUEST_THE_HAND_IN_THE_SAND(1527),
	QUEST_HORROR_FROM_THE_DEEP(34),
	QUEST_ICTHLARINS_LITTLE_HELPER(418),
	QUEST_IN_AID_OF_THE_MYREQUE(1990),
	QUEST_THE_LOST_TRIBE(532),
	QUEST_LUNAR_DIPLOMACY(2448),
	QUEST_MAKING_HISTORY(1383),
	QUEST_MOUNTAIN_DAUGHTER(260),
	QUEST_MOURNINGS_END_PART_II(1103),
	QUEST_MY_ARMS_BIG_ADVENTURE(2790),
	QUEST_RATCATCHERS(1404),
	QUEST_RECIPE_FOR_DISASTER(1850),
	QUEST_RECIPE_FOR_DISASTER_DWARF(1892),
	QUEST_RECIPE_FOR_DISASTER_WARTFACE_AND_BENTNOZE(1867),
	QUEST_RECIPE_FOR_DISASTER_PIRATE_PETE(1895),
	QUEST_RECIPE_FOR_DISASTER_LUMBRIDGE_GUIDE(1896),
	QUEST_RECIPE_FOR_DISASTER_EVIL_DAVE(1878),
	QUEST_RECIPE_FOR_DISASTER_SIR_AMIK_VARZE(1910),
	QUEST_RECIPE_FOR_DISASTER_SKRACH_UGLOGWEE(1904),
	QUEST_RECIPE_FOR_DISASTER_MONKEY_AMBASSADOR(1914),
	QUEST_RECRUITMENT_DRIVE(657),
	QUEST_ROYAL_TROUBLE(2140),
	QUEST_THE_SLUG_MENACE(2610),
	QUEST_SHADOW_OF_THE_STORM(1372),
	QUEST_A_SOULS_BANE(2011),
	QUEST_SPIRITS_OF_THE_ELID(1444),
	QUEST_SWAN_SONG(2098),
	QUEST_A_TAIL_OF_TWO_CATS(1028),
	QUEST_TEARS_OF_GUTHIX(451),
	QUEST_WANTED(1051),
	QUEST_COLD_WAR(3293),
	QUEST_THE_FREMENNIK_ISLES(3311),
	QUEST_TOWER_OF_LIFE(3337),
	QUEST_WHAT_LIES_BELOW(3523),
	QUEST_OLAFS_QUEST(3534),
	QUEST_ANOTHER_SLICE_OF_HAM(3550),
	QUEST_DREAM_MENTOR(3618),
	QUEST_GRIM_TALES(2783),
	QUEST_KINGS_RANSOM(3888),
	QUEST_MONKEY_MADNESS_II(5027),
	QUEST_CLIENT_OF_KOUREND(5619),
	QUEST_BONE_VOYAGE(5795),
	QUEST_THE_QUEEN_OF_THIEVES(6037),
	QUEST_THE_DEPTHS_OF_DESPAIR(6027),
	QUEST_DRAGON_SLAYER_II(6104),
	QUEST_TALE_OF_THE_RIGHTEOUS(6358),
	QUEST_A_TASTE_OF_HOPE(6396),
	QUEST_MAKING_FRIENDS_WITH_MY_ARM(6528),
	QUEST_THE_ASCENT_OF_ARCEUUS(7856),
	QUEST_THE_FORSAKEN_TOWER(7796),
	QUEST_SONG_OF_THE_ELVES(9016),
	QUEST_THE_FREMENNIK_EXILES(9459),
	QUEST_SINS_OF_THE_FATHER(7255),
	QUEST_A_PORCINE_OF_INTEREST(10582),
	QUEST_GETTING_AHEAD(693),
	QUEST_A_KINGDOM_DIVIDED(12296),
	QUEST_A_NIGHT_AT_THE_THEATRE(12276),

	/**
	 * mini-quest varbits, these don't hold the completion value.
	 */
	QUEST_ARCHITECTURAL_ALLIANCE(4982),
	QUEST_BEAR_YOUR_SOUL(5078),
	QUEST_CURSE_OF_THE_EMPTY_LORD(821),
	QUEST_ENCHANTED_KEY(1391),
	QUEST_THE_GENERALS_SHADOW(3330),
	QUEST_SKIPPY_AND_THE_MOGRES(1344),
	QUEST_LAIR_OF_TARN_RAZORLOR(3290),
	QUEST_FAMILY_PEST(5347),
	QUEST_THE_MAGE_ARENA_II(6067),
	QUEST_IN_SEARCH_OF_KNOWLEDGE(8403),
	QUEST_DADDYS_HOME(10570),

	// Fake miniquests
	KNIGHT_WAVES_TRAINING_GROUNDS(3909),

	// Achievement Diaries

	// Ardougne
	ACHIEVEMENT_DIARY_ARDOUGNE_EASY(4499),
	ACHIEVEMENT_DIARY_ARDOUGNE_MEDIUM(4500),
	ACHIEVEMENT_DIARY_ARDOUGNE_HARD(4501),
	ACHIEVEMENT_DIARY_ARDOUGNE_ELITE(4502),

	// Desert
	ACHIEVEMENT_DIARY_DESERT_EASY(4523),
	ACHIEVEMENT_DIARY_DESERT_MEDIUM(4524),
	ACHIEVEMENT_DIARY_DESERT_HARD(4525),
	ACHIEVEMENT_DIARY_DESERT_ELITE(4526),

	// Falador
	ACHIEVEMENT_DIARY_FALADOR_EASY(4503),
	ACHIEVEMENT_DIARY_FALADOR_MEDIUM(4504),
	ACHIEVEMENT_DIARY_FALADOR_HARD(4505),
	ACHIEVEMENT_DIARY_FALADOR_ELITE(4506),

	// Fremennik
	ACHIEVEMENT_DIARY_FREMENNIK_EASY(4531),
	ACHIEVEMENT_DIARY_FREMENNIK_MEDIUM(4532),
	ACHIEVEMENT_DIARY_FREMENNIK_HARD(4533),
	ACHIEVEMENT_DIARY_FREMENNIK_ELITE(4534),

	// Kandarin
	ACHIEVEMENT_DIARY_KANDARIN_EASY(4515),
	ACHIEVEMENT_DIARY_KANDARIN_MEDIUM(4516),
	ACHIEVEMENT_DIARY_KANDARIN_HARD(4517),
	ACHIEVEMENT_DIARY_KANDARIN_ELITE(4518),

	// Karamja
	ACHIEVEMENT_DIARY_KARAMJA_EASY(3577),
	ACHIEVEMENT_DIARY_KARAMJA_MEDIUM(3598),
	ACHIEVEMENT_DIARY_KARAMJA_HARD(3610),
	ACHIEVEMENT_DIARY_KARAMJA_ELITE(4567),

	// Kourend & Kebos
	ACHIEVEMENT_DIARY_KOUREND_EASY(7929),
	ACHIEVEMENT_DIARY_KOUREND_MEDIUM(7930),
	ACHIEVEMENT_DIARY_KOUREND_HARD(7931),
	ACHIEVEMENT_DIARY_KOUREND_ELITE(7932),

	// Lumbridge & Draynor
	ACHIEVEMENT_DIARY_LUMBRIDGE_EASY(4535),
	ACHIEVEMENT_DIARY_LUMBRIDGE_MEDIUM(4536),
	ACHIEVEMENT_DIARY_LUMBRIDGE_HARD(4537),
	ACHIEVEMENT_DIARY_LUMBRIDGE_ELITE(4538),

	// Morytania
	ACHIEVEMENT_DIARY_MORYTANIA_EASY(4527),
	ACHIEVEMENT_DIARY_MORYTANIA_MEDIUM(4528),
	ACHIEVEMENT_DIARY_MORYTANIA_HARD(4529),
	ACHIEVEMENT_DIARY_MORYTANIA_ELITE(4530),

	// Varrock
	ACHIEVEMENT_DIARY_VARROCK_EASY(4519),
	ACHIEVEMENT_DIARY_VARROCK_MEDIUM(4520),
	ACHIEVEMENT_DIARY_VARROCK_HARD(4521),
	ACHIEVEMENT_DIARY_VARROCK_ELITE(4522),

	// Western Provinces
	// TODO: Fix incorrect values!
	ACHIEVEMENT_DIARY_WESTERN_EASY(4519),
	ACHIEVEMENT_DIARY_WESTERN_MEDIUM(4520),
	ACHIEVEMENT_DIARY_WESTERN_HARD(4521),
	ACHIEVEMENT_DIARY_WESTERN_ELITE(4522),

	// Wilderness
	ACHIEVEMENT_DIARY_WILDERNESS_EASY(4507),
	ACHIEVEMENT_DIARY_WILDERNESS_MEDIUM(4508),
	ACHIEVEMENT_DIARY_WILDERNESS_HARD(4509),
	ACHIEVEMENT_DIARY_WILDERNESS_ELITE(4510),

	CUTSCENE(542),
	DIALOG_CHOICE(5983);

	private final int id;
}

package net.unethicalite.api.quests;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Server controlled "content-developer" integers.
 * <p>
 * VarPlayers are stored per RuneScape player save, and synchronized
 * from the server to the client. The client can change them preemptively
 * if it thinks they will change the next tick as a lag-hiding measure.
 * The client CANNOT directly make the server change a varbit.
 */
@AllArgsConstructor
@Getter
public enum QuestVarPlayer
{
	/**
	 * f2p Quest varbits, these don't hold the completion value.
	 */
	QUEST_BLACK_KNIGHTS_FORTRESS(130),
	QUEST_COOKS_ASSISTANT(29),
	QUEST_DORICS_QUEST(31),
	QUEST_DRAGON_SLAYER_I(176),
	QUEST_ERNEST_THE_CHICKEN(32),
	QUEST_IMP_CATCHER(160),
	QUEST_THE_KNIGHTS_SWORD(122),
	QUEST_PIRATES_TREASURE(71),
	QUEST_PRINCE_ALI_RESCUE(273),
	QUEST_THE_RESTLESS_GHOST(107),
	QUEST_ROMEO_AND_JULIET(144),
	QUEST_RUNE_MYSTERIES(63),
	QUEST_SHEEP_SHEARER(179),
	QUEST_SHIELD_OF_ARRAV(145),
	QUEST_SHIELD_OF_ARRAV_STATE_146(146),
	QUEST_VAMPYRE_SLAYER(178),
	QUEST_WITCHS_POTION(67),

	/**
	 * member Quest varbits, these don't hold the completion value.
	 */
	QUEST_BIG_CHOMPY_BIRD_HUNTING(293),
	QUEST_BIOHAZARD(68),
	QUEST_CABIN_FEVER(655),
	QUEST_CLOCK_TOWER(10),
	QUEST_CREATURE_OF_FENKENSTRAIN(399),
	QUEST_DEATH_PLATEAU(314),
	QUEST_THE_DIG_SITE(131),
	QUEST_DRUIDIC_RITUAL(80),
	QUEST_DWARF_CANNON(0),
	QUEST_EADGARS_RUSE(335),
	QUEST_ELEMENTAL_WORKSHOP_I(299),
	QUEST_FAMILY_CREST(148),
	QUEST_FIGHT_ARENA(17),
	QUEST_FISHING_CONTEST(11),
	QUEST_THE_FREMENNIK_TRIALS(347),
	QUEST_WATERFALL_QUEST(65),
	QUEST_GERTRUDES_CAT(180),
	QUEST_THE_GRAND_TREE(150),
	QUEST_HAUNTED_MINE(382),
	QUEST_HAZEEL_CULT(223),
	QUEST_HEROES_QUEST(188),
	QUEST_HOLY_GRAIL(5),
	QUEST_IN_SEARCH_OF_THE_MYREQUE(387),
	QUEST_JUNGLE_POTION(175),
	QUEST_LEGENDS_QUEST(139),
	QUEST_LOST_CITY(147),
	QUEST_MERLINS_CRYSTAL(14),
	QUEST_MONKEY_MADNESS_I(365),
	QUEST_MONKS_FRIEND(30),
	QUEST_MOURNINGS_END_PART_I(517),
	QUEST_MURDER_MYSTERY(192),
	QUEST_NATURE_SPIRIT(307),
	QUEST_OBSERVATORY_QUEST(112),
	QUEST_ONE_SMALL_FAVOUR(416),
	QUEST_PLAGUE_CITY(165),
	QUEST_PRIEST_IN_PERIL(302),
	QUEST_RAG_AND_BONE_MAN_I(714),
	QUEST_REGICIDE(328),
	QUEST_ROVING_ELVES(402),
	QUEST_RUM_DEAL(600),
	QUEST_SCORPION_CATCHER(76),
	QUEST_SEA_SLUG(159),
	QUEST_SHADES_OF_MORTTON(339),
	QUEST_SHEEP_HERDER(60),
	QUEST_SHILO_VILLAGE(116),
	QUEST_TAI_BWO_WANNAI_TRIO(320),
	QUEST_TEMPLE_OF_IKOV(26),
	QUEST_THRONE_OF_MISCELLANIA(359),
	QUEST_THE_TOURIST_TRAP(197),
	QUEST_WITCHS_HOUSE(226),
	QUEST_TREE_GNOME_VILLAGE(111),
	QUEST_TRIBAL_TOTEM(200),
	QUEST_TROLL_ROMANCE(385),
	QUEST_TROLL_STRONGHOLD(317),
	QUEST_UNDERGROUND_PASS(161),
	QUEST_UNDERGROUND_PASS_STATE_162(162),
	QUEST_WATCHTOWER(212),
	QUEST_THE_GREAT_BRAIN_ROBBERY(980),
	QUEST_RAG_AND_BONE_MAN_II(714),

	/**
	 * mini-quest varbits, these don't hold the completion value.
	 */
	QUEST_ENTER_THE_ABYSS(492),
	QUEST_ALFRED_GRIMHANDS_BARCRAWL(77),
	QUEST_ALFRED_GRIMHANDS_BARCRAWL_STATE_76(76),
	QUEST_THE_MAGE_ARENA(267);


	private final int id;
}

package net.unethicalite.api.commons;

import java.util.concurrent.ThreadLocalRandom;

public class Rand
{

	public static synchronized int nextInt(int min, int max)
	{
		return ThreadLocalRandom.current().nextInt(min, max);
	}

	public static synchronized int nextInt()
	{
		return ThreadLocalRandom.current().nextInt();
	}

	public static synchronized boolean nextBool()
	{
		return ThreadLocalRandom.current().nextBoolean();
	}
}

package net.unethicalite.api.movement;

import net.unethicalite.api.Positionable;
import net.unethicalite.api.scene.Tiles;
import net.runelite.api.CollisionData;
import net.runelite.api.GameObject;
import net.runelite.api.Locatable;
import net.runelite.api.Player;
import net.runelite.api.Tile;
import net.runelite.api.WallObject;
import net.runelite.api.coords.Direction;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.client.Static;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

public class Reachable
{
	private static final int MAX_ATTEMPTED_TILES = 64 * 64;

	public static boolean check(int flag, int checkFlag)
	{
		return (flag & checkFlag) != 0;
	}

	public static boolean isObstacle(int endFlag)
	{
		return check(endFlag, 0x100 | 0x20000 | 0x200000 | 0x1000000);
	}

	public static boolean isObstacle(WorldPoint worldPoint)
	{
		return isObstacle(getCollisionFlag(worldPoint));
	}

	public static int getCollisionFlag(WorldPoint point)
	{
		CollisionData[] collisionMaps = Static.getClient().getCollisionMaps();
		if (collisionMaps == null)
		{
			return 0xFFFFFF;
		}

		CollisionData collisionData = collisionMaps[Static.getClient().getPlane()];
		if (collisionData == null)
		{
			return 0xFFFFFF;
		}

		LocalPoint localPoint = LocalPoint.fromWorld(Static.getClient(), point);
		if (localPoint == null)
		{
			return 0xFFFFFF;
		}

		return collisionData.getFlags()[localPoint.getSceneX()][localPoint.getSceneY()];
	}

	public static boolean isWalled(Direction direction, int startFlag)
	{
		switch (direction)
		{
			case NORTH:
				return check(startFlag, 0x2);
			case SOUTH:
				return check(startFlag, 0x20);
			case WEST:
				return check(startFlag, 0x80);
			case EAST:
				return check(startFlag, 0x8);
			default:
				throw new IllegalArgumentException();
		}
	}

	public static boolean isWalled(WorldPoint source, WorldPoint destination)
	{
		return isWalled(Tiles.getAt(source), Tiles.getAt(destination));
	}

	public static boolean isWalled(Tile source, Tile destination)
	{
		WallObject wall = source.getWallObject();
		if (wall == null)
		{
			return false;
		}

		WorldPoint a = source.getWorldLocation();
		WorldPoint b = destination.getWorldLocation();

		switch (wall.getOrientationA())
		{
			case 1:
				return a.dx(-1).equals(b) || a.dx(-1).dy(1).equals(b) || a.dx(-1).dy(-1).equals(b);
			case 2:
				return a.dy(1).equals(b) || a.dx(-1).dy(1).equals(b) || a.dx(1).dy(1).equals(b);
			case 4:
				return a.dx(1).equals(b) || a.dx(1).dy(1).equals(b) || a.dx(1).dy(-1).equals(b);
			case 8:
				return a.dy(-1).equals(b) || a.dx(-1).dy(-1).equals(b) || a.dx(-1).dy(1).equals(b);
			default:
				return false;
		}
	}

	public static boolean hasDoor(WorldPoint source, Direction direction)
	{
		Tile tile = Tiles.getAt(source);
		if (tile == null)
		{
			return false;
		}

		return hasDoor(tile, direction);
	}

	public static boolean hasDoor(Tile source, Direction direction)
	{
		WallObject wall = source.getWallObject();
		if (wall == null)
		{
			return false;
		}

		return isWalled(direction, getCollisionFlag(source.getWorldLocation())) && wall.hasAction("Open", "Close");
	}

	public static boolean isDoored(Tile source, Tile destination)
	{
		WallObject wall = source.getWallObject();
		if (wall == null)
		{
			return false;
		}

		return isWalled(source, destination) && wall.hasAction("Open");
	}

	public static boolean canWalk(Direction direction, int startFlag, int endFlag)
	{
		if (isObstacle(endFlag))
		{
			return false;
		}

		return !isWalled(direction, startFlag);
	}

	public static WorldPoint getNeighbour(Direction direction, WorldPoint source)
	{
		switch (direction)
		{
			case NORTH:
				return source.dy(1);
			case SOUTH:
				return source.dy(-1);
			case WEST:
				return source.dx(-1);
			case EAST:
				return source.dx(1);
			default:
				throw new IllegalArgumentException();
		}
	}

	public static List<WorldPoint> getNeighbours(Positionable destination, Positionable current)
	{
		List<WorldPoint> out = new ArrayList<>();
		WorldPoint dest = current instanceof WorldPoint ? (WorldPoint) current : current.getWorldLocation();
		for (Direction dir : Direction.values())
		{
			WorldPoint neighbour = getNeighbour(dir, dest);
			if (!neighbour.isInScene(Static.getClient()))
			{
				continue;
			}

			if (destination instanceof Locatable)
			{
				Locatable targetObject = (Locatable) destination;
				boolean containsPoint;
				if (targetObject instanceof GameObject)
				{
					containsPoint = ((GameObject) targetObject).getWorldArea().contains(neighbour);
				}
				else
				{
					containsPoint = targetObject.getWorldLocation().equals(neighbour);
				}

				if (containsPoint
						&& (!isWalled(dir, getCollisionFlag(dest)) || targetObject instanceof WallObject))
				{
					out.add(neighbour);
					continue;
				}
			}

			if (!canWalk(dir, getCollisionFlag(dest), getCollisionFlag(neighbour)))
			{
				continue;
			}

			out.add(neighbour);
		}

		return out;
	}

	public static List<WorldPoint> getVisitedTiles(Positionable destination)
	{
		Player local = Static.getClient().getLocalPlayer();
		WorldPoint dest = destination instanceof WorldPoint ? (WorldPoint) destination : destination.getWorldLocation();
		if (local == null || !dest.isInScene(Static.getClient()))
		{
			return Collections.emptyList();
		}

		List<WorldPoint> visitedTiles = new ArrayList<>();
		LinkedList<WorldPoint> queue = new LinkedList<>();

		if (local.getWorldLocation().getPlane() != dest.getPlane())
		{
			return visitedTiles;
		}

		queue.add(local.getWorldLocation());

		while (!queue.isEmpty())
		{
			if (visitedTiles.size() > MAX_ATTEMPTED_TILES)
			{
				return visitedTiles;
			}

			WorldPoint current = queue.pop();
			visitedTiles.add(current);

			if (current.equals(dest))
			{
				return visitedTiles;
			}

			List<WorldPoint> neighbours = getNeighbours(destination, current)
					.stream().filter(x -> !visitedTiles.contains(x) && !queue.contains(x))
					.collect(Collectors.toList());
			queue.addAll(neighbours);
		}

		return visitedTiles;
	}

	/*
	 * Temp, for compatibility
	 */
	public static List<WorldPoint> getVisitedTiles(Locatable locatable)
	{
		return getVisitedTiles((Positionable) locatable);
	}

	/*
	 * Temp, for compatibility
	 */
	public static List<WorldPoint> getVisitedTiles(WorldPoint worldPoint)
	{
		return getVisitedTiles((Positionable) worldPoint);
	}

	public static boolean isInteractable(Locatable locatable)
	{
		return getVisitedTiles(locatable).contains(locatable.getWorldLocation());
	}

	public static boolean isWalkable(WorldPoint worldPoint)
	{
		return getVisitedTiles(worldPoint).contains(worldPoint);
	}
}

package net.unethicalite.api.coords;

import net.unethicalite.api.commons.Rand;
import net.unethicalite.api.entities.Players;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

public class RectangularArea implements Area
{
	@Getter
	private final int minX;
	@Getter
	private final int maxX;
	@Getter
	private final int minY;
	@Getter
	private final int maxY;
	@Getter
	private final int plane;

	public RectangularArea(int x1, int y1, int x2, int y2, int plane)
	{
		this.plane = plane;

		if (x1 <= x2)
		{
			minX = x1;
			maxX = x2;
		}
		else
		{
			minX = x2;
			maxX = x1;
		}

		if (y1 <= y2)
		{
			minY = y1;
			maxY = y2;
		}
		else
		{
			minY = y2;
			maxY = y1;
		}
	}

	public RectangularArea(int x1, int y1, int x2, int y2)
	{
		this(x1, y1, x2, y2, 0);
	}

	public RectangularArea(WorldPoint sw, int width, int height)
	{
		this(sw.getX(), sw.getY(), sw.getX() + width, sw.getY() + height, sw.getPlane());
	}

	public RectangularArea(WorldPoint sw, WorldPoint ne)
	{
		this(sw.getX(), sw.getY(), ne.getX(), ne.getY(), sw.getPlane());
	}

	@Override
	public WorldPoint getRandomTile()
	{
		return new WorldPoint(Rand.nextInt(minX, maxX), Rand.nextInt(minY, maxY), plane);
	}

	public WorldPoint getCenter()
	{
		return new WorldPoint((minX + maxX) / 2, (minY + maxY) / 2, plane);
	}

	public WorldPoint getNearest()
	{
		final WorldPoint current = Players.getLocal().getWorldLocation();

		if (contains(current))
		{
			return current;
		}

		int x;

		if (current.getX() <= minX)
		{
			x = minX;
		}
		else if (current.getX() >= maxX)
		{
			x = maxX;
		}
		else
		{
			x = current.getX();
		}

		int y;

		if (current.getY() <= minY)
		{
			y = minY;
		}
		else if (current.getY() >= maxY)
		{
			y = maxY;
		}
		else
		{
			y = current.getY();
		}

		return new WorldPoint(x, y, plane);
	}

	@Override
	public boolean contains(WorldPoint worldPoint)
	{
		if (worldPoint.getPlane() == -1 || worldPoint.getPlane() != plane)
		{
			return false;
		}

		int x = worldPoint.getX();
		int y = worldPoint.getY();
		return x >= minX && y >= minY && x <= maxX && y <= maxY;
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

public enum Reduction
{
    AND,
    OR,
}

package net.unethicalite.api.coords;

import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.client.Static;

@Value
public class RegionPoint
{
	int x;
	int y;
	int plane;
	int regionId;

	// region > world
	public WorldPoint toWorld()
	{
		return WorldPoint.fromRegion(regionId, x, y, plane);
	}

	// region > world > scene
	public ScenePoint toScene()
	{
		return ScenePoint.fromWorld(toWorld());
	}

	public int distanceTo(RegionPoint other)
	{
		if (other.regionId != regionId || other.plane != plane)
		{
			return Integer.MAX_VALUE;
		}

		return (int) Math.sqrt(Math.pow(other.x - x, 2) + Math.pow(other.y - y, 2));
	}

	// scene > world > region
	public static RegionPoint fromScene(ScenePoint scenePoint)
	{
		Client client = Static.getClient();
		WorldPoint world = new WorldPoint(client.getBaseX() + scenePoint.getX(), client.getBaseY() + scenePoint.getY(), scenePoint.getPlane());
		return fromWorld(world);
	}

	// world > region
	public static RegionPoint fromWorld(WorldPoint worldPoint)
	{
		return new RegionPoint(worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane(), worldPoint.getRegionID());
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import java.util.function.Supplier;

public interface Requirement extends Supplier<Boolean>
{

}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import lombok.Value;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

@Value
public class Requirements
{
    List<ItemRequirement> itemRequirements = new ArrayList<>();
    List<SkillRequirement> skillRequirements = new ArrayList<>();
    List<VarRequirement> varRequirements = new ArrayList<>();
    List<QuestRequirement> questRequirements = new ArrayList<>();
    List<WorldRequirement> worldRequirements = new ArrayList<>();

    public boolean fulfilled()
    {
        List<Requirement> all = new ArrayList<>();
        all.addAll(itemRequirements);
        all.addAll(skillRequirements);
        all.addAll(varRequirements);
        all.addAll(questRequirements);
        all.addAll(worldRequirements);
        return all.stream().allMatch(Supplier::get);
    }
}

package net.unethicalite.api.script.blocking_events;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

public class ResizableEvent extends BlockingEvent
{
	@Override
	public boolean validate()
	{
		Client client = Static.getClient();
		if (Game.getState() != GameState.LOGGED_IN)
		{
			return false;
		}

		return client.getWindowedMode() != 1 || client.getPreferences().getWindowMode() != 1;
	}

	@Override
	public int loop()
	{
		Client client = Static.getClient();
		if (client.getWindowedMode() != 1)
		{
			client.setWindowedMode(1);
			return 1000;
		}

		if (client.getPreferences().getWindowMode() != 1)
		{
			client.getPreferences().setWindowMode(1);
		}

		return 1000;
	}
}

package net.unethicalite.api.magic;

import net.unethicalite.api.items.Equipment;
import net.unethicalite.api.items.Inventory;
import net.runelite.api.Item;
import net.runelite.api.ItemID;

import java.util.Arrays;

public enum Rune
{
	AIR(ItemID.AIR_RUNE, "Air", "Smoke", "Mist", "Dust"),
	EARTH(ItemID.EARTH_RUNE, "Earth", "Lava", "Mud", "Dust"),
	FIRE(ItemID.FIRE_RUNE, "Fire", "Lava", "Smoke", "Steam"),
	WATER(ItemID.WATER_RUNE, "Water", "Mud", "Steam", "Mist"),
	MIND(ItemID.MIND_RUNE, "Mind"),
	BODY(ItemID.BODY_RUNE, "Body"),
	COSMIC(ItemID.COSMIC_RUNE, "Cosmic"),
	CHAOS(ItemID.CHAOS_RUNE, "Chaos"),
	NATURE(ItemID.NATURE_RUNE, "Nature"),
	LAW(ItemID.LAW_RUNE, "Law"),
	DEATH(ItemID.DEATH_RUNE, "Death"),
	ASTRAL(ItemID.ASTRAL_RUNE, "Astral"),
	BLOOD(ItemID.BLOOD_RUNE, "Blood"),
	SOUL(ItemID.SOUL_RUNE, "Soul"),
	WRATH(ItemID.WRATH_RUNE, "Wrath");

	private final int runeId;
	private final String[] runeNames;

	Rune(int runeId, String... runeNames)
	{
		this.runeId = runeId;
		this.runeNames = runeNames;
	}

	public String[] getRuneNames()
	{
		return runeNames;
	}

	public int getRuneId()
	{
		return runeId;
	}

	public int getQuantity()
	{
		if (isStaffEquipped() || isTomeEquipped())
		{
			return Integer.MAX_VALUE;
		}

		Item rune = Inventory.getFirst(x -> x.getName() != null && x.getName().contains("rune") &&
				Arrays.stream(runeNames)
						.anyMatch(name -> x.getId() == runeId || x.getName().contains(name)));
		if (rune == null)
		{
			return RunePouch.getQuantity(this);
		}

		return rune.getQuantity() + RunePouch.getQuantity(this);
	}

	private boolean isStaffEquipped()
	{
		return Equipment.contains(x -> x.getName() != null
				&& x.getName().toLowerCase().contains("staff")
				&& Arrays.stream(runeNames).anyMatch(n -> x.getName().toLowerCase().contains(n.toLowerCase())));
	}

	private boolean isTomeEquipped()
	{
		return Equipment.contains(x -> x.getName() != null
				&& x.getName().startsWith("Tome of")
				&& !x.getName().endsWith("(empty")
				&& Arrays.stream(runeNames).anyMatch(n -> x.getName().toLowerCase().contains(n.toLowerCase())));
	}
}

package net.unethicalite.api.magic;

import net.unethicalite.api.game.Vars;
import net.unethicalite.api.items.Inventory;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import java.util.Arrays;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import static net.runelite.api.Varbits.RUNE_POUCH_AMOUNT1;
import static net.runelite.api.Varbits.RUNE_POUCH_AMOUNT2;
import static net.runelite.api.Varbits.RUNE_POUCH_AMOUNT3;
import static net.runelite.api.Varbits.RUNE_POUCH_AMOUNT4;
import static net.runelite.api.Varbits.RUNE_POUCH_RUNE1;
import static net.runelite.api.Varbits.RUNE_POUCH_RUNE2;
import static net.runelite.api.Varbits.RUNE_POUCH_RUNE3;
import static net.runelite.api.Varbits.RUNE_POUCH_RUNE4;

@Slf4j
public class RunePouch
{
	public enum RuneSlot
	{
		FIRST(RUNE_POUCH_RUNE1, RUNE_POUCH_AMOUNT1),
		SECOND(RUNE_POUCH_RUNE2, RUNE_POUCH_AMOUNT2),
		THIRD(RUNE_POUCH_RUNE3, RUNE_POUCH_AMOUNT3),
		FOURTH(RUNE_POUCH_RUNE4, RUNE_POUCH_AMOUNT4);

		private final int type;
		private final int quantityVarbitIdx;

		private final LoadingCache<Integer, Integer> VARBIT_CACHE = CacheBuilder.newBuilder()
				.expireAfterWrite(1, TimeUnit.SECONDS)
				.build(new CacheLoader<>()
				{
					@Override
					public Integer load(@NotNull Integer type)
					{
						return Vars.getBit(type);
					}
				});

		RuneSlot(int type, int quantityVarbitIdx)
		{
			this.type = type;
			this.quantityVarbitIdx = quantityVarbitIdx;
		}

		public int getType()
		{
			return type;
		}

		public int getQuantityVarbitIdx()
		{
			return quantityVarbitIdx;
		}

		public int getVarbit()
		{
			try
			{
				return VARBIT_CACHE.get(type);
			}
			catch (ExecutionException e)
			{
				log.error("Failed to get cached varbit", e);
				return 0;
			}
		}

		public String getRuneName()
		{
			switch (getVarbit())
			{
				case 1:
					return "Air rune";
				case 2:
					return "Water rune";
				case 3:
					return "Earth rune";
				case 4:
					return "Fire rune";
				case 5:
					return "Mind rune";
				case 6:
					return "Chaos rune";
				case 7:
					return "Death rune";
				case 8:
					return "Blood rune";
				case 9:
					return "Cosmic rune";
				case 10:
					return "Nature rune";
				case 11:
					return "Law rune";
				case 12:
					return "Body rune";
				case 13:
					return "Soul rune";
				case 14:
					return "Astral rune";
				case 15:
					return "Mist rune";
				case 16:
					return "Mud rune";
				case 17:
					return "Dust rune";
				case 18:
					return "Lava rune";
				case 19:
					return "Steam rune";
				case 20:
					return "Smoke rune";
				default:
					return null;
			}
		}

		public int getQuantity()
		{
			return Vars.getBit(quantityVarbitIdx);
		}
	}

	public static int getQuantity(Rune rune)
	{
		if (!hasPouch())
		{
			return 0;
		}

		RuneSlot runeSlot =
				Arrays.stream(RuneSlot.values()).filter(x -> Arrays.stream(rune.getRuneNames())
								.anyMatch(name -> x.getRuneName() != null && x.getRuneName().startsWith(name)))
						.findFirst()
						.orElse(null);

		if (runeSlot == null)
		{
			return 0;
		}

		return runeSlot.getQuantity();
	}

	public static boolean hasPouch()
	{
		return Inventory.getFirst("Rune pouch", "Divine rune pouch") != null;
	}
}

package net.unethicalite.api.magic;

import lombok.Value;

@Value
public class RuneRequirement
{
    int quantity;
    Rune rune;

    public boolean meetsRequirements()
    {
        return rune.getQuantity() >= quantity;
    }
}

package net.unethicalite.api.coords;


import lombok.Value;

@Value
public class SceneArea
{
	int x;
	int y;
	int width;
	int height;
	int plane;

	public boolean contains(ScenePoint point)
	{
		if (point.getPlane() != plane)
		{
			return false;
		}

		return point.getX() >= x && point.getX() <= x + width && point.getY() >= y && point.getY() <= y + height;
	}
}

package net.unethicalite.api.query.entities;

import net.unethicalite.api.SceneEntity;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.query.Query;
import net.unethicalite.api.query.results.SceneEntityQueryResults;
import net.runelite.api.Locatable;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.ArrayUtils;

import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;

public abstract class SceneEntityQuery<T extends SceneEntity, Q extends SceneEntityQuery<T, Q>>
		extends Query<T, Q, SceneEntityQueryResults<T>>
{
	private Integer maxDistance = null;
	private WorldPoint distanceSrc = null;
	private int[] ids = null;
	private String[] names = null;
	private String[] actions = null;
	private WorldPoint[] locations = null;
	private LocalPoint[] localLocations = null;

	protected SceneEntityQuery(Supplier<List<T>> supplier)
	{
		super(supplier);
	}

	public Q ids(int... ids)
	{
		this.ids = ids;
		return (Q) this;
	}

	public Q names(String... names)
	{
		this.names = names;
		return (Q) this;
	}

	public Q actions(String... actions)
	{
		this.actions = actions;
		return (Q) this;
	}

	public Q locations(WorldPoint... locations)
	{
		this.locations = locations;
		return (Q) this;
	}

	public Q localLocations(LocalPoint... localLocations)
	{
		this.localLocations = localLocations;
		return (Q) this;
	}

	public Q distance(Locatable source, int maxDistance)
	{
		return this.distance(source.getWorldLocation(), maxDistance);
	}

	public Q distance(WorldPoint source, int maxDistance)
	{
		this.distanceSrc = source;
		this.maxDistance = maxDistance;
		return (Q) this;
	}

	public Q distance(int maxDistance)
	{
		this.maxDistance = maxDistance;
		return (Q) this;
	}

	@Override
	public boolean test(T t)
	{
		if (ids != null && !ArrayUtils.contains(ids, t.getId()))
		{
			return false;
		}

		if (names != null && !ArrayUtils.contains(names, t.getName()))
		{
			return false;
		}

		if (locations != null && !ArrayUtils.contains(locations, t.getWorldLocation()))
		{
			return false;
		}

		if (localLocations != null && !ArrayUtils.contains(localLocations, t.getLocalLocation()))
		{
			return false;
		}

		if (actions != null && Arrays.stream(actions).noneMatch(Predicates.texts(t.getActions())))
		{
			return false;
		}

		if (maxDistance != null)
		{
			if (distanceSrc == null)
			{
				distanceSrc = Players.getLocal().getWorldLocation();
			}

			if (distanceSrc.distanceTo(t.getWorldLocation()) > maxDistance)
			{
				return false;
			}
		}

		return super.test(t);
	}
}

package net.unethicalite.api.query.results;

import net.unethicalite.api.SceneEntity;
import net.unethicalite.api.entities.Players;
import net.runelite.api.Locatable;
import net.runelite.api.coords.WorldPoint;

import java.util.Comparator;
import java.util.List;

public class SceneEntityQueryResults<T extends SceneEntity> extends QueryResults<T, SceneEntityQueryResults<T>>
{
	public SceneEntityQueryResults(List<T> results)
	{
		super(results);
	}

	public SceneEntityQueryResults<T> sortedByDistance(WorldPoint to)
	{
		return sorted(Comparator.comparingDouble(entity -> entity.distanceTo(to)));
	}

	public SceneEntityQueryResults<T> sortedByDistance(Locatable to)
	{
		return sortedByDistance(to.getWorldLocation());
	}

	public SceneEntityQueryResults<T> sortedByDistance()
	{
		return sortedByDistance(Players.getLocal());
	}

	public T nearest()
	{
		return sortedByDistance().first();
	}

	public T nearest(Locatable to)
	{
		return sortedByDistance(to).first();
	}

	public T nearest(WorldPoint to)
	{
		return sortedByDistance(to).first();
	}

	public T farthest()
	{
		return sortedByDistance().last();
	}

	public T farthest(Locatable locatable)
	{
		return sortedByDistance(locatable).last();
	}

	public T farthest(WorldPoint to)
	{
		return sortedByDistance(to).last();
	}
}

package net.unethicalite.api.coords;

import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.client.Static;

@Value
public class ScenePoint
{
	int x;
	int y;
	int plane;

	// scene > world
	public WorldPoint toWorld()
	{
		Client client = Static.getClient();
		return new WorldPoint(x + client.getBaseX(), y + client.getBaseY(), plane);
	}

	// scene > world > region
	public RegionPoint toRegion()
	{
		return RegionPoint.fromWorld(toWorld());
	}

	public int distanceTo(ScenePoint other)
	{
		if (other.plane != plane)
		{
			return Integer.MAX_VALUE;
		}

		return (int) Math.sqrt(Math.pow(other.x - x, 2) + Math.pow(other.y - y, 2));
	}

	// region > world > scene
	public static ScenePoint fromRegion(RegionPoint regionPoint)
	{
		return fromWorld(regionPoint.toWorld());
	}

	// world > scene
	public static ScenePoint fromWorld(WorldPoint worldPoint)
	{
		Client client = Static.getClient();
		return new ScenePoint(worldPoint.getX() - client.getBaseX(), worldPoint.getY() - client.getBaseY(), 0);
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.input.naturalmouse.api.MouseInfoAccessor;
import net.unethicalite.api.input.naturalmouse.api.SystemCalls;

import java.awt.Dimension;
import java.awt.Point;

/**
 * This nature translates mouse coordinates to specified offset and screen dimension.
 * Internally it wraps the SystemCalls and MouseInfoAccessor in proxies which handle the translations.
 */
public class ScreenAdjustedNature extends DefaultMouseMotionNature
{
	private final Point offset;
	private final Dimension screenSize;

	public ScreenAdjustedNature(int x, int y, int x2, int y2)
	{
		this(new Dimension(x2 - x, y2 - y), new Point(x, y));
		if (y2 <= y || x2 <= x)
		{
			throw new IllegalArgumentException("Invalid range " + x + " " + y + " " + x2 + " " + y2);
		}
	}

	public ScreenAdjustedNature(Dimension screenSize, Point mouseOffset)
	{
		this.screenSize = screenSize;
		this.offset = mouseOffset;
	}

	@Override
	public void setMouseInfo(MouseInfoAccessor mouseInfo)
	{
		super.setMouseInfo(new ProxyMouseInfo(mouseInfo));
	}

	@Override
	public void setSystemCalls(SystemCalls systemCalls)
	{
		super.setSystemCalls(new ProxySystemCalls(systemCalls));
	}

	private class ProxyMouseInfo implements MouseInfoAccessor
	{
		private final MouseInfoAccessor underlying;
		// This implementation reuses the point.
		private final Point p = new Point();

		public ProxyMouseInfo(MouseInfoAccessor underlying)
		{
			this.underlying = underlying;
		}

		@Override
		public Point getMousePosition()
		{
			Point realPointer = underlying.getMousePosition();
			p.setLocation(realPointer.x - offset.x, realPointer.y - offset.y);
			return p;
		}
	}

	private class ProxySystemCalls implements SystemCalls
	{
		private final SystemCalls underlying;

		public ProxySystemCalls(SystemCalls underlying)
		{
			this.underlying = underlying;
		}

		@Override
		public long currentTimeMillis()
		{
			return underlying.currentTimeMillis();
		}

		@Override
		public void sleep(long time)
		{
			underlying.sleep(time);
		}

		@Override
		public Dimension getScreenSize()
		{
			return screenSize;
		}

		@Override
		public void setMousePosition(int x, int y)
		{
			underlying.setMousePosition(x + offset.x, y + offset.y);
		}
	}
}

package net.unethicalite.api.plugins;

import net.unethicalite.api.game.Game;
import net.unethicalite.api.script.blocking_events.BlockingEvent;
import net.unethicalite.api.script.blocking_events.BlockingEventManager;
import net.unethicalite.client.Static;
import net.unethicalite.client.minimal.plugins.MinimalPluginChanged;
import net.unethicalite.client.minimal.plugins.MinimalPluginState;
import net.unethicalite.api.script.paint.Paint;
import lombok.Getter;
import net.runelite.api.GameState;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;

public abstract class Script extends LoopedPlugin
{
	protected final Logger logger;

	private boolean restart;
	private boolean paused;
	private boolean onLogin;

	public Script()
	{
		logger = LoggerFactory.getLogger(getClass());
	}

	@Inject
	@Getter
	private Paint paint;

	@Getter
	private final BlockingEventManager blockingEventManager = new BlockingEventManager();

	protected abstract int loop();

	public abstract void onStart(String... args);

	public void onStop()
	{

	}

	public void onLogin()
	{

	}

	public int outerLoop()
	{
		int loopSleep;
		if (paused)
		{
			return 1000;
		}

		if (restart)
		{
			restart = false;
			Static.getClient().getCallbacks().post(new MinimalPluginChanged(this, MinimalPluginState.RESTARTING));
			return 1000;
		}

		if (Game.getState() == GameState.LOGGED_IN && !onLogin)
		{
			onLogin = true;
			onLogin();
			return 100;
		}

		if (!blockingEventManager.getBlockingEvents().isEmpty())
		{
			for (BlockingEvent event : blockingEventManager.getBlockingEvents())
			{
				if (event.validate())
				{
					return event.loop();
				}
			}
		}

		loopSleep = loop();
		return loopSleep != 0 ? loopSleep : 1000;
	}

	public void pauseScript()
	{
		paused = !paused;
		if (!paused)
		{
			Static.getClient().getCallbacks().post(new MinimalPluginChanged(this, MinimalPluginState.STARTED));
		}
		else
		{
			Static.getClient().getCallbacks().post(new MinimalPluginChanged(this, MinimalPluginState.PAUSED));
		}
	}

	public boolean isRestart()
	{
		return restart;
	}

	public void setRestart(boolean restart)
	{
		this.restart = restart;
	}

	public boolean isPaused()
	{
		return paused;
	}

	public void setPaused(boolean paused)
	{
		this.paused = paused;
	}
}

package net.unethicalite.api.plugins;

import net.runelite.client.config.Config;
import net.runelite.client.plugins.Plugin;

public abstract class SettingsPlugin extends Plugin
{
	public abstract Config getConfig();

	public abstract String getPluginName();

	public abstract String getPluginDescription();

	public abstract String[] getPluginTags();
}

package net.unethicalite.api.items;

import net.unethicalite.api.widgets.Widgets;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;

public class Shop
{
	private static final Supplier<Widget> SHOP = () -> Widgets.get(300, 0);
	private static final Supplier<Widget> SHOP_ITEMS = () -> Widgets.get(300, 16);
	private static final Supplier<Widget> INVENTORY = () -> Widgets.get(301, 0);

	public static boolean isOpen()
	{
		return Widgets.isVisible(SHOP.get());
	}

	public static int getStock(int itemId)
	{
		Widget items = SHOP_ITEMS.get();
		if (!Widgets.isVisible(items))
		{
			return 0;
		}

		Widget[] children = items.getChildren();
		if (children == null)
		{
			return 0;
		}

		return Arrays.stream(children)
				.filter(child -> child.getItemId() == itemId)
				.mapToInt(Widget::getItemQuantity)
				.sum();
	}

	public static void buyOne(int itemId)
	{
		buy(itemId, 1);
	}

	public static void buyOne(String itemName)
	{
		buy(itemName, 1);
	}

	public static void buyFive(int itemId)
	{
		buy(itemId, 5);
	}

	public static void buyFive(String itemName)
	{
		buy(itemName, 5);
	}

	public static void buyTen(int itemId)
	{
		buy(itemId, 10);
	}

	public static void buyTen(String itemName)
	{
		buy(itemName, 10);
	}

	public static void buyFifty(int itemId)
	{
		buy(itemId, 50);
	}

	public static void buyFifty(String itemName)
	{
		buy(itemName, 50);
	}

	public static void sellOne(int itemId)
	{
		sell(itemId, 1);
	}

	public static void sellFive(int itemId)
	{
		sell(itemId, 5);
	}

	public static void sellTen(int itemId)
	{
		sell(itemId, 10);
	}

	public static void sellFifty(int itemId)
	{
		sell(itemId, 50);
	}

	public static List<Integer> getItems()
	{
		List<Integer> out = new ArrayList<>();
		Widget container = SHOP_ITEMS.get();
		if (container == null)
		{
			return out;
		}

		Widget[] items = container.getChildren();
		if (items == null)
		{
			return out;
		}

		for (Widget item : items)
		{
			if (item.getItemId() != -1)
			{
				out.add(item.getItemId());
			}
		}

		return out;
	}

	private static void buy(int itemId, int amount)
	{
		exchange(itemId, amount, SHOP_ITEMS.get());
	}

	private static void buy(String itemName, int amount)
	{
		exchange(itemName, amount, SHOP_ITEMS.get());
	}

	private static void sell(int itemId, int amount)
	{
		exchange(itemId, amount, INVENTORY.get());
	}

	private static void exchange(int itemId, int amount, Widget container)
	{
		if (container == null)
		{
			return;
		}

		Widget[] items = container.getChildren();
		if (items == null)
		{
			return;
		}

		for (Widget item : items)
		{
			if (item.getItemId() == itemId)
			{
				String action = Arrays.stream(item.getActions())
						.filter(x -> x != null && x.contains(String.valueOf(amount)))
						.findFirst()
						.orElse(null);
				if (action == null)
				{
					return;
				}

				item.interact(action);
				return;
			}
		}
	}

	private static void exchange(String itemName, int amount, Widget container)
	{
		if (container == null)
		{
			return;
		}

		Widget[] items = container.getChildren();
		if (items == null)
		{
			return;
		}

		for (Widget item : items)
		{
			var nestedName = StringUtils.substringBetween(item.getName(), ">", "<");
			if (nestedName != null && nestedName.equals(itemName))
			{
				String action = Arrays.stream(item.getActions())
						.filter(x -> x != null && x.contains(String.valueOf(amount)))
						.findFirst()
						.orElse(null);
				if (action == null)
				{
					return;
				}

				item.interact(action);
				return;
			}
		}
	}
}

package net.unethicalite.api.input.naturalmouse.support;

import net.unethicalite.api.input.naturalmouse.api.DeviationProvider;

public class SinusoidalDeviationProvider implements DeviationProvider
{
	public static final int DEFAULT_SLOPE_DIVIDER = 10;
	private final double slopeDivider;

	public SinusoidalDeviationProvider(double slopeDivider)
	{
		this.slopeDivider = slopeDivider;
	}

	@Override
	public DoublePoint getDeviation(double totalDistanceInPixels, double completionFraction)
	{
		double deviationFunctionResult = (1 - Math.cos(completionFraction * Math.PI * 2)) / 2;

		double deviationX = totalDistanceInPixels / slopeDivider;
		double deviationY = totalDistanceInPixels / slopeDivider;

		return new DoublePoint(deviationFunctionResult * deviationX, deviationFunctionResult * deviationY);
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import lombok.Value;
import net.runelite.api.Skill;
import net.unethicalite.api.game.Skills;

@Value
public class SkillRequirement implements Requirement
{
    Skill skill;
    int level;

    @Override
    public Boolean get()
    {
        return Skills.getLevel(skill) >= level;
    }
}

package net.unethicalite.api.game;

import net.runelite.api.Skill;
import net.unethicalite.client.Static;

public class Skills
{

	public static int getBoostedLevel(Skill skill)
	{
		return Static.getClient().getBoostedSkillLevel(skill);
	}

	public static int getLevel(Skill skill)
	{
		return Static.getClient().getRealSkillLevel(skill);
	}

	public static int getExperience(Skill skill)
	{
		return Static.getClient().getSkillExperience(skill);
	}
}

package net.unethicalite.api.input.naturalmouse.api;

import net.unethicalite.api.input.naturalmouse.support.Flow;
import net.unethicalite.api.input.naturalmouse.util.Pair;

/**
 * SpeedManager controls how long does it take to complete a mouse movement and within that
 * time how slow or fast the cursor is moving at a particular moment, the flow.
 * Flow controls how jagged or smooth, accelerating or decelerating, the movement is.
 */
public interface SpeedManager
{

	/**
	 * Get the SpeedFlow object, which contains Flow and planned time for mouse movement in ms.
	 *
	 * @param distance the distance from where the cursor is now to the destination point   *
	 * @return the SpeedFlow object, which details are a SpeedManager implementation decision.
	 */
	Pair<Flow, Long> getFlowWithTime(double distance);
}

package net.unethicalite.api.magic;

import net.unethicalite.api.Interactable;
import net.runelite.api.Item;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.TileItem;
import net.runelite.api.TileObject;
import net.runelite.api.widgets.WidgetInfo;

public interface Spell
{
	int getLevel();

	WidgetInfo getWidget();

	boolean canCast();

	default void cast()
	{
		Magic.cast(this);
	}

	default void castOn(Interactable interactable)
	{
		if (interactable instanceof Item)
		{
			Magic.cast(this, (Item) interactable);
			return;
		}

		if (interactable instanceof NPC)
		{
			Magic.cast(this, (NPC) interactable);
			return;
		}

		if (interactable instanceof Player)
		{
			Magic.cast(this, (Player) interactable);
			return;
		}

		if (interactable instanceof TileItem)
		{
			Magic.cast(this, (TileItem) interactable);
			return;
		}

		if (interactable instanceof TileObject)
		{
			Magic.cast(this, (TileObject) interactable);
		}
	}
}

package net.unethicalite.api.magic;

import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.game.Skills;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.game.Worlds;
import net.unethicalite.api.items.Equipment;
import net.unethicalite.api.items.Inventory;

import java.util.Arrays;

public enum SpellBook
{
	STANDARD(0),
	ANCIENT(1),
	LUNAR(2),
	NECROMANCY(3);

	private static final int SPELLBOOK_VARBIT = 4070;

	private final int varbitValue;

	SpellBook(int varbitValue)
	{
		this.varbitValue = varbitValue;
	}

	public static SpellBook getCurrent()
	{
		return Arrays.stream(values()).filter(x -> Vars.getBit(SPELLBOOK_VARBIT) == x.varbitValue)
				.findFirst().orElse(null);
	}

	public enum Standard implements Spell
	{
		// Teleport spells
		HOME_TELEPORT(
				0,
				WidgetInfo.SPELL_LUMBRIDGE_HOME_TELEPORT,
				false
		),
		VARROCK_TELEPORT(
				25,
				WidgetInfo.SPELL_VARROCK_TELEPORT,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(1, Rune.FIRE),
				new RuneRequirement(1, Rune.LAW)
		),
		LUMBRIDGE_TELEPORT(
				31,
				WidgetInfo.SPELL_LUMBRIDGE_TELEPORT,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(1, Rune.EARTH),
				new RuneRequirement(1, Rune.LAW)
		),
		FALADOR_TELEPORT(
				37,
				WidgetInfo.SPELL_FALADOR_TELEPORT,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(1, Rune.WATER),
				new RuneRequirement(1, Rune.LAW)
		),
		TELEPORT_TO_HOUSE(
				40,
				WidgetInfo.SPELL_TELEPORT_TO_HOUSE,
				true,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(1, Rune.EARTH),
				new RuneRequirement(1, Rune.LAW)
		),
		CAMELOT_TELEPORT(
				45,
				WidgetInfo.SPELL_CAMELOT_TELEPORT,
				true,
				new RuneRequirement(5, Rune.AIR),
				new RuneRequirement(1, Rune.LAW)
		),
		ARDOUGNE_TELEPORT(
				51,
				WidgetInfo.SPELL_ARDOUGNE_TELEPORT,
				true,
				new RuneRequirement(2, Rune.WATER),
				new RuneRequirement(2, Rune.LAW)
		),
		WATCHTOWER_TELEPORT(
				58,
				WidgetInfo.SPELL_WATCHTOWER_TELEPORT,
				true,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(2, Rune.LAW)
		),
		TROLLHEIM_TELEPORT(
				61,
				WidgetInfo.SPELL_TROLLHEIM_TELEPORT,
				true,
				new RuneRequirement(2, Rune.FIRE),
				new RuneRequirement(2, Rune.LAW)
		),
		TELEPORT_TO_APE_ATOLL(
				64,
				WidgetInfo.SPELL_TELEPORT_TO_APE_ATOLL,
				true,
				new RuneRequirement(2, Rune.FIRE),
				new RuneRequirement(2, Rune.WATER),
				new RuneRequirement(2, Rune.LAW)
		),
		TELEPORT_TO_KOUREND(
				69,
				WidgetInfo.SPELL_TELEPORT_TO_KOUREND,
				true,
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(2, Rune.SOUL),
				new RuneRequirement(2, Rune.LAW)
		),
		TELEOTHER_LUMBRIDGE(
				74,
				WidgetInfo.SPELL_TELEOTHER_LUMBRIDGE,
				true,
				new RuneRequirement(1, Rune.EARTH),
				new RuneRequirement(1, Rune.LAW),
				new RuneRequirement(1, Rune.SOUL)
		),
		TELEOTHER_FALADOR(
				82,
				WidgetInfo.SPELL_TELEOTHER_FALADOR,
				true,
				new RuneRequirement(1, Rune.WATER),
				new RuneRequirement(1, Rune.LAW),
				new RuneRequirement(1, Rune.SOUL)
		),
		TELEPORT_TO_BOUNTY_TARGET(
				85,
				WidgetInfo.SPELL_BOUNTY_TARGET_TELEPORT,
				true,
				new RuneRequirement(1, Rune.CHAOS),
				new RuneRequirement(1, Rune.DEATH),
				new RuneRequirement(1, Rune.LAW)
		),
		TELEOTHER_CAMELOT(
				90,
				WidgetInfo.SPELL_TELEOTHER_CAMELOT,
				true,
				new RuneRequirement(1, Rune.LAW),
				new RuneRequirement(2, Rune.SOUL)
		),

		// Strike spells
		WIND_STRIKE(
				1,
				WidgetInfo.SPELL_WIND_STRIKE,
				false,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(1, Rune.MIND)
		),
		WATER_STRIKE(
				5,
				WidgetInfo.SPELL_WATER_STRIKE,
				false,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(1, Rune.WATER),
				new RuneRequirement(1, Rune.MIND)
		),
		EARTH_STRIKE(
				9,
				WidgetInfo.SPELL_EARTH_STRIKE,
				false,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(1, Rune.MIND)
		),
		FIRE_STRIKE(
				13,
				WidgetInfo.SPELL_FIRE_STRIKE,
				false,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(3, Rune.FIRE),
				new RuneRequirement(1, Rune.MIND)
		),

		// Bolt spells
		WIND_BOLT(
				17,
				WidgetInfo.SPELL_WIND_BOLT,
				false,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(1, Rune.CHAOS)
		),
		WATER_BOLT(
				23,
				WidgetInfo.SPELL_WATER_BOLT,
				false,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(2, Rune.WATER),
				new RuneRequirement(1, Rune.CHAOS)
		),
		EARTH_BOLT(
				29,
				WidgetInfo.SPELL_EARTH_BOLT,
				false,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(3, Rune.EARTH),
				new RuneRequirement(1, Rune.CHAOS)
		),
		FIRE_BOLT(
				35,
				WidgetInfo.SPELL_FIRE_BOLT,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(4, Rune.FIRE),
				new RuneRequirement(1, Rune.CHAOS)
		),

		// Blast spells
		WIND_BLAST(
				41,
				WidgetInfo.SPELL_WIND_BLAST,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(1, Rune.DEATH)
		),
		WATER_BLAST(
				47,
				WidgetInfo.SPELL_WATER_BLAST,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(3, Rune.WATER),
				new RuneRequirement(1, Rune.DEATH)
		),
		EARTH_BLAST(
				53,
				WidgetInfo.SPELL_EARTH_BLAST,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(4, Rune.EARTH),
				new RuneRequirement(1, Rune.DEATH)
		),
		FIRE_BLAST(
				59,
				WidgetInfo.SPELL_FIRE_BLAST,
				false,
				new RuneRequirement(4, Rune.AIR),
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(1, Rune.DEATH)
		),

		// Wave spells
		WIND_WAVE(
				62,
				WidgetInfo.SPELL_WIND_WAVE,
				true,
				new RuneRequirement(5, Rune.AIR),
				new RuneRequirement(1, Rune.BLOOD)
		),
		WATER_WAVE(
				65,
				WidgetInfo.SPELL_WATER_WAVE,
				true,
				new RuneRequirement(5, Rune.AIR),
				new RuneRequirement(7, Rune.WATER),
				new RuneRequirement(1, Rune.BLOOD)
		),
		EARTH_WAVE(
				70,
				WidgetInfo.SPELL_EARTH_WAVE,
				true,
				new RuneRequirement(5, Rune.AIR),
				new RuneRequirement(7, Rune.EARTH),
				new RuneRequirement(1, Rune.BLOOD)
		),
		FIRE_WAVE(
				75,
				WidgetInfo.SPELL_FIRE_WAVE,
				true,
				new RuneRequirement(5, Rune.AIR),
				new RuneRequirement(7, Rune.FIRE),
				new RuneRequirement(1, Rune.BLOOD)
		),

		// Surge spells
		WIND_SURGE(
				81,
				WidgetInfo.SPELL_WIND_SURGE,
				true,
				new RuneRequirement(7, Rune.AIR),
				new RuneRequirement(1, Rune.WRATH)
		),
		WATER_SURGE(
				85,
				WidgetInfo.SPELL_WATER_SURGE,
				true,
				new RuneRequirement(7, Rune.AIR),
				new RuneRequirement(10, Rune.WATER),
				new RuneRequirement(1, Rune.WRATH)
		),
		EARTH_SURGE(
				90,
				WidgetInfo.SPELL_EARTH_SURGE,
				true,
				new RuneRequirement(7, Rune.AIR),
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(1, Rune.WRATH)
		),
		FIRE_SURGE(
				95,
				WidgetInfo.SPELL_FIRE_SURGE,
				true,
				new RuneRequirement(7, Rune.AIR),
				new RuneRequirement(10, Rune.FIRE),
				new RuneRequirement(1, Rune.WRATH)
		),

		// God spells
		SARADOMIN_STRIKE(
				60,
				WidgetInfo.SPELL_SARADOMIN_STRIKE,
				true,
				new RuneRequirement(4, Rune.AIR),
				new RuneRequirement(2, Rune.FIRE),
				new RuneRequirement(2, Rune.BLOOD)
		),
		CLAWS_OF_GUTHIX(
				60,
				WidgetInfo.SPELL_CLAWS_OF_GUTHIX,
				true,
				new RuneRequirement(4, Rune.AIR),
				new RuneRequirement(1, Rune.FIRE),
				new RuneRequirement(2, Rune.BLOOD)
		),
		FLAMES_OF_ZAMORAK(
				60,
				WidgetInfo.SPELL_FLAMES_OF_ZAMORAK,
				true,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(4, Rune.FIRE),
				new RuneRequirement(2, Rune.BLOOD)
		),

		// Other combat spells
		CRUMBLE_UNDEAD(
				39,
				WidgetInfo.SPELL_CRUMBLE_UNDEAD,
				false,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(1, Rune.CHAOS)
		),
		IBAN_BLAST(
				50,
				WidgetInfo.SPELL_IBAN_BLAST,
				true,
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(1, Rune.DEATH)
		),
		MAGIC_DART(
				50,
				WidgetInfo.SPELL_MAGIC_DART,
				true,
				new RuneRequirement(1, Rune.DEATH),
				new RuneRequirement(4, Rune.MIND)
		),

		// Curse spells
		CONFUSE(
				3,
				WidgetInfo.SPELL_CONFUSE,
				false,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(3, Rune.WATER),
				new RuneRequirement(1, Rune.BODY)
		),
		WEAKEN(
				11,
				WidgetInfo.SPELL_WEAKEN,
				false,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(3, Rune.WATER),
				new RuneRequirement(1, Rune.BODY)
		),
		CURSE(
				19,
				WidgetInfo.SPELL_CURSE,
				false,
				new RuneRequirement(3, Rune.EARTH),
				new RuneRequirement(2, Rune.WATER),
				new RuneRequirement(1, Rune.BODY)
		),
		BIND(
				20,
				WidgetInfo.SPELL_BIND,
				false,
				new RuneRequirement(3, Rune.EARTH),
				new RuneRequirement(3, Rune.WATER),
				new RuneRequirement(2, Rune.NATURE)
		),
		SNARE(
				50,
				WidgetInfo.SPELL_SNARE,
				false,
				new RuneRequirement(4, Rune.EARTH),
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(3, Rune.NATURE)
		),
		VULNERABILITY(
				66,
				WidgetInfo.SPELL_VULNERABILITY,
				true,
				new RuneRequirement(5, Rune.EARTH),
				new RuneRequirement(5, Rune.WATER),
				new RuneRequirement(1, Rune.SOUL)
		),
		ENFEEBLE(
				73,
				WidgetInfo.SPELL_ENFEEBLE,
				true,
				new RuneRequirement(8, Rune.EARTH),
				new RuneRequirement(8, Rune.WATER),
				new RuneRequirement(1, Rune.SOUL)
		),
		ENTANGLE(
				79,
				WidgetInfo.SPELL_ENTANGLE,
				true,
				new RuneRequirement(5, Rune.EARTH),
				new RuneRequirement(5, Rune.WATER),
				new RuneRequirement(4, Rune.NATURE)
		),
		STUN(
				80,
				WidgetInfo.SPELL_STUN,
				true,
				new RuneRequirement(12, Rune.EARTH),
				new RuneRequirement(12, Rune.WATER),
				new RuneRequirement(1, Rune.SOUL)
		),
		TELE_BLOCK(
				85,
				WidgetInfo.SPELL_TELE_BLOCK,
				false,
				new RuneRequirement(1, Rune.CHAOS),
				new RuneRequirement(1, Rune.DEATH),
				new RuneRequirement(1, Rune.LAW)
		),

		// Support spells
		CHARGE(
				80,
				WidgetInfo.SPELL_CHARGE,
				true,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(3, Rune.FIRE),
				new RuneRequirement(3, Rune.BLOOD)
		),

		// Utility spells
		BONES_TO_BANANAS(
				15,
				WidgetInfo.SPELL_BONES_TO_BANANAS,
				false,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(2, Rune.WATER),
				new RuneRequirement(1, Rune.NATURE)
		),
		LOW_LEVEL_ALCHEMY(
				21,
				WidgetInfo.SPELL_LOW_LEVEL_ALCHEMY,
				false,
				new RuneRequirement(3, Rune.FIRE),
				new RuneRequirement(1, Rune.NATURE)
		),
		SUPERHEAT_ITEM(
				43,
				WidgetInfo.SPELL_SUPERHEAT_ITEM,
				false,
				new RuneRequirement(4, Rune.FIRE),
				new RuneRequirement(1, Rune.NATURE)
		),
		HIGH_LEVEL_ALCHEMY(
				55,
				WidgetInfo.SPELL_HIGH_LEVEL_ALCHEMY,
				false,
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(1, Rune.NATURE)
		),
		BONES_TO_PEACHES(
				60,
				WidgetInfo.SPELL_BONES_TO_PEACHES,
				true,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(2, Rune.NATURE)
		),

		// Enchantment spells
		LVL_1_ENCHANT(
				7,
				WidgetInfo.SPELL_LVL_1_ENCHANT,
				false,
				new RuneRequirement(1, Rune.WATER),
				new RuneRequirement(1, Rune.COSMIC)
		),
		LVL_2_ENCHANT(
				27,
				WidgetInfo.SPELL_LVL_2_ENCHANT,
				false,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(1, Rune.COSMIC)
		),
		LVL_3_ENCHANT(
				49,
				WidgetInfo.SPELL_LVL_3_ENCHANT,
				false,
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(1, Rune.COSMIC)
		),
		CHARGE_WATER_ORB(
				56,
				WidgetInfo.SPELL_CHARGE_WATER_ORB,
				true,
				new RuneRequirement(30, Rune.WATER),
				new RuneRequirement(3, Rune.COSMIC)
		),
		LVL_4_ENCHANT(
				57,
				WidgetInfo.SPELL_LVL_4_ENCHANT,
				false,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(1, Rune.COSMIC)
		),
		CHARGE_EARTH_ORB(
				60,
				WidgetInfo.SPELL_CHARGE_EARTH_ORB,
				true,
				new RuneRequirement(30, Rune.EARTH),
				new RuneRequirement(3, Rune.COSMIC)
		),
		CHARGE_FIRE_ORB(
				63,
				WidgetInfo.SPELL_CHARGE_FIRE_ORB,
				true,
				new RuneRequirement(30, Rune.FIRE),
				new RuneRequirement(3, Rune.COSMIC)
		),
		CHARGE_AIR_ORB(
				66,
				WidgetInfo.SPELL_CHARGE_AIR_ORB,
				true,
				new RuneRequirement(30, Rune.AIR),
				new RuneRequirement(3, Rune.COSMIC)
		),
		LVL_5_ENCHANT(
				68,
				WidgetInfo.SPELL_LVL_5_ENCHANT,
				true,
				new RuneRequirement(15, Rune.EARTH),
				new RuneRequirement(15, Rune.WATER),
				new RuneRequirement(1, Rune.COSMIC)
		),
		LVL_6_ENCHANT(
				87,
				WidgetInfo.SPELL_LVL_6_ENCHANT,
				true,
				new RuneRequirement(20, Rune.EARTH),
				new RuneRequirement(20, Rune.FIRE),
				new RuneRequirement(1, Rune.COSMIC)
		),
		LVL_7_ENCHANT(
				93,
				WidgetInfo.SPELL_LVL_7_ENCHANT,
				true,
				new RuneRequirement(20, Rune.BLOOD),
				new RuneRequirement(20, Rune.SOUL),
				new RuneRequirement(1, Rune.COSMIC)
		),

		// Other spells
		TELEKINETIC_GRAB(
				31,
				WidgetInfo.SPELL_TELEKINETIC_GRAB,
				false,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(1, Rune.LAW)
		),
		;

		private final int level;
		private final WidgetInfo widgetInfo;
		private final boolean members;
		private final RuneRequirement[] requirements;

		Standard(int level, WidgetInfo widgetInfo, boolean members, RuneRequirement... requirements)
		{
			this.level = level;
			this.widgetInfo = widgetInfo;
			this.members = members;
			this.requirements = requirements;
		}

		@Override
		public int getLevel()
		{
			return level;
		}

		@Override
		public WidgetInfo getWidget()
		{
			return widgetInfo;
		}

		@Override
		public boolean canCast()
		{
			if (getCurrent() != STANDARD)
			{
				return false;
			}

			if (members && !Worlds.inMembersWorld())
			{
				return false;
			}

			if (this == HOME_TELEPORT)
			{
				return Magic.isHomeTeleportOnCooldown();
			}

			if (level > Skills.getLevel(Skill.MAGIC) || level > Skills.getBoostedLevel(Skill.MAGIC))
			{
				return false;
			}

			if (this == ARDOUGNE_TELEPORT && Vars.getVarp(165) < 30)
			{
				return false;
			}

			if (this == TROLLHEIM_TELEPORT && Vars.getVarp(335) < 110)
			{
				return false;
			}

			return haveEquipment() && haveItem() && haveRunesAvailable();
		}

		public boolean haveRunesAvailable()
		{
			for (RuneRequirement req : requirements)
			{
				if (!req.meetsRequirements())
				{
					return false;
				}
			}

			return true;
		}

		public boolean haveEquipment()
		{
			switch (this)
			{
				case IBAN_BLAST:
					return Equipment.contains(ItemID.IBANS_STAFF, ItemID.IBANS_STAFF_1410, ItemID.IBANS_STAFF_U);
				case MAGIC_DART:
					return Equipment.contains(ItemID.SLAYERS_STAFF_E, ItemID.SLAYERS_STAFF, ItemID.STAFF_OF_THE_DEAD, ItemID.STAFF_OF_THE_DEAD_23613, ItemID.TOXIC_STAFF_OF_THE_DEAD, ItemID.STAFF_OF_LIGHT, ItemID.STAFF_OF_BALANCE);
				case SARADOMIN_STRIKE:
					return Equipment.contains(ItemID.SARADOMIN_STAFF, ItemID.STAFF_OF_LIGHT);
				case FLAMES_OF_ZAMORAK:
					return Equipment.contains(ItemID.ZAMORAK_STAFF, ItemID.STAFF_OF_THE_DEAD, ItemID.STAFF_OF_THE_DEAD_23613, ItemID.TOXIC_STAFF_OF_THE_DEAD);
				case CLAWS_OF_GUTHIX:
					return Equipment.contains(ItemID.GUTHIX_STAFF, ItemID.VOID_KNIGHT_MACE, ItemID.STAFF_OF_BALANCE);
				default:
					return true;
			}
		}

		public boolean haveItem()
		{
			switch (this)
			{
				case TELEPORT_TO_APE_ATOLL:
					return Inventory.contains(ItemID.BANANA);
				case CHARGE_AIR_ORB:
				case CHARGE_WATER_ORB:
				case CHARGE_EARTH_ORB:
				case CHARGE_FIRE_ORB:
					return Inventory.contains(ItemID.UNPOWERED_ORB);
				default:
					return true;
			}
		}
	}

	public enum Ancient implements Spell
	{
		// Teleport spells
		EDGEVILLE_HOME_TELEPORT(
				0,
				WidgetInfo.SPELL_EDGEVILLE_HOME_TELEPORT
		),
		PADDEWWA_TELEPORT(
				54,
				WidgetInfo.SPELL_PADDEWWA_TELEPORT,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(1, Rune.FIRE),
				new RuneRequirement(2, Rune.LAW)
		),
		SENNTISTEN_TELEPORT(
				60,
				WidgetInfo.SPELL_SENNTISTEN_TELEPORT,
				new RuneRequirement(2, Rune.LAW),
				new RuneRequirement(1, Rune.SOUL)
		),
		KHARYRLL_TELEPORT(
				66,
				WidgetInfo.SPELL_KHARYRLL_TELEPORT,
				new RuneRequirement(2, Rune.LAW),
				new RuneRequirement(1, Rune.BLOOD)
		),
		LASSAR_TELEPORT(
				72,
				WidgetInfo.SPELL_LASSAR_TELEPORT,
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(2, Rune.LAW)
		),
		DAREEYAK_TELEPORT(
				78,
				WidgetInfo.SPELL_DAREEYAK_TELEPORT,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(3, Rune.FIRE),
				new RuneRequirement(2, Rune.LAW)
		),
		CARRALLANGER_TELEPORT(
				84,
				WidgetInfo.SPELL_CARRALLANGER_TELEPORT,
				new RuneRequirement(2, Rune.LAW),
				new RuneRequirement(2, Rune.SOUL)
		),
		BOUNTY_TARGET_TELEPORT(
				85,
				WidgetInfo.SPELL_BOUNTY_TARGET_TELEPORT,
				new RuneRequirement(1, Rune.CHAOS),
				new RuneRequirement(1, Rune.DEATH),
				new RuneRequirement(1, Rune.LAW)
		),
		ANNAKARL_TELEPORT(
				90,
				WidgetInfo.SPELL_ANNAKARL_TELEPORT,
				new RuneRequirement(2, Rune.LAW),
				new RuneRequirement(2, Rune.BLOOD)
		),
		GHORROCK_TELEPORT(
				96,
				WidgetInfo.SPELL_GHORROCK_TELEPORT,
				new RuneRequirement(8, Rune.WATER),
				new RuneRequirement(2, Rune.LAW)
		),

		// Rush Spells
		SMOKE_RUSH(
				50,
				WidgetInfo.SPELL_SMOKE_RUSH,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(1, Rune.FIRE),
				new RuneRequirement(2, Rune.CHAOS),
				new RuneRequirement(2, Rune.DEATH)
		),
		SHADOW_RUSH(
				52,
				WidgetInfo.SPELL_SHADOW_RUSH,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(2, Rune.CHAOS),
				new RuneRequirement(2, Rune.DEATH),
				new RuneRequirement(1, Rune.SOUL)
		),
		BLOOD_RUSH(
				56,
				WidgetInfo.SPELL_BLOOD_RUSH,
				new RuneRequirement(2, Rune.CHAOS),
				new RuneRequirement(2, Rune.DEATH),
				new RuneRequirement(1, Rune.BLOOD)
		),
		ICE_RUSH(
				58,
				WidgetInfo.SPELL_ICE_RUSH,
				new RuneRequirement(2, Rune.WATER),
				new RuneRequirement(2, Rune.CHAOS),
				new RuneRequirement(2, Rune.DEATH)
		),

		// Burst Spells
		SMOKE_BURST(
				62,
				WidgetInfo.SPELL_SMOKE_BURST,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(2, Rune.FIRE),
				new RuneRequirement(4, Rune.CHAOS),
				new RuneRequirement(2, Rune.DEATH)
		),
		SHADOW_BURST(
				64,
				WidgetInfo.SPELL_SHADOW_BURST,
				new RuneRequirement(1, Rune.AIR),
				new RuneRequirement(4, Rune.CHAOS),
				new RuneRequirement(2, Rune.DEATH),
				new RuneRequirement(2, Rune.SOUL)
		),
		BLOOD_BURST(
				68,
				WidgetInfo.SPELL_BLOOD_BURST,
				new RuneRequirement(2, Rune.CHAOS),
				new RuneRequirement(4, Rune.DEATH),
				new RuneRequirement(2, Rune.BLOOD)
		),
		ICE_BURST(
				70,
				WidgetInfo.SPELL_ICE_BURST,
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(4, Rune.CHAOS),
				new RuneRequirement(2, Rune.DEATH)
		),

		// Blitz Spells
		SMOKE_BLITZ(
				74,
				WidgetInfo.SPELL_SMOKE_BLITZ,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(2, Rune.FIRE),
				new RuneRequirement(2, Rune.DEATH),
				new RuneRequirement(2, Rune.BLOOD)
		),
		SHADOW_BLITZ(
				76,
				WidgetInfo.SPELL_SHADOW_BLITZ,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(2, Rune.DEATH),
				new RuneRequirement(2, Rune.BLOOD),
				new RuneRequirement(2, Rune.SOUL)
		),
		BLOOD_BLITZ(
				80,
				WidgetInfo.SPELL_BLOOD_BLITZ,
				new RuneRequirement(2, Rune.DEATH),
				new RuneRequirement(4, Rune.BLOOD)
		),
		ICE_BLITZ(
				82,
				WidgetInfo.SPELL_ICE_BLITZ,
				new RuneRequirement(3, Rune.WATER),
				new RuneRequirement(2, Rune.DEATH),
				new RuneRequirement(2, Rune.BLOOD)
		),

		// Barrage Spells
		SMOKE_BARRAGE(
				86,
				WidgetInfo.SPELL_SMOKE_BARRAGE,
				new RuneRequirement(4, Rune.AIR),
				new RuneRequirement(4, Rune.FIRE),
				new RuneRequirement(4, Rune.DEATH),
				new RuneRequirement(2, Rune.BLOOD)
		),
		SHADOW_BARRAGE(
				88,
				WidgetInfo.SPELL_SHADOW_BARRAGE,
				new RuneRequirement(4, Rune.AIR),
				new RuneRequirement(4, Rune.DEATH),
				new RuneRequirement(2, Rune.BLOOD),
				new RuneRequirement(3, Rune.SOUL)
		),
		BLOOD_BARRAGE(
				92,
				WidgetInfo.SPELL_BLOOD_BARRAGE,
				new RuneRequirement(4, Rune.DEATH),
				new RuneRequirement(4, Rune.BLOOD),
				new RuneRequirement(1, Rune.SOUL)
		),
		ICE_BARRAGE(
				94,
				WidgetInfo.SPELL_ICE_BARRAGE,
				new RuneRequirement(6, Rune.WATER),
				new RuneRequirement(4, Rune.DEATH),
				new RuneRequirement(2, Rune.BLOOD)
		);

		private final int level;
		private final WidgetInfo widgetInfo;
		private final RuneRequirement[] requirements;

		Ancient(int level, WidgetInfo widgetInfo, RuneRequirement... requirements)
		{
			this.level = level;
			this.widgetInfo = widgetInfo;
			this.requirements = requirements;
		}

		@Override
		public int getLevel()
		{
			return level;
		}

		@Override
		public WidgetInfo getWidget()
		{
			return widgetInfo;
		}

		public boolean canCast()
		{
			if (getCurrent() != ANCIENT)
			{
				return false;
			}

			if (!Worlds.inMembersWorld())
			{
				return false;
			}

			if (this == EDGEVILLE_HOME_TELEPORT)
			{
				return Magic.isHomeTeleportOnCooldown();
			}

			if (level > Skills.getLevel(Skill.MAGIC) || level > Skills.getBoostedLevel(Skill.MAGIC))
			{
				return false;
			}

			return haveRunesAvailable();
		}

		public boolean haveRunesAvailable()
		{
			for (RuneRequirement req : requirements)
			{
				if (!req.meetsRequirements())
				{
					return false;
				}
			}

			return true;
		}
	}

	public enum Lunar implements Spell
	{
		// Teleport spells
		LUNAR_HOME_TELEPORT(
				0,
				WidgetInfo.SPELL_LUNAR_HOME_TELEPORT
		),
		MOONCLAN_TELEPORT(
				69,
				WidgetInfo.SPELL_MOONCLAN_TELEPORT,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		TELE_GROUP_MOONCLAN(
				70,
				WidgetInfo.SPELL_TELE_GROUP_MOONCLAN,
				new RuneRequirement(4, Rune.EARTH),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		OURANIA_TELEPORT(
				71,
				WidgetInfo.SPELL_OURANIA_TELEPORT,
				new RuneRequirement(6, Rune.EARTH),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		WATERBIRTH_TELEPORT(
				72,
				WidgetInfo.SPELL_WATERBIRTH_TELEPORT,
				new RuneRequirement(1, Rune.WATER),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		TELE_GROUP_WATERBIRTH(
				73,
				WidgetInfo.SPELL_TELE_GROUP_WATERBIRTH,
				new RuneRequirement(5, Rune.WATER),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		BARBARIAN_TELEPORT(
				75,
				WidgetInfo.SPELL_BARBARIAN_TELEPORT,
				new RuneRequirement(3, Rune.FIRE),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(2, Rune.LAW)
		),
		TELE_GROUP_BARBARIAN(
				76,
				WidgetInfo.SPELL_TELE_GROUP_BARBARIAN,
				new RuneRequirement(6, Rune.FIRE),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(2, Rune.LAW)
		),
		KHAZARD_TELEPORT(
				78,
				WidgetInfo.SPELL_KHAZARD_TELEPORT,
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(2, Rune.LAW)
		),
		TELE_GROUP_KHAZARD(
				79,
				WidgetInfo.SPELL_TELE_GROUP_KHAZARD,
				new RuneRequirement(8, Rune.WATER),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(2, Rune.LAW)
		),
		FISHING_GUILD_TELEPORT(
				85,
				WidgetInfo.SPELL_FISHING_GUILD_TELEPORT,
				new RuneRequirement(10, Rune.WATER),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.LAW)
		),
		TELE_GROUP_FISHING_GUILD(
				86,
				WidgetInfo.SPELL_TELE_GROUP_FISHING_GUILD,
				new RuneRequirement(14, Rune.WATER),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.LAW)
		),
		CATHERBY_TELEPORT(
				87,
				WidgetInfo.SPELL_CATHERBY_TELEPORT,
				new RuneRequirement(10, Rune.WATER),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.LAW)
		),
		TELE_GROUP_CATHERBY(
				88,
				WidgetInfo.SPELL_TELE_GROUP_CATHERBY,
				new RuneRequirement(15, Rune.WATER),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.LAW)
		),
		ICE_PLATEAU_TELEPORT(
				89,
				WidgetInfo.SPELL_ICE_PLATEAU_TELEPORT,
				new RuneRequirement(8, Rune.WATER),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.LAW)
		),
		TELE_GROUP_ICE_PLATEAU(
				90,
				WidgetInfo.SPELL_TELE_GROUP_ICE_PLATEAU,
				new RuneRequirement(16, Rune.WATER),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.LAW)
		),

		// Combat spells
		MONSTER_EXAMINE(
				66,
				WidgetInfo.SPELL_MONSTER_EXAMINE,
				new RuneRequirement(1, Rune.MIND),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(1, Rune.ASTRAL)
		),
		CURE_OTHER(
				66,
				WidgetInfo.SPELL_CURE_OTHER,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(1, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		CURE_ME(
				66,
				WidgetInfo.SPELL_CURE_ME,
				new RuneRequirement(2, Rune.COSMIC),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		CURE_GROUP(
				66,
				WidgetInfo.SPELL_CURE_GROUP,
				new RuneRequirement(2, Rune.COSMIC),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(2, Rune.LAW)
		),
		STAT_SPY(
				66,
				WidgetInfo.SPELL_STAT_SPY,
				new RuneRequirement(5, Rune.BODY),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(2, Rune.ASTRAL)
		),
		DREAM(
				66,
				WidgetInfo.SPELL_DREAM,
				new RuneRequirement(5, Rune.BODY),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(2, Rune.ASTRAL)
		),
		STAT_RESTORE_POT_SHARE(
				66,
				WidgetInfo.SPELL_STAT_RESTORE_POT_SHARE,
				new RuneRequirement(10, Rune.WATER),
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(2, Rune.ASTRAL)
		),
		BOOST_POTION_SHARE(
				66,
				WidgetInfo.SPELL_BOOST_POTION_SHARE,
				new RuneRequirement(10, Rune.WATER),
				new RuneRequirement(12, Rune.EARTH),
				new RuneRequirement(3, Rune.ASTRAL)
		),
		ENERGY_TRANSFER(
				66,
				WidgetInfo.SPELL_ENERGY_TRANSFER,
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(1, Rune.NATURE),
				new RuneRequirement(2, Rune.LAW)
		),
		HEAL_OTHER(
				66,
				WidgetInfo.SPELL_HEAL_OTHER,
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.LAW),
				new RuneRequirement(1, Rune.BLOOD)
		),
		VENGEANCE_OTHER(
				66,
				WidgetInfo.SPELL_VENGEANCE_OTHER,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(2, Rune.DEATH)
		),
		VENGEANCE(
				66,
				WidgetInfo.SPELL_VENGEANCE,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(4, Rune.ASTRAL),
				new RuneRequirement(2, Rune.DEATH)
		),
		HEAL_GROUP(
				66,
				WidgetInfo.SPELL_HEAL_GROUP,
				new RuneRequirement(4, Rune.ASTRAL),
				new RuneRequirement(6, Rune.LAW),
				new RuneRequirement(3, Rune.BLOOD)
		),

		// Utility spells
		BAKE_PIE(
				66,
				WidgetInfo.SPELL_BAKE_PIE,
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(1, Rune.ASTRAL)
		),
		GEOMANCY(
				66,
				WidgetInfo.SPELL_GEOMANCY,
				new RuneRequirement(8, Rune.EARTH),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(3, Rune.NATURE)
		),
		CURE_PLANT(
				66,
				WidgetInfo.SPELL_CURE_PLANT,
				new RuneRequirement(8, Rune.EARTH),
				new RuneRequirement(1, Rune.ASTRAL)
		),
		NPC_CONTACT(
				66,
				WidgetInfo.SPELL_NPC_CONTACT,
				new RuneRequirement(2, Rune.AIR),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(1, Rune.ASTRAL)
		),
		HUMIDIFY(
				66,
				WidgetInfo.SPELL_HUMIDIFY,
				new RuneRequirement(3, Rune.WATER),
				new RuneRequirement(1, Rune.FIRE),
				new RuneRequirement(1, Rune.ASTRAL)
		),
		HUNTER_KIT(
				66,
				WidgetInfo.SPELL_HUNTER_KIT,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(2, Rune.ASTRAL)
		),
		SPIN_FLAX(
				66,
				WidgetInfo.SPELL_SPIN_FLAX,
				new RuneRequirement(5, Rune.AIR),
				new RuneRequirement(1, Rune.ASTRAL),
				new RuneRequirement(2, Rune.NATURE)
		),
		SUPERGLASS_MAKE(
				66,
				WidgetInfo.SPELL_SUPERGLASS_MAKE,
				new RuneRequirement(10, Rune.AIR),
				new RuneRequirement(6, Rune.FIRE),
				new RuneRequirement(2, Rune.ASTRAL)
		),
		TAN_LEATHER(
				66,
				WidgetInfo.SPELL_TAN_LEATHER,
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.NATURE)
		),
		STRING_JEWELLERY(
				66,
				WidgetInfo.SPELL_STRING_JEWELLERY,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(5, Rune.WATER),
				new RuneRequirement(2, Rune.ASTRAL)
		),
		MAGIC_IMBUE(
				66,
				WidgetInfo.SPELL_MAGIC_IMBUE,
				new RuneRequirement(7, Rune.WATER),
				new RuneRequirement(7, Rune.FIRE),
				new RuneRequirement(2, Rune.ASTRAL)
		),
		FERTILE_SOIL(
				66,
				WidgetInfo.SPELL_FERTILE_SOIL,
				new RuneRequirement(15, Rune.EARTH),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(2, Rune.NATURE)
		),
		PLANK_MAKE(
				66,
				WidgetInfo.SPELL_PLANK_MAKE,
				new RuneRequirement(15, Rune.EARTH),
				new RuneRequirement(2, Rune.ASTRAL),
				new RuneRequirement(1, Rune.NATURE)
		),
		RECHARGE_DRAGONSTONE(
				66,
				WidgetInfo.SPELL_RECHARGE_DRAGONSTONE,
				new RuneRequirement(4, Rune.WATER),
				new RuneRequirement(1, Rune.ASTRAL),
				new RuneRequirement(1, Rune.SOUL)
		),
		SPELLBOOK_SWAP(
				66,
				WidgetInfo.SPELL_SPELLBOOK_SWAP,
				new RuneRequirement(2, Rune.COSMIC),
				new RuneRequirement(3, Rune.ASTRAL),
				new RuneRequirement(1, Rune.LAW)
		),
		;

		private final int level;
		private final WidgetInfo widgetInfo;
		private final RuneRequirement[] requirements;

		Lunar(int level, WidgetInfo widgetInfo, RuneRequirement... requirements)
		{
			this.level = level;
			this.widgetInfo = widgetInfo;
			this.requirements = requirements;
		}

		@Override
		public int getLevel()
		{
			return level;
		}

		@Override
		public WidgetInfo getWidget()
		{
			return widgetInfo;
		}

		public boolean canCast()
		{
			if (getCurrent() != LUNAR)
			{
				return false;
			}

			if (!Worlds.inMembersWorld())
			{
				return false;
			}

			if (this == LUNAR_HOME_TELEPORT)
			{
				return Magic.isHomeTeleportOnCooldown();
			}

			if (level > Skills.getLevel(Skill.MAGIC) || level > Skills.getBoostedLevel(Skill.MAGIC))
			{
				return false;
			}

			return haveRunesAvailable();
		}

		public boolean haveRunesAvailable()
		{
			for (RuneRequirement req : requirements)
			{
				if (!req.meetsRequirements())
				{
					return false;
				}
			}

			return true;
		}
	}

	public enum Necromancy implements Spell
	{
		// Teleport spells
		ARCEUUS_HOME_TELEPORT(
				1,
				WidgetInfo.SPELL_ARCEUUS_HOME_TELEPORT
		),
		ARCEUUS_LIBRARY_TELEPORT(
				6,
				WidgetInfo.SPELL_ARCEUUS_LIBRARY_TELEPORT,
				new RuneRequirement(2, Rune.EARTH),
				new RuneRequirement(1, Rune.LAW)
		),
		DRAYNOR_MANOR_TELEPORT(
				17,
				WidgetInfo.SPELL_DRAYNOR_MANOR_TELEPORT,
				new RuneRequirement(1, Rune.EARTH),
				new RuneRequirement(1, Rune.WATER),
				new RuneRequirement(1, Rune.LAW)
		),
		BATTLEFRONT_TELEPORT(
				23,
				WidgetInfo.SPELL_BATTLEFRONT_TELEPORT,
				new RuneRequirement(1, Rune.EARTH),
				new RuneRequirement(1, Rune.FIRE),
				new RuneRequirement(1, Rune.LAW)
		),
		MIND_ALTAR_TELEPORT(
				28,
				WidgetInfo.SPELL_MIND_ALTAR_TELEPORT,
				new RuneRequirement(2, Rune.MIND),
				new RuneRequirement(1, Rune.LAW)
		),
		RESPAWN_TELEPORT(
				34,
				WidgetInfo.SPELL_RESPAWN_TELEPORT,
				new RuneRequirement(1, Rune.SOUL),
				new RuneRequirement(1, Rune.LAW)
		),
		SALVE_GRAVEYARD_TELEPORT(
				40,
				WidgetInfo.SPELL_SALVE_GRAVEYARD_TELEPORT,
				new RuneRequirement(2, Rune.SOUL),
				new RuneRequirement(1, Rune.LAW)
		),
		FENKENSTRAINS_CASTLE_TELEPORT(
				48,
				WidgetInfo.SPELL_FENKENSTRAINS_CASTLE_TELEPORT,
				new RuneRequirement(1, Rune.EARTH),
				new RuneRequirement(1, Rune.SOUL),
				new RuneRequirement(1, Rune.LAW)
		),
		WEST_ARDOUGNE_TELEPORT(
				61,
				WidgetInfo.SPELL_WEST_ARDOUGNE_TELEPORT,
				new RuneRequirement(2, Rune.SOUL),
				new RuneRequirement(2, Rune.LAW)
		),
		HARMONY_ISLAND_TELEPORT(
				65,
				WidgetInfo.SPELL_HARMONY_ISLAND_TELEPORT,
				new RuneRequirement(1, Rune.NATURE),
				new RuneRequirement(1, Rune.SOUL),
				new RuneRequirement(1, Rune.LAW)
		),
		CEMETERY_TELEPORT(
				71,
				WidgetInfo.SPELL_CEMETERY_TELEPORT,
				new RuneRequirement(1, Rune.BLOOD),
				new RuneRequirement(1, Rune.SOUL),
				new RuneRequirement(1, Rune.LAW)
		),
		BARROWS_TELEPORT(
				83,
				WidgetInfo.SPELL_BARROWS_TELEPORT,
				new RuneRequirement(1, Rune.BLOOD),
				new RuneRequirement(2, Rune.SOUL),
				new RuneRequirement(2, Rune.LAW)
		),
		APE_ATOLL_TELEPORT(
				90,
				WidgetInfo.SPELL_APE_ATOLL_TELEPORT,
				new RuneRequirement(2, Rune.BLOOD),
				new RuneRequirement(2, Rune.SOUL),
				new RuneRequirement(2, Rune.LAW)
		),

		// Combat spells
		GHOSTLY_GRASP(
				35,
				WidgetInfo.SPELL_GHOSTLY_GRASP,
				new RuneRequirement(4, Rune.AIR),
				new RuneRequirement(1, Rune.CHAOS)
		),
		SKELETAL_GRASP(
				56,
				WidgetInfo.SPELL_SKELETAL_GRASP,
				new RuneRequirement(8, Rune.EARTH),
				new RuneRequirement(1, Rune.DEATH)
		),
		UNDEAD_GRASP(
				79,
				WidgetInfo.SPELL_UNDEAD_GRASP,
				new RuneRequirement(12, Rune.FIRE),
				new RuneRequirement(1, Rune.BLOOD)
		),
		INFERIOR_DEMONBANE(
				44,
				WidgetInfo.SPELL_INFERIOR_DEMONBANE,
				new RuneRequirement(4, Rune.FIRE),
				new RuneRequirement(1, Rune.CHAOS)
		),
		SUPERIOR_DEMONBANE(
				62,
				WidgetInfo.SPELL_SUPERIOR_DEMONBANE,
				new RuneRequirement(8, Rune.FIRE),
				new RuneRequirement(1, Rune.SOUL)
		),
		DARK_DEMONBANE(
				82,
				WidgetInfo.SPELL_DARK_DEMONBANE,
				new RuneRequirement(12, Rune.FIRE),
				new RuneRequirement(2, Rune.SOUL)
		),
		LESSER_CORRUPTION(
				64,
				WidgetInfo.SPELL_LESSER_CORRUPTION,
				new RuneRequirement(1, Rune.DEATH),
				new RuneRequirement(2, Rune.SOUL)
		),
		GREATER_CORRUPTION(
				85,
				WidgetInfo.SPELL_GREATER_CORRUPTION,
				new RuneRequirement(1, Rune.BLOOD),
				new RuneRequirement(3, Rune.SOUL)
		),
		RESURRECT_LESSER_GHOST(
				38,
				WidgetInfo.SPELL_RESURRECT_LESSER_GHOST,
				new RuneRequirement(10, Rune.AIR),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.MIND)
		),
		RESURRECT_LESSER_SKELETON(
				38,
				WidgetInfo.SPELL_RESURRECT_LESSER_SKELETON,
				new RuneRequirement(10, Rune.AIR),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.MIND)
		),
		RESURRECT_LESSER_ZOMBIE(
				38,
				WidgetInfo.SPELL_RESURRECT_LESSER_ZOMBIE,
				new RuneRequirement(10, Rune.AIR),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.MIND)
		),
		RESURRECT_SUPERIOR_GHOST(
				57,
				WidgetInfo.SPELL_RESURRECT_SUPERIOR_GHOST,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.DEATH)
		),
		RESURRECT_SUPERIOR_SKELETON(
				57,
				WidgetInfo.SPELL_RESURRECT_SUPERIOR_SKELETON,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.DEATH)
		),
		RESURRECT_SUPERIOR_ZOMBIE(
				57,
				WidgetInfo.SPELL_RESURRECT_SUPERIOR_ZOMBIE,
				new RuneRequirement(10, Rune.EARTH),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.DEATH)
		),
		RESURRECT_GREATER_GHOST(
				76,
				WidgetInfo.SPELL_RESURRECT_GREATER_GHOST,
				new RuneRequirement(10, Rune.FIRE),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.BLOOD)
		),
		RESURRECT_GREATER_SKELETON(
				76,
				WidgetInfo.SPELL_RESURRECT_GREATER_SKELETON,
				new RuneRequirement(10, Rune.FIRE),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.BLOOD)
		),
		RESURRECT_GREATER_ZOMBIE(
				76,
				WidgetInfo.SPELL_RESURRECT_GREATER_ZOMBIE,
				new RuneRequirement(10, Rune.FIRE),
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(5, Rune.BLOOD)
		),
		DARK_LURE(
				50,
				WidgetInfo.SPELL_DARK_LURE,
				new RuneRequirement(1, Rune.DEATH),
				new RuneRequirement(1, Rune.NATURE)
		),
		MARK_OF_DARKNESS(
				59,
				WidgetInfo.SPELL_MARK_OF_DARKNESS,
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(1, Rune.SOUL)
		),
		WARD_OF_ARCEUUS(
				73,
				WidgetInfo.SPELL_WARD_OF_ARCEUUS,
				new RuneRequirement(1, Rune.COSMIC),
				new RuneRequirement(2, Rune.NATURE),
				new RuneRequirement(4, Rune.SOUL)
		),

		// Utility spells
		BASIC_REANIMATION(
				16,
				WidgetInfo.SPELL_BASIC_REANIMATION,
				new RuneRequirement(4, Rune.BODY),
				new RuneRequirement(2, Rune.NATURE)
		),
		ADEPT_REANIMATION(
				41,
				WidgetInfo.SPELL_ADEPT_REANIMATION,
				new RuneRequirement(4, Rune.BODY),
				new RuneRequirement(3, Rune.NATURE),
				new RuneRequirement(1, Rune.SOUL)
		),
		EXPERT_REANIMATION(
				72,
				WidgetInfo.SPELL_EXPERT_REANIMATION,
				new RuneRequirement(1, Rune.BLOOD),
				new RuneRequirement(3, Rune.NATURE),
				new RuneRequirement(2, Rune.SOUL)
		),
		MASTER_REANIMATION(
				90,
				WidgetInfo.SPELL_MASTER_REANIMATION,
				new RuneRequirement(2, Rune.BLOOD),
				new RuneRequirement(4, Rune.NATURE),
				new RuneRequirement(4, Rune.SOUL)
		),
		DEMONIC_OFFERING(
				84,
				WidgetInfo.SPELL_DEMONIC_OFFERING,
				new RuneRequirement(1, Rune.SOUL),
				new RuneRequirement(1, Rune.WRATH)
		),
		SINISTER_OFFERING(
				92,
				WidgetInfo.SPELL_SINISTER_OFFERING,
				new RuneRequirement(1, Rune.BLOOD),
				new RuneRequirement(1, Rune.WRATH)
		),
		SHADOW_VEIL(
				47,
				WidgetInfo.SPELL_SHADOW_VEIL,
				new RuneRequirement(5, Rune.EARTH),
				new RuneRequirement(5, Rune.FIRE),
				new RuneRequirement(5, Rune.COSMIC)
		),
		VILE_VIGOUR(
				66,
				WidgetInfo.SPELL_VILE_VIGOUR,
				new RuneRequirement(3, Rune.AIR),
				new RuneRequirement(1, Rune.SOUL)
		),
		DEGRIME(
				70,
				WidgetInfo.SPELL_DEGRIME,
				new RuneRequirement(4, Rune.EARTH),
				new RuneRequirement(2, Rune.NATURE)
		),
		RESURRECT_CROPS(
				78,
				WidgetInfo.SPELL_RESURRECT_CROPS,
				new RuneRequirement(25, Rune.EARTH),
				new RuneRequirement(8, Rune.BLOOD),
				new RuneRequirement(12, Rune.NATURE),
				new RuneRequirement(8, Rune.SOUL)
		),
		DEATH_CHARGE(
				80,
				WidgetInfo.SPELL_DEATH_CHARGE,
				new RuneRequirement(1, Rune.BLOOD),
				new RuneRequirement(1, Rune.DEATH),
				new RuneRequirement(1, Rune.SOUL)
		),
		;

		private final int level;
		private final WidgetInfo widgetInfo;
		private final RuneRequirement[] requirements;

		Necromancy(int level, WidgetInfo widgetInfo, RuneRequirement... requirements)
		{
			this.level = level;
			this.widgetInfo = widgetInfo;
			this.requirements = requirements;
		}

		@Override
		public int getLevel()
		{
			return level;
		}

		@Override
		public WidgetInfo getWidget()
		{
			return widgetInfo;
		}

		public boolean canCast()
		{
			if (getCurrent() != NECROMANCY)
			{
				return false;
			}

			if (!Worlds.inMembersWorld())
			{
				return false;
			}

			if (this == ARCEUUS_HOME_TELEPORT)
			{
				return Magic.isHomeTeleportOnCooldown();
			}

			if (level > Skills.getLevel(Skill.MAGIC) || level > Skills.getBoostedLevel(Skill.MAGIC))
			{
				return false;
			}

			return haveRunesAvailable();
		}

		public boolean haveRunesAvailable()
		{
			for (RuneRequirement req : requirements)
			{
				if (!req.meetsRequirements())
				{
					return false;
				}
			}

			return true;
		}
	}
}

package net.unethicalite.api.statistics;

import net.unethicalite.api.commons.NumericFormat;
import net.unethicalite.api.commons.StopWatch;

import java.util.function.Supplier;

public final class Statistic
{
	private final boolean header;
	private final Supplier<String> supplier;

	public Statistic(boolean header, Supplier<String> supplier)
	{
		this.header = header;
		this.supplier = supplier;
	}

	public Statistic(Supplier<String> supplier)
	{
		this(false, supplier);
	}

	public Statistic(StopWatch timer, Supplier<Integer> rate, boolean format)
	{
		this(false, () ->
		{
			int value = rate.get();
			long hourly = (long) timer.getHourlyRate(value);
			String valueText = format ? NumericFormat.apply(value) : String.valueOf(value);
			String hourlyText = format ? NumericFormat.apply(hourly) : String.valueOf(hourly);

			return valueText + " (" + hourlyText + " / hr)";
		});
	}

	public Statistic(StopWatch timer, Supplier<Integer> rate)
	{
		this(timer, rate, true);
	}

	public boolean isHeader()
	{
		return header;
	}

	public Supplier<String> getSupplier()
	{
		return supplier;
	}

	@Override
	public String toString()
	{
		return supplier.get();
	}
}

package net.unethicalite.api.statistics;

import net.unethicalite.api.commons.NumericFormat;
import net.unethicalite.api.commons.StopWatch;

import java.util.function.Supplier;

public final class Statistic
{
	private final boolean header;
	private final Supplier<String> supplier;

	public Statistic(boolean header, Supplier<String> supplier)
	{
		this.header = header;
		this.supplier = supplier;
	}

	public Statistic(Supplier<String> supplier)
	{
		this(false, supplier);
	}

	public Statistic(StopWatch timer, Supplier<Integer> rate, boolean format)
	{
		this(false, () ->
		{
			int value = rate.get();
			long hourly = (long) timer.getHourlyRate(value);
			String valueText = format ? NumericFormat.apply(value) : String.valueOf(value);
			String hourlyText = format ? NumericFormat.apply(hourly) : String.valueOf(hourly);

			return valueText + " (" + hourlyText + " / hr)";
		});
	}

	public Statistic(StopWatch timer, Supplier<Integer> rate)
	{
		this(timer, rate, true);
	}

	public boolean isHeader()
	{
		return header;
	}

	public Supplier<String> getSupplier()
	{
		return supplier;
	}

	@Override
	public String toString()
	{
		return supplier.get();
	}
}

package net.unethicalite.api.script.paint;

import net.unethicalite.api.commons.NumericFormat;
import net.unethicalite.api.commons.StopWatch;

import java.util.function.Supplier;

public final class Statistic
{
	private final boolean header;
	private final Supplier<String> supplier;

	public Statistic(boolean header, Supplier<String> supplier)
	{
		this.header = header;
		this.supplier = supplier;
	}

	public Statistic(Supplier<String> supplier)
	{
		this(false, supplier);
	}

	public Statistic(StopWatch timer, Supplier<Integer> rate, boolean format)
	{
		this(false, () ->
		{
			int value = rate.get();
			long hourly = (long) timer.getHourlyRate(value);
			String valueText = format ? NumericFormat.apply(value) : String.valueOf(value);
			String hourlyText = format ? NumericFormat.apply(hourly) : String.valueOf(hourly);

			return valueText + " (" + hourlyText + " / hr)";
		});
	}

	public Statistic(StopWatch timer, Supplier<Integer> rate)
	{
		this(timer, rate, true);
	}

	public boolean isHeader()
	{
		return header;
	}

	public Supplier<String> getSupplier()
	{
		return supplier;
	}

	@Override
	public String toString()
	{
		return supplier.get();
	}
}

package net.unethicalite.api.commons;

import java.time.Duration;
import java.time.Instant;
import java.util.function.Supplier;

public class StopWatch
{
	private Instant start;
	private Instant end;

	private StopWatch(Supplier<Instant> supplier, Duration duration)
	{
		start = supplier.get();
		if (duration != null)
		{
			end = start.plus(duration);
		}
	}

	public static StopWatch start(Supplier<Instant> supplier)
	{
		return new StopWatch(supplier, null);
	}

	public static StopWatch start()
	{
		return start(Instant::now);
	}

	public boolean exceeds(Duration duration)
	{
		return getElapsed().getSeconds() > duration.getSeconds();
	}

	public void setEndIn(Duration duration)
	{
		end = Instant.now().plus(duration);
	}

	public boolean isRunning()
	{
		return end == null || Instant.now().isBefore(end);
	}

	public Duration getElapsed()
	{
		return Duration.between(start, Instant.now());
	}

	public Duration getRemaining()
	{
		return end != null ? Duration.between(end, Instant.now()) : Duration.ZERO;
	}

	public String toElapsedString()
	{
		return Time.format(getElapsed());
	}

	public String toRemainingString()
	{
		return Time.format(getRemaining());
	}

	public void reset()
	{
		Instant prevStart = start;
		start = Instant.now();
		if (end != null)
		{
			Duration duration = Duration.between(prevStart, end);
			setEndIn(duration);
		}
	}

	public double getRate(long value, Duration rate)
	{
		long elapsed = getElapsed().toMillis();
		if (elapsed == 0)
		{
			return 0;
		}

		return (double) (value * rate.toMillis() / getElapsed().toMillis());
	}

	public double getHourlyRate(long value)
	{
		return getRate(value, Duration.ofHours(1));
	}
}

package net.unethicalite.api.input.naturalmouse.api;

import java.awt.Dimension;

/**
 * Abstracts ordinary static System calls away
 */
public interface SystemCalls
{
	long currentTimeMillis();

	void sleep(long time);

	Dimension getScreenSize();

	void setMousePosition(int x, int y);
}

package net.unethicalite.api.input.naturalmouse.tools;

import net.unethicalite.api.input.naturalmouse.api.MouseInfoAccessor;
import net.unethicalite.api.input.naturalmouse.api.SystemCalls;
import net.unethicalite.api.input.naturalmouse.support.DefaultMouseInfoAccessor;
import net.unethicalite.api.input.naturalmouse.support.DefaultSystemCalls;

import java.awt.AWTException;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Robot;

public class SystemDiagnosis
{

	/**
	 * Runs a diagnosis with default configuration, by setting mouse all over your screen and expecting to receive
	 * correct coordinates back.
	 * If java.awt.Robot cannot be constructed, then new RuntimeException is thrown.
	 * If no issues are found, then this method completes without throwing an error, otherwise IllegalStateException is
	 * thrown.
	 */
	public static void validateMouseMovement()
	{
		try
		{
			Robot robot = new Robot();
			validateMouseMovement(new DefaultSystemCalls(robot), new DefaultMouseInfoAccessor());
		}
		catch (AWTException e)
		{
			throw new RuntimeException(e);
		}
	}

	/**
	 * Runs a diagnosis, by setting mouse all over your screen and expecting to receive correct coordinates back.
	 * If no issues are found, then this method completes without throwing an error, otherwise IllegalStateException is
	 * thrown.
	 *
	 * @param system   a SystemCalls class which is used for setting the mouse position
	 * @param accessor a MouseInfoAccessor which is used for querying mouse position
	 */
	public static void validateMouseMovement(SystemCalls system, MouseInfoAccessor accessor)
	{
		Dimension dimension = system.getScreenSize();
		for (int y = 0; y < dimension.height; y += 50)
		{
			for (int x = 0; x < dimension.width; x += 50)
			{
				system.setMousePosition(x, y);

				try
				{
					Thread.sleep(1);
				}
				catch (InterruptedException e)
				{
					Thread.currentThread().interrupt();
				}

				Point p = accessor.getMousePosition();
				if (x != p.x || y != p.y)
				{
					throw new IllegalStateException(
							"Tried to move mouse to (" + x + ", " + y + "). Actually moved to (" + p.x + ", " + p.y + ")" +
									"This means NaturalMouseMotion is not able to work optimally on this system as the cursor move " +
									"calls may miss the target pixels on the screen."
					);
				}
			}
		}
	}
}

package net.unethicalite.api.widgets;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.widgets.WidgetInfo;

@AllArgsConstructor
@Getter
public enum Tab
{
	COMBAT(WidgetInfo.FIXED_VIEWPORT_COMBAT_TAB, WidgetInfo.FIXED_VIEWPORT_COMBAT_TAB.getChildId(), 0),
	SKILLS(WidgetInfo.FIXED_VIEWPORT_STATS_TAB, WidgetInfo.FIXED_VIEWPORT_STATS_TAB.getChildId(), 1),
	QUESTS(WidgetInfo.FIXED_VIEWPORT_QUESTS_TAB, WidgetInfo.FIXED_VIEWPORT_QUESTS_TAB.getChildId(), 2),
	INVENTORY(WidgetInfo.FIXED_VIEWPORT_INVENTORY_TAB, WidgetInfo.FIXED_VIEWPORT_INVENTORY_TAB.getChildId(), 3),
	EQUIPMENT(WidgetInfo.FIXED_VIEWPORT_EQUIPMENT_TAB, WidgetInfo.FIXED_VIEWPORT_EQUIPMENT_TAB.getChildId(), 4),
	PRAYER(WidgetInfo.FIXED_VIEWPORT_PRAYER_TAB, WidgetInfo.FIXED_VIEWPORT_PRAYER_TAB.getChildId(), 5),
	MAGIC(WidgetInfo.FIXED_VIEWPORT_MAGIC_TAB, WidgetInfo.FIXED_VIEWPORT_MAGIC_TAB.getChildId(), 6),
	CLAN_CHAT(WidgetInfo.FIXED_VIEWPORT_FRIENDS_CHAT_TAB, WidgetInfo.FIXED_VIEWPORT_FRIENDS_CHAT_TAB.getChildId(), 7),
	ACCOUNT(WidgetInfo.FIXED_VIEWPORT_IGNORES_TAB, WidgetInfo.FIXED_VIEWPORT_IGNORES_TAB.getChildId(), 8),
	FRIENDS(WidgetInfo.FIXED_VIEWPORT_FRIENDS_TAB, WidgetInfo.FIXED_VIEWPORT_FRIENDS_TAB.getChildId(), 9),
	LOG_OUT(WidgetInfo.FIXED_VIEWPORT_LOGOUT_TAB, WidgetInfo.FIXED_VIEWPORT_LOGOUT_TAB.getChildId(), 10),
	OPTIONS(WidgetInfo.FIXED_VIEWPORT_OPTIONS_TAB, WidgetInfo.FIXED_VIEWPORT_OPTIONS_TAB.getChildId(), 11),
	EMOTES(WidgetInfo.FIXED_VIEWPORT_EMOTES_TAB, WidgetInfo.FIXED_VIEWPORT_EMOTES_TAB.getChildId(), 12),
	MUSIC(WidgetInfo.FIXED_VIEWPORT_MUSIC_TAB, WidgetInfo.FIXED_VIEWPORT_MUSIC_TAB.getChildId(), 13);

	private final WidgetInfo widgetInfo;
	private final int childId;
	private final int index;
}

package net.unethicalite.api.widgets;

import net.unethicalite.api.game.Game;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.game.Vars;
import net.runelite.api.GameState;
import net.runelite.api.VarClientInt;
import net.unethicalite.client.Static;

import java.util.Arrays;

public class Tabs
{
	public static void open(Tab tab)
	{
		if (Static.getClient() == null || Game.getState() != GameState.LOGGED_IN)
		{
			return;
		}

		GameThread.invoke(() -> Static.getClient().runScript(915, tab.getIndex()));
	}

	@Deprecated
	public static void openInterface(Tab tab)
	{
		open(tab);
	}

	public static boolean isOpen(Tab tab)
	{
		return Vars.getVarcInt(VarClientInt.INVENTORY_TAB) == Arrays.asList(Tab.values()).indexOf(tab);
	}
}

package net.unethicalite.api.plugins;

public interface Task
{
	boolean validate();

	int execute();

	default boolean isBlocking()
	{
		return true;
	}

	default boolean subscribe()
	{
		return false;
	}
}

package net.unethicalite.api.plugins;

import lombok.Getter;

public abstract class TaskPlugin extends LoopedPlugin
{
	public abstract Task[] getTasks();

	@Getter
	private String currentTask = null;

	@Override
	protected int loop()
	{
		for (Task task : getTasks())
		{
			if (task.validate())
			{
				currentTask = task.getClass().getSimpleName();
				int delay = task.execute();
				if (task.isBlocking())
				{
					return delay;
				}
			}
		}

		return 1000;
	}
}

package net.unethicalite.api.movement.pathfinder.model;

import lombok.Value;
import net.runelite.api.coords.WorldPoint;

@Value
public class Teleport
{
	WorldPoint destination;
	int radius;
	Runnable handler;
}

package net.unethicalite.api.movement.pathfinder.model;

import net.runelite.api.ItemID;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.api.game.Skills;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.items.Inventory;
import net.unethicalite.api.quests.Quests;

public enum TeleportItem
{
    // Prioritize house tab
    HOUSE_TAB(MovementConstants.HOUSE_POINT, "Break", null, ItemID.TELEPORT_TO_HOUSE),

    // Tabs
    WATERBIRTH_TELEPORT_TAB(new WorldPoint(2546, 3757, 0), "Break", null, ItemID.WATERBIRTH_TELEPORT),
    KHAZARD_TELEPORT_TAB(new WorldPoint(2637, 3166, 0), "Break", null, ItemID.KHAZARD_TELEPORT),
    VARROCK_TELEPORT_TAB(new WorldPoint(3212, 3424, 0), "Break", null, ItemID.VARROCK_TELEPORT),
    LUMBRIDGE_TELEPORT_TAB(new WorldPoint(3225, 3219, 0), "Break", null, ItemID.LUMBRIDGE_TELEPORT),
    FALADOR_TELEPORT_TAB(new WorldPoint(2966, 3379, 0), "Break", null, ItemID.FALADOR_TELEPORT),
    CAMELOT_TELEPORT_TAB(new WorldPoint(2757, 3479, 0), "Break", null, ItemID.CAMELOT_TELEPORT),
    ARDOUGNE_TELEPORT_TAB(new WorldPoint(2661, 3300, 0), "Break", null, ItemID.ARDOUGNE_TELEPORT),
    WEST_ARDOUGNE_TELEPORT_TAB(new WorldPoint(2500, 3290, 0), "Break", null, ItemID.WEST_ARDOUGNE_TELEPORT),
    RIMMINGTON_TELEPORT_TAB(new WorldPoint(2954, 3224, 0), "Break", null, ItemID.RIMMINGTON_TELEPORT),
    TAVERLEY_TELEPORT_TAB(new WorldPoint(2894, 3465, 0), "Break", null, ItemID.TAVERLEY_TELEPORT),
    RELLEKKA_TELEPORT_TAB(new WorldPoint(2668, 3631, 0), "Break", null, ItemID.RELLEKKA_TELEPORT),
    BRIMHAVEN_TELEPORT_TAB(new WorldPoint(2758, 3178, 0), "Break", null, ItemID.BRIMHAVEN_TELEPORT),
    POLLNIVNEACH_TELEPORT_TAB(new WorldPoint(3340, 3004, 0), "Break", null, ItemID.POLLNIVNEACH_TELEPORT),
    YANILLE_TELEPORT_TAB(new WorldPoint(2544, 3095, 0), "Break", null, ItemID.YANILLE_TELEPORT),
    HOSIDIUS_TELEPORT_TAB(new WorldPoint(1744, 3517, 0), "Break", null, ItemID.HOSIDIUS_TELEPORT),
    SALVE_GRAVEYARD_TELEPORT_TAB(new WorldPoint(3432, 3460, 0), "Break", null, ItemID.SALVE_GRAVEYARD_TELEPORT),
    DRAYNOR_MANOR_TELEPORT_TAB(new WorldPoint(3109, 3350, 0), "Break", null, ItemID.DRAYNOR_MANOR_TELEPORT),
    FENKENSTRAINS_CASTLE_TELEPORT_TAB(new WorldPoint(3549, 3530, 0), "Break", null, ItemID.FENKENSTRAINS_CASTLE_TELEPORT),

    RIMMINGTON_TAB(new WorldPoint(2954, 3223, 0), "Break", null, ItemID.RIMMINGTON_TELEPORT),
    TAVERLEY_TAB(new WorldPoint(2894, 3466, 0), "Break", null, ItemID.TAVERLEY_TELEPORT),
    POLLNIVNEACH_TAB(new WorldPoint(3339, 3004, 0), "Break", null, ItemID.POLLNIVNEACH_TELEPORT),
    HOSIDIUS_TAB(new WorldPoint(1744, 3518, 0), "Break", null, ItemID.HOSIDIUS_TELEPORT),
    RELLEKKA_TAB(new WorldPoint(2671, 3631, 0), "Break", null, ItemID.RELLEKKA_TELEPORT),
    BRIMHAVEN_TAB(new WorldPoint(2758, 3177, 0), "Break", null, ItemID.BRIMHAVEN_TELEPORT),
    YANILLE_TAB(new WorldPoint(2545, 3096, 0), "Break", null, ItemID.YANILLE_TELEPORT),
    TROLLHEIM_TAB(new WorldPoint(2890, 3679, 0), "Break", null, ItemID.TROLLHEIM_TELEPORT),
    PRIFDDINAS_TAB(new WorldPoint(3239, 6076, 0), "Break", null, ItemID.PRIFDDINAS_TELEPORT),

    // Scrolls
    FELDIP_HILLS_TELEPORT(new WorldPoint(2541, 2925, 0), "Teleport", null, ItemID.FELDIP_HILLS_TELEPORT),
    PISCATORIS_TELEPORT(new WorldPoint(2342, 3647, 0), "Teleport", null, ItemID.PISCATORIS_TELEPORT),
    MORTTON_TELEPORT(new WorldPoint(3488, 3288, 0), "Teleport", null, ItemID.MORTTON_TELEPORT),
    DIGSITE_TELEPORT(new WorldPoint(3324, 3412, 0), "Teleport", null, ItemID.DIGSITE_TELEPORT),
    NARDAH_TELEPORT(new WorldPoint(3420, 2917, 0), "Teleport", null, ItemID.NARDAH_TELEPORT),
    LUMBERYARD_TELEPORT(new WorldPoint(3302, 3486, 0), "Teleport", null, ItemID.LUMBERYARD_TELEPORT),
    TAI_BWO_TELEPORT(new WorldPoint(2789, 3066, 0), "Teleport", null, ItemID.TAI_BWO_WANNAI_TELEPORT),
    ZULANDRA_TELEPORT(new WorldPoint(2197, 3055, 0), "Teleport", null, ItemID.ZULANDRA_TELEPORT),
    IORWERTH_TELEPORT(new WorldPoint(2194, 3258, 0), "Teleport", null, ItemID.IORWERTH_CAMP_TELEPORT),
    LUNAR_ISLE_TELEPORT(new WorldPoint(2093, 3912, 0), "Teleport", null, ItemID.LUNAR_ISLE_TELEPORT),
    MOS_LEHARMLESS_TELEPORT(new WorldPoint(3701, 2996, 0), "Teleport", null, ItemID.MOS_LEHARMLESS_TELEPORT),
    PEST_CONTROL_TELEPORT(new WorldPoint(2657, 2660, 0), "Teleport", null, ItemID.PEST_CONTROL_TELEPORT),
    KEY_MASTER_TELEPORT(new WorldPoint(2686, 9882, 0), "Teleport", null, ItemID.KEY_MASTER_TELEPORT),
    REVENANT_CAVE_TELEPORT(new WorldPoint(3127, 3833, 0), "Teleport", null, ItemID.REVENANT_CAVE_TELEPORT),
    WATSON_TELEPORT(new WorldPoint(1645, 3579, 0), "Teleport", null, ItemID.WATSON_TELEPORT),

    // Misc consumables
    WEISS_ICY_BASALT(new WorldPoint(2846, 3940, 0), "Weiss", Quest.MAKING_FRIENDS_WITH_MY_ARM, ItemID.ICY_BASALT),
    TROLL_STRONGHOLD(new WorldPoint(2838, 3693, 0), "Troll Stronghold", Quest.MAKING_FRIENDS_WITH_MY_ARM, ItemID.STONY_BASALT),
    TROLL_STRONGHOLD_OUTSIDE(new WorldPoint(2844, 3693, 0), "Troll Stronghold", Quest.MAKING_FRIENDS_WITH_MY_ARM, ItemID.STONY_BASALT),

    // Reusable
    ROYAL_SEED_POD(new WorldPoint(2465, 3495, 0), "Commune", Quest.MONKEY_MADNESS_II, ItemID.ROYAL_SEED_POD),
    ECTOPHIAL(new WorldPoint(3659, 3523, 0), "Empty", null, ItemID.ECTOPHIAL),
    TELEPORT_CRYSTAL_LLETYA(new WorldPoint(2330, 3172, 0), "Lletya", null, MovementConstants.TELEPORT_CRYSTAL),
    TELEPORT_CRYSTAL_PRIFDDINAS(new WorldPoint(3264, 6065, 0), "Prifddinas", Quest.SONG_OF_THE_ELVES, MovementConstants.TELEPORT_CRYSTAL),

    // TODO move these to teleport loader since they are equippable...
    //	CHAMPIONS_GUILD_CHRONICLE(new WorldPoint(3202, 3357, 0), "Champions' Guild", null, ItemID.CHRONICLE),
    RELLEKKKA_LYRE(new WorldPoint(2664, 3643, 0), "Rellekka", Quest.THE_FREMENNIK_TRIALS, MovementConstants.ENCHANTED_LYRE),
    WATERBIRTH_ISLAND_LYRE(new WorldPoint(2550, 3756, 0), "Waterbirth Island", Quest.THE_FREMENNIK_TRIALS, MovementConstants.ENCHANTED_LYRE),
    NEITIZNOT_LYRE(new WorldPoint(2336, 3801, 0), "Neitiznot", Quest.THE_FREMENNIK_TRIALS, MovementConstants.ENCHANTED_LYRE),
    JATIZSO_LYRE(new WorldPoint(2409, 3809, 0), "Jatizso", Quest.THE_FREMENNIK_TRIALS, MovementConstants.ENCHANTED_LYRE),
    ;

    private final WorldPoint destination;
    private final Quest requirement;
    private final int[] itemIds;
    private final String action;

    TeleportItem(WorldPoint destination, String action, Quest requirement, int... itemIds)
    {
        this.destination = destination;
        this.requirement = requirement;
        this.itemIds = itemIds;
        this.action = action;
    }

    public WorldPoint getDestination()
    {
        return destination;
    }

    public int[] getItemId()
    {
        return itemIds;
    }

    public String getAction()
    {
        return action;
    }

    public boolean canUse()
    {
        return hasRequirements() && Inventory.getFirst(itemIds) != null;
    }

    public boolean hasRequirements()
    {
        boolean hasQuestReqs = (requirement == null || Quests.getState(requirement) == QuestState.FINISHED);
        switch (this)
        {
            case JATIZSO_LYRE:
            case NEITIZNOT_LYRE:
                return hasQuestReqs && Vars.getBit(Varbits.DIARY_FREMENNIK_ELITE) > 0;
            case WATERBIRTH_ISLAND_LYRE:
                return hasQuestReqs && Vars.getBit(Varbits.DIARY_FREMENNIK_HARD) > 0;
            case TROLL_STRONGHOLD:
                return hasQuestReqs && Skills.getLevel(Skill.AGILITY) >= 73 && Vars.getBit(Varbits.DIARY_FREMENNIK_HARD) > 0;
            case ARDOUGNE_TELEPORT_TAB:
                return hasQuestReqs && Vars.getVarp(165) >= 30;
            case SALVE_GRAVEYARD_TELEPORT_TAB:
                return hasQuestReqs && Vars.getVarp(302) >= 61;
            default:
                return hasQuestReqs;
        }
    }
}

package net.unethicalite.api.movement.pathfinder;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemID;
import net.runelite.api.ObjectID;
import net.runelite.api.Quest;
import net.runelite.api.TileObject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.commons.Time;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.entities.TileObjects;
import net.unethicalite.api.game.Game;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.game.Worlds;
import net.unethicalite.api.input.Keyboard;
import net.unethicalite.api.items.Equipment;
import net.unethicalite.api.items.Inventory;
import net.unethicalite.api.magic.Magic;
import net.unethicalite.api.magic.Spell;
import net.unethicalite.api.magic.SpellBook;
import static net.unethicalite.api.movement.pathfinder.model.MovementConstants.*;
import net.unethicalite.api.movement.pathfinder.model.Teleport;
import net.unethicalite.api.movement.pathfinder.model.TeleportItem;
import net.unethicalite.api.movement.pathfinder.model.TeleportSpell;
import net.unethicalite.api.movement.pathfinder.model.poh.HousePortal;
import net.unethicalite.api.quests.Quests;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.api.widgets.Minigames;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;
import net.unethicalite.client.managers.RegionManager;

public class TeleportLoader
{
	private static Pattern WILDY_PATTERN = Pattern.compile("Okay, teleport to level [\\d,]* Wilderness\\.");
	private static List<Teleport> LAST_TELEPORT_LIST = new ArrayList<>();

	public static List<Teleport> buildTeleports()
	{
		List<Teleport> teleports = new ArrayList<>();
		teleports.addAll(LAST_TELEPORT_LIST);
		teleports.addAll(buildTimedTeleports());
		return teleports;
	}

	private static List<Teleport> buildTimedTeleports()
	{
		return GameThread.invokeLater(() -> {
			List<Teleport> teleports = new ArrayList<>();
			if (Worlds.inMembersWorld())
			{
				if (Game.getWildyLevel() == 0)
				{
					// Minigames
					if (RegionManager.useMinigameTeleports() && Minigames.canTeleport())
					{
						for (Minigames.Destination tp : Minigames.Destination.values())
						{
							if (tp.canUse())
							{
								teleports.add(new Teleport(tp.getLocation(), 2, () -> Minigames.teleport(tp)));
							}
						}
					}
				}
			}

			if (Game.getWildyLevel() <= 20)
			{
				for (TeleportSpell teleportSpell : TeleportSpell.values())
				{
					if (!teleportSpell.canCast() || teleportSpell.getPoint() == null)
					{
						continue;
					}

					if (teleportSpell.getPoint().distanceTo(Players.getLocal().getWorldLocation()) > 50)
					{
						teleports.add(new Teleport(teleportSpell.getPoint(), 5, () ->
						{
							final Spell spell = teleportSpell.getSpell();
							if (teleportSpell == TeleportSpell.TELEPORT_TO_HOUSE)
							{
								// Tele to outside
								Widget widget = Widgets.get(spell.getWidget());
								if (widget == null)
								{
									return;
								}
								widget.interact(1);
							}
							else
							{
								Magic.cast(spell);
							}
						}));
					}
				}
			}

			return teleports;
		});
	}

	public static void refreshTeleports()
	{
		GameThread.invoke(() ->
		{
			List<Teleport> teleports = new ArrayList<>();
			if (Worlds.inMembersWorld())
			{
				// One click teleport items
				for (TeleportItem tele : TeleportItem.values())
				{
					if (tele.canUse() && tele.getDestination().distanceTo(Players.getLocal().getWorldLocation()) > 20)
					{
						switch (tele)
						{
							case ROYAL_SEED_POD:
								if (Game.getWildyLevel() <= 30)
								{
									teleports.add(itemTeleport(tele));
								}
							default:
								if (Game.getWildyLevel() <= 20)
								{
									teleports.add(itemTeleport(tele));
								}
						}
					}
				}

				if (Game.getWildyLevel() <= 20)
				{
					if (ringOfDueling())
					{
						teleports.add(new Teleport(new WorldPoint(3315, 3235, 0), 6,
							() -> jewelryTeleport("PvP Arena", RING_OF_DUELING)));
						teleports.add(new Teleport(new WorldPoint(2440, 3090, 0), 2,
							() -> jewelryTeleport("Castle Wars", RING_OF_DUELING)));
						teleports.add(new Teleport(new WorldPoint(3151, 3635, 0), 2,
							() -> jewelryTeleport("Ferox Enclave", RING_OF_DUELING)));
					}

					if (gamesNecklace())
					{
						teleports.add(new Teleport(new WorldPoint(2898, 3553, 0), 2,
							() -> jewelryTeleport("Burthorpe", GAMES_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(2520, 3571, 0), 6,
							() -> jewelryTeleport("Barbarian Outpost", GAMES_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(2964, 4382, 2), 2,
							() -> jewelryTeleport("Corporeal Beast", GAMES_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(3244, 9501, 2), 2,
							() -> jewelryTeleport("Tears of Guthix", GAMES_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(1624, 3938, 0), 1,
							() -> jewelryTeleport("Wintertodt Camp", GAMES_NECKLACE)));
					}

					if (necklaceOfPassage())
					{
						teleports.add(new Teleport(new WorldPoint(3114, 3179, 0), 2,
							() -> jewelryTeleport("Wizards' Tower", NECKLACE_OF_PASSAGE)));
						teleports.add(new Teleport(new WorldPoint(2430, 3348, 0), 2,
							() -> jewelryTeleport("The Outpost", NECKLACE_OF_PASSAGE)));
						teleports.add(new Teleport(new WorldPoint(3405, 3157, 0), 2,
							() -> jewelryTeleport("Eagle's Eyrie", NECKLACE_OF_PASSAGE)));
					}

					if (xericsTalisman())
					{
						teleports.add(new Teleport(new WorldPoint(1576, 3530, 0), 6,
												   () -> jewelryTeleport("Xeric's Lookout", XERICS_TALISMAN)));
						teleports.add(new Teleport(new WorldPoint(1752, 3566, 0), 6,
												   () -> jewelryTeleport("Xeric's Glade", XERICS_TALISMAN)));
						teleports.add(new Teleport(new WorldPoint(1504, 3817, 0), 6,
												   () -> jewelryTeleport("Xeric's Inferno", XERICS_TALISMAN)));
						if (Quests.isFinished(Quest.ARCHITECTURAL_ALLIANCE))
						{
							teleports.add(new Teleport(new WorldPoint(1640, 3674, 0), 6,
														() -> jewelryTeleport("Xeric's Heart", XERICS_TALISMAN)));
						}
					}

					if (digsitePendant())
					{
						teleports.add(new Teleport(new WorldPoint(3341, 3445, 0), 6,
								() -> jewelryTeleport("Digsite", DIGSITE_PENDANT)));
						teleports.add(new Teleport(new WorldPoint(3764, 3869, 1), 6,
								() -> jewelryTeleport("Fossil Island", DIGSITE_PENDANT)));
						if (Quests.isFinished(Quest.DRAGON_SLAYER_II))
						{
							teleports.add(new Teleport(new WorldPoint(3549, 10456, 0), 6,
								() -> jewelryTeleport("Lithkren", DIGSITE_PENDANT)));
						}
					}
				}

				if (Game.getWildyLevel() <= 30)
				{
					if (combatBracelet())
					{
						teleports.add(new Teleport(new WorldPoint(2882, 3548, 0), 2,
							() -> jewelryTeleport("Warriors' Guild", COMBAT_BRACELET)));
						teleports.add(new Teleport(new WorldPoint(3191, 3367, 0), 2,
							() -> jewelryTeleport("Champions' Guild", COMBAT_BRACELET)));
						teleports.add(new Teleport(new WorldPoint(3052, 3488, 0), 2,
							() -> jewelryTeleport("Monastery", COMBAT_BRACELET)));
						teleports.add(new Teleport(new WorldPoint(2655, 3441, 0), 2,
							() -> jewelryTeleport("Ranging Guild", COMBAT_BRACELET)));
					}

					if (skillsNecklace())
					{
						teleports.add(new Teleport(new WorldPoint(2611, 3390, 0), 6,
							() -> jewelryPopupTeleport("Fishing Guild", SKILLS_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(3050, 9763, 0), 6,
							() -> jewelryPopupTeleport("Mining Guild", SKILLS_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(2933, 3295, 0), 6,
							() -> jewelryPopupTeleport("Crafting Guild", SKILLS_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(3143, 3440, 0), 6,
							() -> jewelryPopupTeleport("Cooking Guild", SKILLS_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(1662, 3505, 0), 6,
							() -> jewelryPopupTeleport("Woodcutting Guild", SKILLS_NECKLACE)));
						teleports.add(new Teleport(new WorldPoint(1249, 3718, 0), 6,
							() -> jewelryPopupTeleport("Farming Guild", SKILLS_NECKLACE)));
					}

					if (ringOfWealth())
					{
						teleports.add(new Teleport(new WorldPoint(3163, 3478, 0), 2,
							() -> jewelryTeleport("Grand Exchange", RING_OF_WEALTH)));
						teleports.add(new Teleport(new WorldPoint(2996, 3375, 0), 2,
								() -> jewelryTeleport("Falador", RING_OF_WEALTH)));

						if (Quests.isFinished(Quest.THRONE_OF_MISCELLANIA))
						{
							teleports.add(new Teleport(new WorldPoint(2538, 3863, 0), 2,
									() -> jewelryTeleport("Miscellania", RING_OF_WEALTH)));
						}
						if (Quests.isFinished(Quest.BETWEEN_A_ROCK))
						{
							teleports.add(new Teleport(new WorldPoint(2828, 10166, 0), 2,
									() -> jewelryTeleport("Miscellania", RING_OF_WEALTH)));
						}

					}

					if (amuletOfGlory())
					{
						teleports.add(new Teleport(new WorldPoint(3087, 3496, 0), 0,
							() -> jewelryTeleport("Edgeville", AMULET_OF_GLORY)));
						teleports.add(new Teleport(new WorldPoint(2918, 3176, 0), 0,
							() -> jewelryTeleport("Karamja", AMULET_OF_GLORY)));
						teleports.add(new Teleport(new WorldPoint(3105, 3251, 0), 0,
							() -> jewelryTeleport("Draynor Village", AMULET_OF_GLORY)));
						teleports.add(new Teleport(new WorldPoint(3293, 3163, 0), 0,
							() -> jewelryTeleport("Al Kharid", AMULET_OF_GLORY)));
					}

					if (burningAmulet())
					{
						teleports.add(new Teleport(new WorldPoint(3235, 3636, 0), 5,
								() -> jewelryWildernessTeleport( "Chaos Temple", BURNING_AMULET)));
						teleports.add(new Teleport(new WorldPoint(3038, 3651, 0), 5,
								() -> jewelryWildernessTeleport("Bandit Camp", BURNING_AMULET)));
						teleports.add(new Teleport(new WorldPoint(3028, 3842, 0), 5,
								() -> jewelryWildernessTeleport( "Lava Maze", BURNING_AMULET)));
					}

					if (slayerRing())
					{
						teleports.add(new Teleport(new WorldPoint(2432, 3423, 0), 2,
								() -> slayerRingTeleport("Stronghold Slayer Cave", SLAYER_RING)));
						teleports.add(new Teleport(new WorldPoint(3422, 3537, 0), 2,
								() -> slayerRingTeleport("Slayer Tower", SLAYER_RING)));
						teleports.add(new Teleport(new WorldPoint(2802, 10000, 0), 2,
								() -> slayerRingTeleport("Fremennik Slayer Dungeon", SLAYER_RING)));
						teleports.add(new Teleport(new WorldPoint(3185, 4601, 0), 2,
								() -> slayerRingTeleport("Tarn's Lair", SLAYER_RING)));
						if (Quests.isFinished(Quest.MOURNINGS_END_PART_II))
						{
							teleports.add(new Teleport(new WorldPoint(2028, 4636, 0), 2,
								() -> slayerRingTeleport("Dark Beasts", SLAYER_RING)));
						}
					}
				}

				if (RegionManager.usePoh() && (canEnterHouse() || TileObjects.getNearest(ObjectID.PORTAL_4525) != null))
				{
					if (RegionManager.hasMountedGlory())
					{
						teleports.add(mountedPohTeleport(new WorldPoint(3087, 3496, 0), ObjectID.AMULET_OF_GLORY, "Edgeville"));
						teleports.add(mountedPohTeleport(new WorldPoint(2918, 3176, 0), ObjectID.AMULET_OF_GLORY, "Karamja"));
						teleports.add(mountedPohTeleport(new WorldPoint(3105, 3251, 0), ObjectID.AMULET_OF_GLORY, "Draynor Village"));
						teleports.add(mountedPohTeleport(new WorldPoint(3293, 3163, 0), ObjectID.AMULET_OF_GLORY, "Al Kharid"));
					}

					if (RegionManager.hasMountedDigsitePendant())
					{
						teleports.add(pohDigsitePendantTeleport(new WorldPoint(3341, 3445, 0), 1));
						teleports.add(pohDigsitePendantTeleport(new WorldPoint(3766, 3870, 1), 2));
						if (Quests.isFinished(Quest.DRAGON_SLAYER_II))
						{
							teleports.add(pohDigsitePendantTeleport(new WorldPoint(3549, 10456, 0), 3));
						}
					}

					switch (RegionManager.hasJewelryBox())
					{
						case ORNATE:
							if (Quests.isFinished(Quest.THRONE_OF_MISCELLANIA))
							{
								teleports.add(pohWidgetTeleport(new WorldPoint(2538, 3863, 0), 'j'));
							}
							teleports.add(pohWidgetTeleport(new WorldPoint(3163, 3478, 0), 'k'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2996, 3375, 0), 'l'));
							if (Quests.isFinished(Quest.BETWEEN_A_ROCK))
							{
								teleports.add(pohWidgetTeleport(new WorldPoint(2828, 10166, 0), 'm'));
							}
							teleports.add(pohWidgetTeleport(new WorldPoint(3087, 3496, 0), 'n'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2918, 3176, 0), 'o'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3105, 3251, 0), 'p'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3293, 3163, 0), 'q'));
						case FANCY:
							teleports.add(pohWidgetTeleport(new WorldPoint(2882, 3548, 0), '9'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3191, 3367, 0), 'a'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3052, 3488, 0), 'b'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2655, 3441, 0), 'c'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2611, 3390, 0), 'd'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3050, 9763, 0), 'e'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2933, 3295, 0), 'f'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3143, 3440, 0), 'g'));
							teleports.add(pohWidgetTeleport(new WorldPoint(1662, 3505, 0), 'h'));
							teleports.add(pohWidgetTeleport(new WorldPoint(1249, 3718, 0), 'i'));
						case BASIC:
							teleports.add(pohWidgetTeleport(new WorldPoint(3315, 3235, 0), '1'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2440, 3090, 0), '2'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3151, 3635, 0), '3'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2898, 3553, 0), '4'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2520, 3571, 0), '5'));
							teleports.add(pohWidgetTeleport(new WorldPoint(2964, 4382, 2), '6'));
							teleports.add(pohWidgetTeleport(new WorldPoint(3244, 9501, 2), '7'));
							teleports.add(pohWidgetTeleport(new WorldPoint(1624, 3938, 0), '8'));
							break;
						default:
					}

					//nexus portal
					List<Teleport> nexusTeleports = getNexusTeleports();
					teleports.addAll(nexusTeleports);

					//normal house portals (remove duplicate teleports)
					RegionManager.getHousePortals().stream().
						filter(housePortal -> nexusTeleports.stream().
							noneMatch(teleport -> teleport.getDestination().equals(housePortal.getDestination()))).
						forEach(housePortal -> teleports.add(pohPortalTeleport(housePortal)));
				}
			}

			LAST_TELEPORT_LIST.clear();
			LAST_TELEPORT_LIST.addAll(teleports);
		});
	}

	public static boolean canEnterHouse()
	{
		return Inventory.contains(ItemID.TELEPORT_TO_HOUSE) || TeleportSpell.TELEPORT_TO_HOUSE.canCast();
	}

	public static void enterHouse()
	{
		if (TeleportSpell.TELEPORT_TO_HOUSE.canCast())
		{
			SpellBook.Standard.TELEPORT_TO_HOUSE.cast();
			return;
		}

		Item teleTab = Inventory.getFirst(ItemID.TELEPORT_TO_HOUSE);
		if (teleTab != null)
		{
			teleTab.interact("Break");
		}
	}

	public static void jewelryTeleport(String target, int... ids)
	{
		Item inv = Inventory.getFirst(ids);

		if (inv != null)
		{
			if (!Dialog.isViewingOptions())
			{
				inv.interact("Rub");
				Time.sleepTicksUntil(Dialog::isViewingOptions, 2);
				return;
			}
			Dialog.chooseOption(target);
			return;
		}

		if (!RegionManager.useEquipmentJewellery())
		{
			return;
		}

		Item equipped = Equipment.getFirst(ids);
		if (equipped != null)
		{
			equipped.interact(target);
		}
	}

	public static Teleport pohPortalTeleport(HousePortal housePortal)
	{
		return new Teleport(housePortal.getDestination(), 10, () ->
		{
			if (!Players.getLocal().isIdle() || Static.getClient().getGameState() == GameState.LOADING)
			{
				return;
			}

			TileObject portal = TileObjects.getNearest(housePortal.getPortalName());
			if (portal != null)
			{
				portal.interact("Enter", "Varrock", "Seers' Village", "Watchtower");
				return;
			}

			enterHouse();
		});
	}

	public static List<Teleport> getNexusTeleports()
	{
		List<Teleport> result = new ArrayList<>();
		int[] varbitArray = {
			6672, 6673, 6674, 6675, 6676, 6677, 6678, 6679, 6680,
			6681, 6682, 6683, 6684, 6685, 6686, 6568, 6569, 6582,
			10092, 10093, 10094, 10095, 10096, 10097, 10098,
			10099, 10100, 10101, 10102, 10103
		};

		for (int varbit : varbitArray)
		{
			int id = Vars.getBit(varbit);
			switch (id)
			{
				case 0:
				{
					break;
				}
				case 1:
				{
					result.add(pohNexusTeleport(HousePortal.VARROCK));
					break;
				}
				case 2:
				{
					result.add(pohNexusTeleport(HousePortal.LUMBRIDGE));
					break;
				}
				case 3:
				{
					result.add(pohNexusTeleport(HousePortal.FALADOR));
					break;
				}
				case 4:
				{
					result.add(pohNexusTeleport(HousePortal.CAMELOT));
					break;
				}
				case 5:
				{
					result.add(pohNexusTeleport(HousePortal.EAST_ARDOUGNE));
					break;
				}
				case 6:
				{
					result.add(pohNexusTeleport(HousePortal.WATCHTOWER));
					break;
				}
				case 7:
				{
					result.add(pohNexusTeleport(HousePortal.SENNTISTEN));
					break;
				}
				case 8:
				{
					result.add(pohNexusTeleport(HousePortal.MARIM));
					break;
				}
				case 9:
				{
					result.add(pohNexusTeleport(HousePortal.KHARYRLL));
					break;
				}
				case 10:
				{
					result.add(pohNexusTeleport(HousePortal.LUNAR_ISLE));
					break;
				}
				case 11:
				{
					result.add(pohNexusTeleport(HousePortal.KOUREND));
					break;
				}
				case 12:
				{
					result.add(pohNexusTeleport(HousePortal.WATERBIRTH_ISLAND));
					break;
				}
				case 13:
				{
					result.add(pohNexusTeleport(HousePortal.FISHING_GUILD));
					break;
				}
				case 14:
				{
					result.add(pohNexusTeleport(HousePortal.ANNAKARL)); //wilderness
					break;
				}
				case 15:
				{
					result.add(pohNexusTeleport(HousePortal.TROLL_STRONGHOLD));
					break;
				}
				case 16:
				{
					result.add(pohNexusTeleport(HousePortal.CATHERBY));
					break;
				}
				case 17:
				{
					result.add(pohNexusTeleport(HousePortal.GHORROCK)); //wilderness
					break;
				}
				case 18:
				{
					result.add(pohNexusTeleport(HousePortal.CARRALLANGAR)); //wilderness
					break;
				}
				case 19:
				{
					result.add(pohNexusTeleport(HousePortal.WEISS));
					break;
				}
				case 20:
				{
					result.add(pohNexusTeleport(HousePortal.ARCEUUS_LIBRARY));
					break;
				}
				case 21:
				{
					result.add(pohNexusTeleport(HousePortal.DRAYNOR_MANOR));
					break;
				}
				case 22:
				{
					result.add(pohNexusTeleport(HousePortal.BATTLEFRONT));
					break;
				}
				case 23:
				{
					result.add(pohNexusTeleport(HousePortal.MIND_ALTAR));
					break;
				}
				case 24:
				{
					result.add(pohNexusTeleport(HousePortal.SALVE_GRAVEYARD));
					break;
				}
				case 25:
				{
					result.add(pohNexusTeleport(HousePortal.FENKENSTRAINS_CASTLE));
					break;
				}
				case 26:
				{
					result.add(pohNexusTeleport(HousePortal.WEST_ARDOUGNE));
					break;
				}
				case 27:
				{
					result.add(pohNexusTeleport(HousePortal.HARMONY_ISLAND));
					break;
				}
				case 28:
				{
					result.add(pohNexusTeleport(HousePortal.CEMETERY)); //wilderness
					break;
				}
				case 29:
				{
					result.add(pohNexusTeleport(HousePortal.BARROWS));
					break;
				}
				case 30:
				{
					result.add(pohNexusTeleport(HousePortal.APE_ATOLL_DUNGEON));
					break;
				}
			}
		}

		return result;
	}

	public static Teleport pohNexusTeleport(HousePortal housePortal)
	{
		WorldPoint destination = housePortal.getDestination();
		return new Teleport(destination, 10, () ->
		{
			if (!Players.getLocal().isIdle() || Static.getClient().getGameState() == GameState.LOADING)
			{
				return;
			}

			TileObject nexusPortal = TileObjects.getNearest("Portal Nexus");
			if (nexusPortal == null)
			{
				enterHouse();
				return;
			}

			Widget teleportInterface = Widgets.get(17, 12);
			if (teleportInterface == null || teleportInterface.isHidden())
			{
				nexusPortal.interact("Teleport Menu");
				return;
			}

			Widget[] teleportChildren = teleportInterface.getDynamicChildren();
			if (teleportChildren == null || teleportChildren.length == 0)
			{
				//no teleports in the portal
				return;
			}

			Optional<Widget> optionalTeleportWidget = Arrays.stream(teleportChildren).
				filter(Objects::nonNull).
				filter(widget -> widget.getText() != null).
				filter(widget -> widget.getText().contains(housePortal.getNexusTarget())).
				findFirst();

			if (optionalTeleportWidget.isEmpty())
			{
				//the teleport is not in the list
				return;
			}

			Widget teleportWidget = optionalTeleportWidget.get();
			String teleportChar = teleportWidget.getText().substring(12, 13);
			Keyboard.type(teleportChar);
		});
	}

	public static void jewelryPopupTeleport(String target, int... ids)
	{
		Item inv = Inventory.getFirst(ids);

		if (inv != null)
		{
			Widget baseWidget = Widgets.get(187, 3);
			if (Widgets.isVisible(baseWidget))
			{
				Widget[] children = baseWidget.getChildren();
				if (children == null)
				{
					return;
				}

				for (int i = 0; i < children.length; i++)
				{
					Widget teleportItem = children[i];
					if (teleportItem.getText().contains(target))
					{
						Keyboard.type((i + 1));
						return;
					}
				}
			}

			inv.interact("Rub");
			return;
		}

		if (!RegionManager.useEquipmentJewellery())
		{
			return;
		}

		Item equipped = Equipment.getFirst(ids);
		if (equipped != null)
		{
			equipped.interact(target);
		}
	}

	public static Teleport pohDigsitePendantTeleport(
			WorldPoint destination,
			int action
	)
	{
		return new Teleport(destination, 10, () ->
		{
			if (!Players.getLocal().isIdle() || Static.getClient().getGameState() == GameState.LOADING)
			{
				return;
			}

			if (Widgets.isVisible(Widgets.get(WidgetInfo.ADVENTURE_LOG)))
			{
				Keyboard.type(action);
				return;
			}

			TileObject digsitePendant = TileObjects.getNearest("Digsite Pendant");
			if (digsitePendant != null)
			{
				digsitePendant.interact("Teleport menu");
				return;
			}

			enterHouse();
		});
	}

	public static Teleport itemTeleport(TeleportItem teleportItem)
	{
			return new Teleport(teleportItem.getDestination(), 5, () ->
			{
				Item item = Inventory.getFirst(teleportItem.getItemId());
				if (item != null)
				{
					item.interact(teleportItem.getAction());
				}
			});
	}


	public static Teleport pohWidgetTeleport(
			WorldPoint destination,
			char action
	)
	{
		return new Teleport(destination, 10, () ->
		{
			if (!Players.getLocal().isIdle() || Static.getClient().getGameState() == GameState.LOADING)
			{
				return;
			}

			if (Widgets.isVisible(Widgets.get(WidgetID.JEWELLERY_BOX_GROUP_ID, 0)))
			{
				Keyboard.type(action);
				return;
			}

			TileObject box = TileObjects.getNearest(to -> to.getName() != null && to.getName().contains("Jewellery Box"));
			if (box != null)
			{
				box.interact("Teleport Menu");
				return;
			}

			enterHouse();
		});
	}

	public static Teleport mountedPohTeleport(
			WorldPoint destination,
			int objId,
			String action
	)
	{
		return new Teleport(destination, 10, () ->
		{
			if (!Players.getLocal().isIdle() || Static.getClient().getGameState() == GameState.LOADING)
			{
				return;
			}

			TileObject first = TileObjects.getNearest(objId);
			if (first != null)
			{
				first.interact(action);
				return;
			}

			enterHouse();
		});
	}

	public static void jewelryWildernessTeleport(String target, int... ids)
	{
		jewelryTeleport(target, ids);
		Time.sleepTick();
		if (Dialog.isViewingOptions() && Dialog.getOptions().stream()
				.anyMatch(it -> it.getText() != null && WILDY_PATTERN.matcher(it.getText()).matches()))
		{
			Dialog.chooseOption(1);
		}
	}

	public static void slayerRingTeleport(String target, int... ids)
	{
		Item ring = Inventory.getFirst(ids);

		if (ring == null && RegionManager.useEquipmentJewellery())
		{
			ring = Equipment.getFirst(ids);
		}

		if (ring != null)
		{
			if (!Dialog.isViewingOptions())
			{
				ring.interact("Teleport");
				Time.sleepTicksUntil(Dialog::isViewingOptions, 2);
				return;
			}
			if (Dialog.hasOption("Teleport"))
			{
				Dialog.chooseOption("Teleport");
				return;
			}
			Dialog.chooseOption(target);
		}
	}

	public static boolean ringOfDueling()
	{
		return Inventory.getFirst(RING_OF_DUELING) != null
			|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(RING_OF_DUELING) != null);
	}

	public static boolean gamesNecklace()
	{
		return Inventory.getFirst(GAMES_NECKLACE) != null
			|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(GAMES_NECKLACE) != null);
	}

	public static boolean combatBracelet()
	{
		return Inventory.getFirst(COMBAT_BRACELET) != null
			|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(COMBAT_BRACELET) != null);
	}

	public static boolean skillsNecklace()
	{
		return Inventory.getFirst(SKILLS_NECKLACE) != null
			|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(SKILLS_NECKLACE) != null);
	}

	public static boolean ringOfWealth()
	{
		return Inventory.getFirst(RING_OF_WEALTH) != null
			|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(RING_OF_WEALTH) != null);
	}

	public static boolean amuletOfGlory()
	{
		return Inventory.getFirst(AMULET_OF_GLORY) != null
			|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(AMULET_OF_GLORY) != null);
	}

	public static boolean necklaceOfPassage()
	{
		return Inventory.getFirst(NECKLACE_OF_PASSAGE) != null
			|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(NECKLACE_OF_PASSAGE) != null);
	}

	public static boolean xericsTalisman()
	{
		return Inventory.getFirst(XERICS_TALISMAN) != null
				|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(XERICS_TALISMAN) != null);
	}

	public static boolean slayerRing()
	{
		return Inventory.getFirst(SLAYER_RING) != null
				|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(SLAYER_RING) != null);
	}

	public static boolean digsitePendant()
	{
		return Inventory.getFirst(DIGSITE_PENDANT) != null
				|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(DIGSITE_PENDANT) != null);
	}

	public static boolean burningAmulet()
	{
		return Inventory.getFirst(BURNING_AMULET) != null
				|| (RegionManager.useEquipmentJewellery() && Equipment.getFirst(BURNING_AMULET) != null);
	}
}

package net.unethicalite.api.movement.pathfinder.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.api.magic.Spell;
import net.unethicalite.api.magic.SpellBook;

@AllArgsConstructor
@Getter
public enum TeleportSpell
{
	LUMBRIDGE_HOME_TELEPORT(
			SpellBook.Standard.HOME_TELEPORT,
			new WorldPoint(3225, 3219, 0)
	),
	TELEPORT_TO_HOUSE(
			SpellBook.Standard.TELEPORT_TO_HOUSE,
			MovementConstants.HOUSE_POINT
	),
	VARROCK_TELEPORT(
			SpellBook.Standard.VARROCK_TELEPORT,
			new WorldPoint(3212, 3424, 0)
	),
	LUMBRIDGE_TELEPORT(
			SpellBook.Standard.LUMBRIDGE_TELEPORT,
			new WorldPoint(3225, 3219, 0)
	),
	FALADOR_TELEPORT(
			SpellBook.Standard.FALADOR_TELEPORT,
			new WorldPoint(2966, 3379, 0)
	),
	CAMELOT_TELEPORT(
			SpellBook.Standard.CAMELOT_TELEPORT,
			new WorldPoint(2757, 3479, 0)
	),
	ARDOUGNE_TELEPORT(
			SpellBook.Standard.ARDOUGNE_TELEPORT,
			new WorldPoint(2661, 3300, 0)
	),
	WATCHTOWER_TELEPORT(
			SpellBook.Standard.WATCHTOWER_TELEPORT,
			new WorldPoint(2931, 4717, 2)
	),
	TROLLHEIM_TELEPORT(
			SpellBook.Standard.TROLLHEIM_TELEPORT,
			new WorldPoint(2888, 367, 0)
	),
	TELEPORT_TO_KOUREND(
			SpellBook.Standard.TELEPORT_TO_KOUREND,
			new WorldPoint(1643, 3673, 0)
	),
	TELEPORT_TO_APE_ATOLL(
			SpellBook.Standard.TELEPORT_TO_APE_ATOLL,
			new WorldPoint(2796, 2791, 0)
	),

	// ANCIENT TELEPORTS
	EDGEVILLE_HOME_TELEPORT(
			SpellBook.Ancient.EDGEVILLE_HOME_TELEPORT,
			new WorldPoint(3087, 3496, 0)
	),
	PADDEWWA_TELEPORT(
			SpellBook.Ancient.PADDEWWA_TELEPORT,
			new WorldPoint(3098, 9883, 0)
	),
	SENNTISTEN_TELEPORT(
			SpellBook.Ancient.SENNTISTEN_TELEPORT,
			new WorldPoint(3321, 3335, 0)
	),
	KHARYRLL_TELEPORT(
			SpellBook.Ancient.KHARYRLL_TELEPORT,
			new WorldPoint(3493, 3474, 0)
	),
	LASSAR_TELEPORT(
			SpellBook.Ancient.LASSAR_TELEPORT,
			new WorldPoint(3004, 3468, 0)
	),
	DAREEYAK_TELEPORT(
			SpellBook.Ancient.DAREEYAK_TELEPORT,
			new WorldPoint(2969, 3695, 0)
	),
	CARRALLANGER_TELEPORT(
			SpellBook.Ancient.CARRALLANGER_TELEPORT,
			new WorldPoint(3157, 3667, 0)
	),
	ANNAKARL_TELEPORT(
			SpellBook.Ancient.ANNAKARL_TELEPORT,
			new WorldPoint(3288, 3888, 0)
	),
	GHORROCK_TELEPORT(
			SpellBook.Ancient.GHORROCK_TELEPORT,
			new WorldPoint(2977, 3872, 0)
	),

	// LUNAR TELEPORTS
	LUNAR_HOME_TELEPORT(
			SpellBook.Lunar.LUNAR_HOME_TELEPORT,
			new WorldPoint(2094, 3914, 0)
	),
	MOONCLAN_TELEPORT(
			SpellBook.Lunar.MOONCLAN_TELEPORT,
			new WorldPoint(2113, 3917, 0)
	),
	OURANIA_TELEPORT(
			SpellBook.Lunar.OURANIA_TELEPORT,
			new WorldPoint(2470, 3247, 0)),
	WATERBIRTH_TELEPORT(
			SpellBook.Lunar.WATERBIRTH_TELEPORT,
			new WorldPoint(2548, 3758, 0)
	),
	BARBARIAN_TELEPORT(
			SpellBook.Lunar.BARBARIAN_TELEPORT,
			new WorldPoint(2545, 3571, 0)
	),
	KHAZARD_TELEPORT(
			SpellBook.Lunar.KHAZARD_TELEPORT,
			new WorldPoint(2637, 3168, 0)
	),
	FISHING_GUILD_TELEPORT(
			SpellBook.Lunar.FISHING_GUILD_TELEPORT,
			new WorldPoint(2610, 3389, 0)
	),
	CATHERBY_TELEPORT(
			SpellBook.Lunar.CATHERBY_TELEPORT,
			new WorldPoint(2802, 3449, 0)
	),
	ICE_PLATEAU_TELEPORT(
			SpellBook.Lunar.ICE_PLATEAU_TELEPORT,
			new WorldPoint(2973, 3939, 0)
	),

	// NECROMANCY TELEPORTS
	ARCEUUS_HOME_TELEPORT(
			SpellBook.Necromancy.ARCEUUS_HOME_TELEPORT,
			new WorldPoint(1699, 3882, 0)
	),
	ARCEUUS_LIBRARY_TELEPORT(
			SpellBook.Necromancy.ARCEUUS_LIBRARY_TELEPORT,
			new WorldPoint(1634, 3836, 0)
	),
	DRAYNOR_MANOR_TELEPORT(
			SpellBook.Necromancy.DRAYNOR_MANOR_TELEPORT,
			new WorldPoint(3109, 3352, 0)
	),
	BATTLEFRONT_TELEPORT(
			SpellBook.Necromancy.BATTLEFRONT_TELEPORT,
			new WorldPoint(1350, 3740, 0)
	),
	MIND_ALTAR_TELEPORT(
			SpellBook.Necromancy.MIND_ALTAR_TELEPORT,
			new WorldPoint(2978, 3508, 0)
	),
	RESPAWN_TELEPORT(
			SpellBook.Necromancy.RESPAWN_TELEPORT,
			new WorldPoint(3262, 6074, 0)
	),
	SALVE_GRAVEYARD_TELEPORT(
			SpellBook.Necromancy.SALVE_GRAVEYARD_TELEPORT,
			new WorldPoint(3431, 3460, 0)
	),
	FENKENSTRAINS_CASTLE_TELEPORT(
			SpellBook.Necromancy.FENKENSTRAINS_CASTLE_TELEPORT,
			new WorldPoint(3546, 3528, 0)
	),
	WEST_ARDOUGNE_TELEPORT(
			SpellBook.Necromancy.WEST_ARDOUGNE_TELEPORT,
			new WorldPoint(2502, 3291, 0)
	),
	HARMONY_ISLAND_TELEPORT(
			SpellBook.Necromancy.HARMONY_ISLAND_TELEPORT,
			new WorldPoint(3799, 2867, 0)
	),
	CEMETERY_TELEPORT(
			SpellBook.Necromancy.CEMETERY_TELEPORT,
			new WorldPoint(2978, 3763, 0)
	),
	BARROWS_TELEPORT(
			SpellBook.Necromancy.BARROWS_TELEPORT,
			new WorldPoint(3563, 3313, 0)
	),
	APE_ATOLL_TELEPORT(
			SpellBook.Necromancy.APE_ATOLL_TELEPORT,
			new WorldPoint(2769, 9100, 0)
	),
	;

	private final Spell spell;
	private final WorldPoint point;

	public boolean canCast()
	{
		return spell.canCast();
	}
}

package net.unethicalite.api.entities;

import net.unethicalite.api.SceneEntity;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.scene.Tiles;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public abstract class TileEntities<T extends SceneEntity> extends Entities<T>
{
	protected abstract List<T> at(Tile tile, Predicate<? super T> filter);

	protected List<T> at(Tile tile, int... ids)
	{
		return at(tile, Predicates.ids(ids));
	}

	protected List<T> at(Tile tile, String... names)
	{
		return at(tile, Predicates.names(names));
	}

	protected List<T> surrounding(int worldX, int worldY, int plane, int radius, Predicate<? super T> filter)
	{
		List<T> out = new ArrayList<>();
		for (int x = -radius; x <= radius; x++)
		{
			for (int y = -radius; y <= radius; y++)
			{
				out.addAll(at(Tiles.getAt(worldX + x, worldY + y, plane), filter));
			}
		}

		return out;
	}

	protected List<T> surrounding(int worldX, int worldY, int plane, int radius, int... ids)
	{
		return surrounding(worldX, worldY, plane, radius, Predicates.ids(ids));
	}

	protected List<T> surrounding(int worldX, int worldY, int plane, int radius, String... names)
	{
		return surrounding(worldX, worldY, plane, radius, Predicates.names(names));
	}


	protected List<T> in(WorldArea area, Predicate<? super T> filter)
	{
		List<T> out = new ArrayList<>();
		for (WorldPoint worldPoint : area.toWorldPointList())
		{
			out.addAll(at(Tiles.getAt(worldPoint), filter));
		}

		return out;
	}

	protected List<T> in(WorldArea area, int... ids)
	{
		return in(area, Predicates.ids(ids));
	}

	protected List<T> in(WorldArea area, String... names)
	{
		return in(area, Predicates.names(names));
	}
}

package net.unethicalite.api.query.entities;

import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.query.results.SceneEntityQueryResults;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import org.apache.commons.lang3.ArrayUtils;

import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;

public class TileItemQuery extends SceneEntityQuery<TileItem, TileItemQuery>
{
	private int[] quantities = null;
	private Tile[] tiles = null;
	private Boolean tradable = null;
	private Boolean stackable = null;
	private Boolean noted = null;
	private Boolean members = null;
	private Integer storePrice = null;
	private String[] inventoryActions = null;

	public TileItemQuery(Supplier<List<TileItem>> supplier)
	{
		super(supplier);
	}

	public TileItemQuery quantities(int... quantities)
	{
		this.quantities = quantities;
		return this;
	}

	public TileItemQuery tiles(Tile... tiles)
	{
		this.tiles = tiles;
		return this;
	}

	public TileItemQuery tradable(boolean tradable)
	{
		this.tradable = tradable;
		return this;
	}

	public TileItemQuery stackable(boolean stackable)
	{
		this.stackable = stackable;
		return this;
	}

	public TileItemQuery noted(boolean noted)
	{
		this.noted = noted;
		return this;
	}

	public TileItemQuery members(boolean members)
	{
		this.members = members;
		return this;
	}

	public TileItemQuery storePrice(int storePrice)
	{
		this.storePrice = storePrice;
		return this;
	}

	public TileItemQuery inventoryActions(String... inventoryActions)
	{
		this.inventoryActions = inventoryActions;
		return this;
	}

	@Override
	protected SceneEntityQueryResults<TileItem> results(List<TileItem> list)
	{
		return new SceneEntityQueryResults<>(list);
	}

	@Override
	public boolean test(TileItem tileItem)
	{
		if (quantities != null && !ArrayUtils.contains(quantities, tileItem.getQuantity()))
		{
			return false;
		}

		if (tiles != null && !ArrayUtils.contains(tiles, tileItem.getTile()))
		{
			return false;
		}

		if (tradable != null && !tradable.equals(tileItem.isTradable()))
		{
			return false;
		}

		if (stackable != null && !stackable.equals(tileItem.isStackable()))
		{
			return false;
		}

		if (noted != null && !noted.equals(tileItem.isNoted()))
		{
			return false;
		}

		if (members != null && !members.equals(tileItem.isMembers()))
		{
			return false;
		}

		if (storePrice != null && !storePrice.equals(tileItem.getStorePrice()))
		{
			return false;
		}

		if (inventoryActions != null
				&& Arrays.stream(inventoryActions).noneMatch(Predicates.texts(tileItem.getInventoryActions())))
		{
			return false;
		}

		return super.test(tileItem);
	}
}

package net.unethicalite.api.entities;

import net.unethicalite.api.query.entities.TileItemQuery;
import net.unethicalite.api.scene.Tiles;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public class TileItems extends TileEntities<TileItem>
{
	private static final TileItems TILE_ITEMS = new TileItems();

	private TileItems()
	{
	}

	public static TileItemQuery query()
	{
		return query(TileItems::getAll);
	}

	public static TileItemQuery query(Supplier<List<TileItem>> supplier)
	{
		return new TileItemQuery(supplier);
	}

	public static List<TileItem> getAll()
	{
		return getAll(x -> true);
	}

	public static List<TileItem> getAll(Predicate<TileItem> filter)
	{
		return TILE_ITEMS.all(filter);
	}

	public static List<TileItem> getAll(int... ids)
	{
		return TILE_ITEMS.all(ids);
	}

	public static List<TileItem> getAll(String... names)
	{
		return TILE_ITEMS.all(names);
	}

	public static TileItem getNearest(Predicate<TileItem> filter)
	{
		return getNearest(Players.getLocal().getWorldLocation(), filter);
	}

	public static TileItem getNearest(int... ids)
	{
		return getNearest(Players.getLocal().getWorldLocation(), ids);
	}

	public static TileItem getNearest(String... names)
	{
		return getNearest(Players.getLocal().getWorldLocation(), names);
	}

	public static TileItem getNearest(WorldPoint to, Predicate<TileItem> filter)
	{
		return TILE_ITEMS.nearest(to, filter);
	}

	public static TileItem getNearest(WorldPoint to, int... ids)
	{
		return TILE_ITEMS.nearest(to, ids);
	}

	public static TileItem getNearest(WorldPoint to, String... names)
	{
		return TILE_ITEMS.nearest(to, names);
	}

	public static List<TileItem> getAt(int worldX, int worldY, int plane, int... ids)
	{
		return getAt(Tiles.getAt(worldX, worldY, plane), ids);
	}

	public static List<TileItem> getAt(int worldX, int worldY, int plane, String... names)
	{
		return getAt(Tiles.getAt(worldX, worldY, plane), names);
	}

	public static List<TileItem> getAt(int worldX, int worldY, int plane, Predicate<TileItem> filter)
	{
		return getAt(Tiles.getAt(worldX, worldY, plane), filter);
	}

	public static List<TileItem> getAt(WorldPoint worldPoint, Predicate<TileItem> filter)
	{
		return getAt(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), filter);
	}

	public static List<TileItem> getAt(WorldPoint worldPoint, int... ids)
	{
		return getAt(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), ids);
	}

	public static List<TileItem> getAt(WorldPoint worldPoint, String... names)
	{
		return getAt(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), names);
	}

	public static List<TileItem> getAt(Tile tile, int... ids)
	{
		return TILE_ITEMS.at(tile, ids);
	}

	public static List<TileItem> getAt(Tile tile, String... names)
	{
		return TILE_ITEMS.at(tile, names);
	}

	public static List<TileItem> getAt(Tile tile, Predicate<TileItem> filter)
	{
		if (tile == null)
		{
			return Collections.emptyList();
		}

		return TILE_ITEMS.at(tile, filter);
	}

	public static TileItem getFirstAt(int worldX, int worldY, int plane, int... ids)
	{
		return getAt(worldX, worldY, plane, ids).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(int worldX, int worldY, int plane, String... names)
	{
		return getAt(worldX, worldY, plane, names).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(int worldX, int worldY, int plane, Predicate<TileItem> filter)
	{
		return getAt(worldX, worldY, plane, filter).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(WorldPoint worldPoint, int... ids)
	{
		return getAt(worldPoint, ids).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(WorldPoint worldPoint, String... names)
	{
		return getAt(worldPoint, names).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(WorldPoint worldPoint, Predicate<TileItem> filter)
	{
		return getAt(worldPoint, filter).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(Tile tile, int... ids)
	{
		return getAt(tile, ids).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(Tile tile, String... names)
	{
		return getAt(tile, names).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstAt(Tile tile, Predicate<TileItem> filter)
	{
		return getAt(tile, filter).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(int worldX, int worldY, int plane, int radius, int... ids)
	{
		return getSurrounding(worldX, worldY, plane, radius, ids).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(int worldX, int worldY, int plane, int radius, String... names)
	{
		return getSurrounding(worldX, worldY, plane, radius, names).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(int worldX, int worldY, int plane, int radius, Predicate<TileItem> filter)
	{
		return getSurrounding(worldX, worldY, plane, radius, filter).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(WorldPoint worldPoint, int radius, int... ids)
	{
		return getSurrounding(worldPoint, radius, ids).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(WorldPoint worldPoint, int radius, String... names)
	{
		return getSurrounding(worldPoint, radius, names).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(WorldPoint worldPoint, int radius, Predicate<TileItem> filter)
	{
		return getSurrounding(worldPoint, radius, filter).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(Tile tile, int radius, int... ids)
	{
		return getSurrounding(tile, radius, ids).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(Tile tile, int radius, String... names)
	{
		return getSurrounding(tile, radius, names).stream().findFirst().orElse(null);
	}

	public static TileItem getFirstSurrounding(Tile tile, int radius, Predicate<TileItem> filter)
	{
		return getSurrounding(tile, radius, filter).stream().findFirst().orElse(null);
	}

	public static List<TileItem> getSurrounding(int worldX, int worldY, int plane, int radius, int... ids)
	{
		return TILE_ITEMS.surrounding(worldX, worldY, plane, radius, ids);
	}

	public static List<TileItem> getSurrounding(int worldX, int worldY, int plane, int radius, String... names)
	{
		return TILE_ITEMS.surrounding(worldX, worldY, plane, radius, names);
	}

	public static List<TileItem> getSurrounding(int worldX, int worldY, int plane, int radius, Predicate<TileItem> filter)
	{
		return TILE_ITEMS.surrounding(worldX, worldY, plane, radius, filter);
	}

	public static List<TileItem> getSurrounding(WorldPoint worldPoint, int radius, int... ids)
	{
		return getSurrounding(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), radius, ids);
	}

	public static List<TileItem> getSurrounding(WorldPoint worldPoint, int radius, String... names)
	{
		return getSurrounding(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), radius, names);
	}

	public static List<TileItem> getSurrounding(WorldPoint worldPoint, int radius, Predicate<TileItem> filter)
	{
		return getSurrounding(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), radius, filter);
	}

	public static List<TileItem> getSurrounding(Tile tile, int radius, int... ids)
	{
		return getSurrounding(tile.getWorldX(), tile.getWorldY(), tile.getPlane(), radius, ids);
	}

	public static List<TileItem> getSurrounding(Tile tile, int radius, String... names)
	{
		return getSurrounding(tile.getWorldX(), tile.getWorldY(), tile.getPlane(), radius, names);
	}

	public static List<TileItem> getSurrounding(Tile tile, int radius, Predicate<TileItem> filter)
	{
		return getSurrounding(tile.getWorldX(), tile.getWorldY(), tile.getPlane(), radius, filter);
	}

	public static List<TileItem> within(WorldArea area, String... names)
	{
		return TILE_ITEMS.in(area, names);
	}

	public static List<TileItem> within(WorldArea area, int... ids)
	{
		return TILE_ITEMS.in(area, ids);
	}

	public static List<TileItem> within(WorldArea area, Predicate<TileItem> filter)
	{
		return TILE_ITEMS.in(area, filter);
	}

	@Override
	protected List<TileItem> all(Predicate<? super TileItem> filter)
	{
		return Tiles.getAll().stream()
				.flatMap(tile -> at(tile, filter).stream())
				.collect(Collectors.toList());
	}

	@Override
	protected List<TileItem> at(Tile tile, Predicate<? super TileItem> filter)
	{
		List<TileItem> out = new ArrayList<>();
		if (tile == null)
		{
			return out;
		}

		if (tile.getGroundItems() != null)
		{
			for (TileItem item : tile.getGroundItems())
			{
				if (item == null || item.getId() == -1)
				{
					continue;
				}

				if (!filter.test(item))
				{
					continue;
				}

				out.add(item);
			}
		}

		return out;
	}
}

package net.unethicalite.api.query.entities;

import net.unethicalite.api.query.results.SceneEntityQueryResults;
import net.unethicalite.api.scene.Tiles;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import org.apache.commons.lang3.ArrayUtils;

import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;

public class TileObjectQuery extends SceneEntityQuery<TileObject, TileObjectQuery>
{
	private Tile[] tiles = null;
	private Class<? extends TileObject>[] is = null;

	public TileObjectQuery(Supplier<List<TileObject>> supplier)
	{
		super(supplier);
	}

	public TileObjectQuery tiles(Tile... tiles)
	{
		this.tiles = tiles;
		return this;
	}

	@SafeVarargs
	public final TileObjectQuery is(Class<? extends TileObject>... classes)
	{
		this.is = classes;
		return this;
	}

	@Override
	protected SceneEntityQueryResults<TileObject> results(List<TileObject> list)
	{
		return new SceneEntityQueryResults<>(list);
	}

	@Override
	public boolean test(TileObject tileObject)
	{
		if (tiles != null && !ArrayUtils.contains(tiles, Tiles.getAt(tileObject.getWorldLocation())))
		{
			return false;
		}

		if (is != null && Arrays.stream(is).noneMatch(clazz -> clazz.isInstance(tileObject)))
		{
			return false;
		}

		return super.test(tileObject);
	}
}

package net.unethicalite.api.entities;

import net.unethicalite.api.query.entities.TileObjectQuery;
import net.unethicalite.api.scene.Tiles;
import net.runelite.api.DecorativeObject;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.client.Static;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public class TileObjects extends TileEntities<TileObject>
{
	private static final TileObjects TILE_OBJECTS = new TileObjects();

	private TileObjects()
	{
	}

	public static TileObjectQuery query()
	{
		return query(TileObjects::getAll);
	}

	public static TileObjectQuery query(Supplier<List<TileObject>> supplier)
	{
		return new TileObjectQuery(supplier);
	}

	public static List<TileObject> getAll()
	{
		return getAll(x -> true);
	}

	public static List<TileObject> getAll(Predicate<TileObject> filter)
	{
		return TILE_OBJECTS.all(filter);
	}

	public static List<TileObject> getAll(int... ids)
	{
		return TILE_OBJECTS.all(ids);
	}

	public static List<TileObject> getAll(String... names)
	{
		return TILE_OBJECTS.all(names);
	}

	public static TileObject getNearest(Predicate<TileObject> filter)
	{
		return TILE_OBJECTS.nearest(Players.getLocal().getWorldLocation(), filter);
	}

	public static TileObject getNearest(int... ids)
	{
		return TILE_OBJECTS.nearest(Players.getLocal().getWorldLocation(), ids);
	}

	public static TileObject getNearest(String... names)
	{
		return TILE_OBJECTS.nearest(Players.getLocal().getWorldLocation(), names);
	}

	public static TileObject getNearest(WorldPoint to, Predicate<TileObject> filter)
	{
		return TILE_OBJECTS.nearest(to, filter);
	}

	public static TileObject getNearest(WorldPoint to, int... ids)
	{
		return TILE_OBJECTS.nearest(to, ids);
	}

	public static TileObject getNearest(WorldPoint to, String... names)
	{
		return TILE_OBJECTS.nearest(to, names);
	}

	public static List<TileObject> getAt(int worldX, int worldY, int plane, int... ids)
	{
		return TILE_OBJECTS.at(Tiles.getAt(worldX, worldY, plane), ids);
	}

	public static List<TileObject> getAt(int worldX, int worldY, int plane, String... names)
	{
		return TILE_OBJECTS.at(Tiles.getAt(worldX, worldY, plane), names);
	}

	public static List<TileObject> getAt(int worldX, int worldY, int plane, Predicate<TileObject> filter)
	{
		return TILE_OBJECTS.at(Tiles.getAt(worldX, worldY, plane), filter);
	}

	public static List<TileObject> getAt(WorldPoint worldPoint, Predicate<TileObject> filter)
	{
		return TILE_OBJECTS.at(Tiles.getAt(worldPoint), filter);
	}

	public static List<TileObject> getAt(WorldPoint worldPoint, int... ids)
	{
		return TILE_OBJECTS.at(Tiles.getAt(worldPoint), ids);
	}

	public static List<TileObject> getAt(WorldPoint worldPoint, String... names)
	{
		return TILE_OBJECTS.at(Tiles.getAt(worldPoint), names);
	}

	public static List<TileObject> getAt(Tile tile, int... ids)
	{
		return TILE_OBJECTS.at(tile, ids);
	}

	public static List<TileObject> getAt(Tile tile, String... names)
	{
		return TILE_OBJECTS.at(tile, names);
	}

	public static List<TileObject> getAt(Tile tile, Predicate<TileObject> filter)
	{
		if (tile == null)
		{
			return Collections.emptyList();
		}

		return TILE_OBJECTS.at(tile, filter);
	}

	public static TileObject getFirstAt(int worldX, int worldY, int plane, int... ids)
	{
		return getAt(worldX, worldY, plane, ids).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(int worldX, int worldY, int plane, String... names)
	{
		return getAt(worldX, worldY, plane, names).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(int worldX, int worldY, int plane, Predicate<TileObject> filter)
	{
		return getAt(worldX, worldY, plane, filter).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(WorldPoint worldPoint, int... ids)
	{
		return getAt(worldPoint, ids).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(WorldPoint worldPoint, String... names)
	{
		return getAt(worldPoint, names).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(WorldPoint worldPoint, Predicate<TileObject> filter)
	{
		return getAt(worldPoint, filter).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(Tile tile, int... ids)
	{
		return getAt(tile, ids).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(Tile tile, String... names)
	{
		return getAt(tile, names).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstAt(Tile tile, Predicate<TileObject> filter)
	{
		return getAt(tile, filter).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(int worldX, int worldY, int plane, int radius, int... ids)
	{
		return getSurrounding(worldX, worldY, plane, radius, ids).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(int worldX, int worldY, int plane, int radius, String... names)
	{
		return getSurrounding(worldX, worldY, plane, radius, names).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(int worldX, int worldY, int plane, int radius, Predicate<TileObject> filter)
	{
		return getSurrounding(worldX, worldY, plane, radius, filter).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(WorldPoint worldPoint, int radius, int... ids)
	{
		return getSurrounding(worldPoint, radius, ids).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(WorldPoint worldPoint, int radius, String... names)
	{
		return getSurrounding(worldPoint, radius, names).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(WorldPoint worldPoint, int radius, Predicate<TileObject> filter)
	{
		return getSurrounding(worldPoint, radius, filter).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(Tile tile, int radius, int... ids)
	{
		return getSurrounding(tile, radius, ids).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(Tile tile, int radius, String... names)
	{
		return getSurrounding(tile, radius, names).stream().findFirst().orElse(null);
	}

	public static TileObject getFirstSurrounding(Tile tile, int radius, Predicate<TileObject> filter)
	{
		return getSurrounding(tile, radius, filter).stream().findFirst().orElse(null);
	}

	public static List<TileObject> getSurrounding(int worldX, int worldY, int plane, int radius, int... ids)
	{
		return TILE_OBJECTS.surrounding(worldX, worldY, plane, radius, ids);
	}

	public static List<TileObject> getSurrounding(int worldX, int worldY, int plane, int radius, String... names)
	{
		return TILE_OBJECTS.surrounding(worldX, worldY, plane, radius, names);
	}

	public static List<TileObject> getSurrounding(int worldX, int worldY, int plane, int radius, Predicate<TileObject> filter)
	{
		return TILE_OBJECTS.surrounding(worldX, worldY, plane, radius, filter);
	}

	public static List<TileObject> getSurrounding(WorldPoint worldPoint, int radius, int... ids)
	{
		return getSurrounding(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), radius, ids);
	}

	public static List<TileObject> getSurrounding(WorldPoint worldPoint, int radius, String... names)
	{
		return getSurrounding(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), radius, names);
	}

	public static List<TileObject> getSurrounding(WorldPoint worldPoint, int radius, Predicate<TileObject> filter)
	{
		return getSurrounding(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane(), radius, filter);
	}

	public static List<TileObject> getSurrounding(Tile tile, int radius, int... ids)
	{
		return getSurrounding(tile.getWorldX(), tile.getWorldY(), tile.getPlane(), radius, ids);
	}

	public static List<TileObject> getSurrounding(Tile tile, int radius, String... names)
	{
		return getSurrounding(tile.getWorldX(), tile.getWorldY(), tile.getPlane(), radius, names);
	}

	public static List<TileObject> getSurrounding(Tile tile, int radius, Predicate<TileObject> filter)
	{
		return getSurrounding(tile.getWorldX(), tile.getWorldY(), tile.getPlane(), radius, filter);
	}

	public static List<TileObject> within(WorldArea area, String... names)
	{
		return TILE_OBJECTS.in(area, names);
	}

	public static List<TileObject> within(WorldArea area, int... ids)
	{
		return TILE_OBJECTS.in(area, ids);
	}

	public static List<TileObject> within(WorldArea area, Predicate<TileObject> filter)
	{
		return TILE_OBJECTS.in(area, filter);
	}

	private static List<TileObject> getTileObjects(Tile tile)
	{
		List<TileObject> out = new ArrayList<>();
		if (tile == null)
		{
			return out;
		}

		DecorativeObject dec = tile.getDecorativeObject();
		if (dec != null && dec.getId() != -1)
		{
			out.add(dec);
		}

		WallObject wall = tile.getWallObject();
		if (wall != null && wall.getId() != -1)
		{
			out.add(wall);
		}

		GroundObject grnd = tile.getGroundObject();
		if (grnd != null && grnd.getId() != -1)
		{
			out.add(grnd);
		}

		GameObject[] gameObjects = tile.getGameObjects();
		if (gameObjects != null)
		{
			for (GameObject gameObject : gameObjects)
			{
				if (gameObject == null
						|| !Static.getClient().isTileObjectValid(tile, gameObject)
						|| gameObject.getId() == -1)
				{
					continue;
				}

				out.add(gameObject);
			}
		}

		return out;
	}

	@Override
	protected List<TileObject> all(Predicate<? super TileObject> filter)
	{
		List<TileObject> out = new ArrayList<>();
		for (Tile tile : Tiles.getAll())
		{
			out.addAll(getTileObjects(tile));
		}

		return out.stream()
				.filter(filter)
				.collect(Collectors.toList());
	}

	@Override
	protected List<TileObject> at(Tile tile, Predicate<? super TileObject> pred)
	{
		return getTileObjects(tile).stream()
				.filter(pred)
				.collect(Collectors.toList());
	}
}

package net.unethicalite.api.scene;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.api.worldmap.WorldMap;
import net.unethicalite.api.coords.RegionPoint;
import net.unethicalite.api.coords.ScenePoint;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;

public class Tiles
{
	public static List<Tile> getAll(Predicate<Tile> filter)
	{
		List<Tile> out = new ArrayList<>();

		for (int x = 0; x < Constants.SCENE_SIZE; x++)
		{
			for (int y = 0; y < Constants.SCENE_SIZE; y++)
			{
				Tile tile = Static.getClient().getScene().getTiles()[Static.getClient().getPlane()][x][y];
				if (tile != null && filter.test(tile))
				{
					out.add(tile);
				}
			}
		}

		return out;
	}

	public static List<Tile> getAll()
	{
		return getAll(x -> true);
	}

	public static Tile getAt(WorldPoint worldPoint)
	{
		return getAt(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	public static Tile getAt(LocalPoint localPoint)
	{
		return Static.getClient().getScene().getTiles()[Static.getClient().getPlane()][localPoint.getSceneX()][localPoint.getSceneY()];
	}

	public static Tile getAt(int worldX, int worldY, int plane)
	{
		Client client = Static.getClient();
		int correctedX = worldX < Constants.SCENE_SIZE ? worldX + client.getBaseX() : worldX;
		int correctedY = worldY < Constants.SCENE_SIZE ? worldY + client.getBaseY() : worldY;

		if (!WorldPoint.isInScene(client, correctedX, correctedY))
		{
			return null;
		}

		int x = correctedX - client.getBaseX();
		int y = correctedY - client.getBaseY();

		return client.getScene().getTiles()[plane][x][y];
	}

	public static Tile getAt(RegionPoint regionPoint)
	{
		return getAt(regionPoint.toWorld());
	}

	public static Tile getAt(ScenePoint scenePoint)
	{
		return Static.getClient().getScene().getTiles()[scenePoint.getPlane()][scenePoint.getX()][scenePoint.getY()];
	}

	public static List<Tile> getSurrounding(WorldPoint worldPoint, int radius)
	{
		List<Tile> out = new ArrayList<>();
		for (int x = -radius; x <= radius; x++)
		{
			for (int y = -radius; y <= radius; y++)
			{
				out.add(getAt(worldPoint.dx(x).dy(y)));
			}
		}

		return out;
	}

	public static Tile getHoveredTile()
	{
		return Static.getClient().getSelectedSceneTile();
	}

	public static Set<WorldPoint> getWorldMapTiles()
	{
		Widget worldMap = Widgets.get(WidgetInfo.WORLD_MAP_VIEW);
		if (worldMap == null)
		{
			return Collections.emptySet();
		}

		WorldMap wm = Static.getClient().getWorldMap();
		Set<WorldPoint> out = new HashSet<>();
		int topLeftX = wm.getWorldMapX() - (wm.getWorldMapDisplayWidth() / 2);
		int topLeftY = wm.getWorldMapY() - (wm.getWorldMapDisplayHeight() / 2);

		for (int x = topLeftX; x < topLeftX + wm.getWorldMapDisplayWidth(); x++)
		{
			for (int y = topLeftY; y < topLeftY + wm.getWorldMapDisplayHeight(); y++)
			{
				WorldPoint worldPoint = wm.getWorldPointFromMap(x, y);
				if (worldPoint == null)
				{
					continue;
				}

				out.add(worldPoint);
			}
		}

		return out;
	}

	public static List<WorldPoint> getWorldMapTiles(int plane)
	{
		Widget worldMap = Widgets.get(WidgetInfo.WORLD_MAP_VIEW);
		if (worldMap == null)
		{
			return Collections.emptyList();
		}

		List<WorldPoint> out = new ArrayList<>();
		WorldMap wm = Static.getClient().getWorldMap();

		Rectangle worldMapRect = worldMap.getBounds();

		float pixelsPerTile = wm.getWorldMapZoom();
		int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
		int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

		Point worldMapPosition = wm.getWorldMapPosition();
		int leftX = worldMapPosition.getX() - (widthInTiles / 2);
		int rightX = leftX + widthInTiles;
		int topY = worldMapPosition.getY() + (heightInTiles / 2);
		int bottomY = topY - heightInTiles;

		for (int x = leftX; x < rightX; x++)
		{
			for (int y = topY; y >= bottomY; y--)
			{
				out.add(new WorldPoint(x, y, plane));
			}
		}

		return out;
	}
}

package net.unethicalite.api.commons;

import net.unethicalite.api.game.Game;
import net.runelite.api.GameState;
import net.unethicalite.client.Static;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.function.BooleanSupplier;

public class Time
{
	private static final Logger logger = LoggerFactory.getLogger(Time.class);
	private static final int DEFAULT_POLLING_RATE = 10;

	public static boolean sleep(long ms)
	{
		if (Static.getClient().isClientThread())
		{
			logger.debug("Tried to sleep on client thread!");
			return false;
		}

		try
		{
			Thread.sleep(ms);
			return true;
		}
		catch (InterruptedException e)
		{
			logger.debug("Sleep interrupted");
		}

		return false;
	}

	public static boolean sleep(int min, int max)
	{
		return sleep(Rand.nextInt(min, max));
	}

	public static boolean sleepUntil(BooleanSupplier supplier, BooleanSupplier resetSupplier, int pollingRate, int timeOut)
	{
		if (Static.getClient().isClientThread())
		{
			logger.debug("Tried to sleepUntil on client thread!");
			return false;
		}

		long start = System.currentTimeMillis();
		while (!supplier.getAsBoolean())
		{
			if (System.currentTimeMillis() > start + timeOut)
			{
				return false;
			}

			if (resetSupplier.getAsBoolean())
			{
				start = System.currentTimeMillis();
			}

			if (!sleep(pollingRate))
			{
				return false;
			}
		}

		return true;
	}

	public static boolean sleepUntil(BooleanSupplier supplier, BooleanSupplier resetSupplier, int timeOut)
	{
		return sleepUntil(supplier, resetSupplier, DEFAULT_POLLING_RATE, timeOut);
	}

	public static boolean sleepUntil(BooleanSupplier supplier, int pollingRate, int timeOut)
	{
		return sleepUntil(supplier, () -> false, pollingRate, timeOut);
	}

	public static boolean sleepUntil(BooleanSupplier supplier, int timeOut)
	{
		return sleepUntil(supplier, DEFAULT_POLLING_RATE, timeOut);
	}

	public static boolean sleepTicks(int ticks)
	{
		if (Static.getClient().isClientThread())
		{
			logger.debug("Tried to sleep on client thread!");
			return false;
		}

		if (Game.getState() == GameState.LOGIN_SCREEN || Game.getState() == GameState.LOGIN_SCREEN_AUTHENTICATOR)
		{
			return false;
		}

		for (int i = 0; i < ticks; i++)
		{
			long start = Static.getClient().getTickCount();

			while (Static.getClient().getTickCount() == start)
			{
				try
				{
					Thread.sleep(DEFAULT_POLLING_RATE);
				}
				catch (InterruptedException e)
				{
					logger.debug("Sleep interrupted");
					return false;
				}
			}
		}

		return true;
	}

	public static boolean sleepTick()
	{
		return sleepTicks(1);
	}

	public static boolean sleepTicksUntil(BooleanSupplier supplier, int ticks)
	{
		if (Static.getClient().isClientThread())
		{
			logger.debug("Tried to sleep on client thread!");
			return false;
		}

		if (Game.getState() == GameState.LOGIN_SCREEN || Game.getState() == GameState.LOGIN_SCREEN_AUTHENTICATOR)
		{
			return false;
		}

		for (int i = 0; i < ticks; i++)
		{
			if (supplier.getAsBoolean())
			{
				return true;
			}

			if (!sleepTick())
			{
				return false;
			}
		}

		return false;
	}

	public static String format(Duration duration)
	{
		long secs = Math.abs(duration.getSeconds());
		return String.format("%02d:%02d:%02d", secs / 3600L, secs % 3600L / 60L, secs % 60L);
	}
}

package net.unethicalite.api.items;

import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.api.widgets.Widgets;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.client.Static;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class Trade
{
	private static final Supplier<Widget> OUR_ITEMS = () -> Widgets.get(WidgetID.PLAYER_TRADE_SCREEN_GROUP_ID, 25);
	private static final Supplier<Widget> THEIR_ITEMS = () -> Widgets.get(WidgetID.PLAYER_TRADE_SCREEN_GROUP_ID, 28);
	private static final Supplier<Widget> INVENTORY = () -> Widgets.get(WidgetID.PLAYER_TRADE_INVENTORY_GROUP_ID, 0);
	private static final Supplier<Widget> ACCEPT_1 = () -> Widgets.get(WidgetID.PLAYER_TRADE_SCREEN_GROUP_ID, 10);
	private static final Supplier<Widget> ACCEPT_2 = () -> Widgets.get(WidgetInfo.SECOND_TRADING_WITH_ACCEPT_BUTTON);
	private static final Supplier<Widget> DECLINE_1 = () -> Widgets.get(WidgetID.PLAYER_TRADE_SCREEN_GROUP_ID, 13);
	private static final Supplier<Widget> DECLINE_2 = () -> Widgets.get(WidgetID.PLAYER_TRADE_CONFIRM_GROUP_ID, WidgetID.TradeScreen.SECOND_DECLINE_FUNC);
	private static final Supplier<Widget> ACCEPT_STATUS_1 = () -> Widgets.get(WidgetID.PLAYER_TRADE_SCREEN_GROUP_ID, 30);
	private static final Supplier<Widget> ACCEPT_STATUS_2 = () -> Widgets.get(WidgetID.PLAYER_TRADE_CONFIRM_GROUP_ID, 4);

	public static boolean isOpen()
	{
		return isFirstScreenOpen() || isSecondScreenOpen();
	}

	public static boolean isSecondScreenOpen()
	{
		return Widgets.isVisible(ACCEPT_2.get());
	}

	public static boolean isFirstScreenOpen()
	{
		return Widgets.isVisible(ACCEPT_1.get());
	}

	public static void accept()
	{
		acceptFirstScreen();
		acceptSecondScreen();
	}

	public static void acceptFirstScreen()
	{
		Widget button = ACCEPT_1.get();
		if (Widgets.isVisible(button))
		{
			button.interact("Accept");
		}
	}

	public static void acceptSecondScreen()
	{
		Widget button = ACCEPT_2.get();
		if (Widgets.isVisible(button))
		{
			button.interact("Accept");
		}
	}

	public static void decline()
	{
		declineFirstScreen();
		declineSecondScreen();
	}

	public static void declineFirstScreen()
	{
		Widget button = DECLINE_1.get();
		if (Widgets.isVisible(button))
		{
			button.interact("Decline");
		}
	}

	public static void declineSecondScreen()
	{
		Widget button = DECLINE_2.get();
		if (Widgets.isVisible(button))
		{
			button.interact("Decline");
		}
	}

	public static boolean hasAccepted(boolean them)
	{
		return hasAcceptedFirstScreen(them) || hasAcceptedSecondScreen(them);
	}

	public static boolean hasAcceptedFirstScreen(boolean them)
	{
		Widget widget = ACCEPT_STATUS_1.get();
		return widget != null && widget.getText().equals(them ? "Other player has accepted." : "Waiting for other player...");
	}

	public static boolean hasAcceptedSecondScreen(boolean them)
	{
		Widget widget = ACCEPT_STATUS_2.get();
		return widget != null && widget.getText().equals(them ? "Other player has accepted." : "Waiting for other player...");
	}

	public static void offer(Predicate<Item> filter, int quantity)
	{
		Item item = Trade.getInventory(filter).stream().findFirst().orElse(null);
		if (item == null)
		{
			return;
		}

		switch (quantity)
		{
			case 1:
				item.interact("Offer");
				break;
			case 5:
				item.interact("Offer-5");
				break;
			case 10:
				item.interact("Offer-10");
				break;
			default:
				if (quantity > Inventory.getCount(true, item.getId()))
				{
					item.interact("Offer-All");
				}
				else
				{
					item.interact("Offer-X");
					Dialog.enterAmount(quantity);
				}
				break;
		}
	}

	public static void offer(int id, int quantity)
	{
		offer(x -> x.getId() == id, quantity);
	}

	public static void offer(String name, int quantity)
	{
		offer(x -> x.getName() != null && x.getName().equals(name), quantity);
	}

	/**
	 * Pass true as first parameter if you want to get the other side's items
	 */
	public static List<Item> getAll(boolean theirs, Predicate<Item> filter)
	{
		List<Item> items = new ArrayList<>();
		ItemContainer container = Static.getClient().getItemContainer(theirs ? InventoryID.TRADEOTHER : InventoryID.TRADE);
		if (container == null)
		{
			return items;
		}

		Item[] containerItems = container.getItems();
		for (int i = 0, containerItemsLength = containerItems.length; i < containerItemsLength; i++)
		{
			Item item = containerItems[i];
			if (item.getId() != -1 && item.getName() != null && !item.getName().equals("null"))
			{
				Widget containerWidget = theirs ? THEIR_ITEMS.get() : OUR_ITEMS.get();
				item.setWidgetId(item.calculateWidgetId(containerWidget));
				item.setSlot(i);

				if (filter.test(item))
				{
					items.add(item);
				}
			}
		}

		return items;
	}

	public static List<Item> getInventory(Predicate<Item> filter)
	{
		List<Item> items = new ArrayList<>();
		ItemContainer container = Static.getClient().getItemContainer(InventoryID.INVENTORY);
		if (container == null)
		{
			return items;
		}

		Item[] containerItems = container.getItems();
		for (int i = 0, containerItemsLength = containerItems.length; i < containerItemsLength; i++)
		{
			Item item = containerItems[i];
			if (item.getId() != -1 && item.getName() != null && !item.getName().equals("null"))
			{
				item.setWidgetId(item.calculateWidgetId(INVENTORY.get()));
				item.setSlot(i);

				if (filter.test(item))
				{
					items.add(item);
				}
			}
		}

		return items;
	}

	public static List<Item> getAll(boolean theirs)
	{
		return getAll(theirs, x -> true);
	}

	public static List<Item> getAll(boolean theirs, int... ids)
	{
		return getAll(theirs, Predicates.ids(ids));
	}

	public static List<Item> getAll(boolean theirs, String... names)
	{
		return getAll(theirs, Predicates.names(names));
	}

	public static Item getFirst(boolean theirs, Predicate<Item> filter)
	{
		return getAll(theirs, filter).stream().findFirst().orElse(null);
	}

	public static Item getFirst(boolean theirs, int... ids)
	{
		return getFirst(theirs, Predicates.ids(ids));
	}

	public static Item getFirst(boolean theirs, String... names)
	{
		return getFirst(theirs, Predicates.names(names));
	}

	public static boolean contains(boolean theirs, Predicate<Item> filter)
	{
		return getFirst(theirs, filter) != null;
	}

	public static boolean contains(boolean theirs, int... ids)
	{
		return contains(theirs, Predicates.ids(ids));
	}

	public static boolean contains(boolean theirs, String... names)
	{
		return contains(theirs, Predicates.names(names));
	}

	public static String getTradingPlayer()
	{
		return Vars.getVarcStr(VarClientStr.DUEL_OPPONENT_NAME);
	}
}

package net.unethicalite.api.movement.pathfinder.model;

import lombok.AllArgsConstructor;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.api.movement.pathfinder.model.requirement.Requirements;

@Value
@AllArgsConstructor
public class Transport
{
    WorldPoint source;
    WorldPoint destination;
    int sourceRadius;
    int destinationRadius;
    Runnable handler;
    Requirements requirements;

    public Transport(WorldPoint source,
              WorldPoint destination,
              int sourceRadius,
              int destinationRadius,
              Runnable handler
    )
    {
        this.source = source;
        this.destination = destination;
        this.sourceRadius = sourceRadius;
        this.destinationRadius = destinationRadius;
        this.handler = handler;
        this.requirements = new Requirements();
    }
}

package net.unethicalite.api.movement.pathfinder.model.dto;

import lombok.Value;
import net.runelite.api.coords.WorldPoint;
import net.unethicalite.api.movement.pathfinder.TransportLoader;
import net.unethicalite.api.movement.pathfinder.model.Transport;
import net.unethicalite.api.movement.pathfinder.model.requirement.Requirements;

@Value
public class TransportDto
{
    WorldPoint source;
    WorldPoint destination;
    String action;
    Integer objectId;
    Requirements requirements;

    public Transport toTransport()
    {
        return TransportLoader.objectTransport(source, destination, objectId, action, requirements);
    }
}

package net.unethicalite.api.movement.pathfinder;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.ItemID;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Point;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.TileObject;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.unethicalite.api.entities.NPCs;
import net.unethicalite.api.entities.TileObjects;
import net.unethicalite.api.game.GameThread;
import net.unethicalite.api.game.Skills;
import net.unethicalite.api.game.Vars;
import net.unethicalite.api.game.Worlds;
import net.unethicalite.api.items.Equipment;
import net.unethicalite.api.items.Inventory;
import net.unethicalite.api.movement.Movement;
import net.unethicalite.api.movement.pathfinder.model.FairyRingLocation;
import net.unethicalite.api.movement.pathfinder.model.Transport;
import net.unethicalite.api.movement.pathfinder.model.dto.TransportDto;
import net.unethicalite.api.movement.pathfinder.model.requirement.Requirements;
import net.unethicalite.api.quests.QuestVarbits;
import net.unethicalite.api.quests.Quests;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.api.widgets.Widgets;
import org.apache.commons.lang3.tuple.Pair;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import static net.unethicalite.api.movement.pathfinder.model.MovementConstants.*;

@Slf4j
public class TransportLoader
{
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final List<Transport> ALL_STATIC_TRANSPORTS = new ArrayList<>();
    private static final List<Transport> LAST_TRANSPORT_LIST = new ArrayList<>();

    public static void init()
    {
        log.info("Loading transports");
        try (InputStream stream = Walker.class.getResourceAsStream("/transports.json"))
        {
            if (stream == null)
            {
                log.error("Failed to load transports.");
                return;
            }

            TransportDto[] json = GSON.fromJson(new String(stream.readAllBytes()), TransportDto[].class);

            List<Transport> list = Arrays.stream(json)
                    .map(TransportDto::toTransport)
                    .collect(Collectors.toList());
            ALL_STATIC_TRANSPORTS.addAll(list);
        }
        catch (IOException e)
        {
            log.error("Failed to load transports.", e);
        }

        log.info("Loaded {} transports", ALL_STATIC_TRANSPORTS.size());
    }

    public static List<Transport> buildTransports()
    {
        return LAST_TRANSPORT_LIST;
    }

    public static void refreshTransports()
    {
        GameThread.invoke(() ->
        {
            List<Transport> filteredStatic = ALL_STATIC_TRANSPORTS.stream()
                    .filter(it -> it.getRequirements().fulfilled())
                    .collect(Collectors.toList());

            List<Transport> transports = new ArrayList<>();

            int gold = Inventory.getFirst(995) != null ? Inventory.getFirst(995).getQuantity() : 0;

            if (gold >= 30)
            {
                if (Quests.isFinished(Quest.PIRATES_TREASURE))
                {
                    transports.add(npcTransport(new WorldPoint(3027, 3218, 0), new WorldPoint(2956, 3143, 1), 3644, "Pay-fare"));
                    transports.add(npcTransport(new WorldPoint(2954, 3147, 0), new WorldPoint(3032, 3217, 1), 3648, "Pay-Fare"));
                }
                else
                {
                    transports.add(npcDialogTransport(new WorldPoint(3027, 3218, 0), new WorldPoint(2956, 3143, 1), 3644, "Yes please."));
                    transports.add(npcDialogTransport(new WorldPoint(2954, 3147, 0), new WorldPoint(3032, 3217, 1), 3648, "Can I journey on this ship?", "Search away, I have nothing to hide.", "Ok"));
                }
            }

            if (Worlds.inMembersWorld())
            {
                //Shamans
                transports.add(objectTransport(new WorldPoint(1312, 3685, 0), new WorldPoint(1312, 10086, 0), 34405, "Enter"));

                //Doors for shamans
                transports.add(objectTransport(new WorldPoint(1293, 10090, 0), new WorldPoint(1293, 10093, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1293, 10093, 0), new WorldPoint(1293, 10091, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1296, 10096, 0), new WorldPoint(1298, 10096, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1298, 10096, 0), new WorldPoint(1296, 10096, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1307, 10096, 0), new WorldPoint(1309, 10096, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1309, 10096, 0), new WorldPoint(1307, 10096, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1316, 10096, 0), new WorldPoint(1318, 10096, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1318, 10096, 0), new WorldPoint(1316, 10096, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1324, 10096, 0), new WorldPoint(1326, 10096, 0), 34642, "Pass"));
                transports.add(objectTransport(new WorldPoint(1326, 10096, 0), new WorldPoint(1324, 10096, 0), 34642, "Pass"));

                // Crabclaw island
                if (gold >= 10_000)
                {
                    transports.add(npcTransport(new WorldPoint(1782, 3458, 0), new WorldPoint(1778, 3417, 0), 7483, "Travel"));
                }

                transports.add(npcTransport(new WorldPoint(1779, 3418, 0), new WorldPoint(1784, 3458, 0), 7484, "Travel"));

                // Port sarim
                if (Vars.getBit(Varbits.VEOS_HAS_TALKED_TO_BEFORE) == 0) // First time talking to Veos
                {
                    if (Vars.getBit(QuestVarbits.QUEST_X_MARKS_THE_SPOT.getId()) >= 7)
                    {
                        transports.add(npcDialogTransport(new WorldPoint(3054, 3245, 0),
                                new WorldPoint(1824, 3691, 0),
                                8484,
                                "Can you take me to Great Kourend?"));
                    }
                    else
                    {
                        transports.add(npcDialogTransport(new WorldPoint(3054, 3245, 0),
                                new WorldPoint(1824, 3691, 0),
                                8484,
                                "That's great, can you take me there please?"));
                    }
                }
                else // Has talked to Veos before
                {
                    transports.add(npcTransport(new WorldPoint(3054, 3245, 0),
                            new WorldPoint(1824, 3695, 1),
                            "Veos",
                            "Port Piscarilius"));
                }

                if (Quests.getState(Quest.LUNAR_DIPLOMACY) != QuestState.NOT_STARTED)
                {
                    transports.add(npcTransport(new WorldPoint(2222, 3796, 2), new WorldPoint(2130, 3899, 2), NpcID.CAPTAIN_BENTLEY_6650, "Travel"));
                    transports.add(npcTransport(new WorldPoint(2130, 3899, 2), new WorldPoint(2222, 3796, 2), NpcID.CAPTAIN_BENTLEY_6650, "Travel"));
                }

                // Spirit Trees
                if (Quests.isFinished(Quest.TREE_GNOME_VILLAGE))
                {
                    for (var source : SPIRIT_TREES)
                    {
                        if (source.location.equals("Gnome Stronghold") && !Quests.isFinished(Quest.THE_GRAND_TREE))
                        {
                            continue;
                        }
                        for (var target : SPIRIT_TREES)
                        {
                            if (source == target)
                            {
                                continue;
                            }

                            transports.add(spritTreeTransport(source.position, target.position, target.location));
                        }
                    }
                }

                if (Quests.isFinished(Quest.THE_LOST_TRIBE))
                {
                    transports.add(npcTransport(new WorldPoint(3229, 9610, 0), new WorldPoint(3316, 9613, 0), NpcID.KAZGAR_7301, "Mines"));
                    transports.add(npcTransport(new WorldPoint(3316, 9613, 0), new WorldPoint(3229, 9610, 0), NpcID.MISTAG_7299, "Cellar"));
                }

                // Tree Gnome Village
                if (Quests.getState(Quest.TREE_GNOME_VILLAGE) != QuestState.NOT_STARTED)
                {
                    transports.add(npcTransport(new WorldPoint(2504, 3192, 0), new WorldPoint(2515, 3159, 0), 4968, "Follow"));
                    transports.add(npcTransport(new WorldPoint(2515, 3159, 0), new WorldPoint(2504, 3192, 0), 4968, "Follow"));
                }

                // Eagles peak cave
                if (Vars.getVarp(934) >= 15)
                {
                    // Entrance
                    transports.add(objectTransport(new WorldPoint(2328, 3496, 0), new WorldPoint(1994, 4983, 3), 19790,
                            "Enter"));
                    transports.add(objectTransport(new WorldPoint(1994, 4983, 3), new WorldPoint(2328, 3496, 0), 19891,
                            "Exit"));
                }

                // Waterbirth island
                if (Quests.isFinished(Quest.THE_FREMENNIK_TRIALS) || gold >= 1000)
                {
                    transports.add(npcTransport(new WorldPoint(2544, 3760, 0), new WorldPoint(2620, 3682, 0), 10407, "Rellekka"));
                    transports.add(npcTransport(new WorldPoint(2620, 3682, 0), new WorldPoint(2547, 3759, 0), 5937, "Waterbirth Island"));
                }

                // Pirates cove
                transports.add(npcTransport(new WorldPoint(2620, 3692, 0), new WorldPoint(2213, 3794, 0), NpcID.LOKAR_SEARUNNER, "Pirate's Cove"));
                transports.add(npcTransport(new WorldPoint(2213, 3794, 0), new WorldPoint(2620, 3692, 0), NpcID.LOKAR_SEARUNNER_9306, "Rellekka"));

                // Corsair's Cove
                if (Skills.getBoostedLevel(Skill.AGILITY) >= 10)
                {
                    transports.add(objectTransport(new WorldPoint(2546, 2871, 0), new WorldPoint(2546, 2873, 0), 31757,
                            "Climb"));
                    transports.add(objectTransport(new WorldPoint(2546, 2873, 0), new WorldPoint(2546, 2871, 0), 31757,
                            "Climb"));
                }

                // Lumbridge castle dining room, ignore if RFD is in progress.
                if (Quests.getState(Quest.RECIPE_FOR_DISASTER) != QuestState.IN_PROGRESS)
                {

                    transports.add(objectTransport(new WorldPoint(3213, 3221, 0), new WorldPoint(3212, 3221, 0), 12349, "Open"));
                    transports.add(objectTransport(new WorldPoint(3212, 3221, 0), new WorldPoint(3213, 3221, 0), 12349, "Open"));
                    transports.add(objectTransport(new WorldPoint(3213, 3222, 0), new WorldPoint(3212, 3222, 0), 12350, "Open"));
                    transports.add(objectTransport(new WorldPoint(3212, 3222, 0), new WorldPoint(3213, 3222, 0), 12350, "Open"));
                    transports.add(objectTransport(new WorldPoint(3207, 3218, 0), new WorldPoint(3207, 3217, 0), 12348, "Open"));
                    transports.add(objectTransport(new WorldPoint(3207, 3217, 0), new WorldPoint(3207, 3218, 0), 12348, "Open"));
                }

                // Digsite gate
                if (Vars.getBit(Varbits.KUDOS) >= 153)
                {
                    transports.add(objectTransport(new WorldPoint(3295, 3429, 0), new WorldPoint(3296, 3429, 0), 24561,
                            "Open"));
                    transports.add(objectTransport(new WorldPoint(3296, 3429, 0), new WorldPoint(3295, 3429, 0), 24561,
                            "Open"));
                    transports.add(objectTransport(new WorldPoint(3295, 3428, 0), new WorldPoint(3296, 3428, 0), 24561,
                            "Open"));
                    transports.add(objectTransport(new WorldPoint(3296, 3428, 0), new WorldPoint(3295, 3428, 0), 24561,
                            "Open"));
                }

                // Fairy Rings
                if (Equipment.contains(ItemID.DRAMEN_STAFF, ItemID.LUNAR_STAFF)
                        && Quests.getState(Quest.FAIRYTALE_II__CURE_A_QUEEN) != QuestState.NOT_STARTED)
                {
                    for (FairyRingLocation sourceRing : FairyRingLocation.values())
                    {
                        for (FairyRingLocation destRing : FairyRingLocation.values())
                        {
                            if (sourceRing != destRing)
                            {
                                transports.add(fairyRingTransport(sourceRing, destRing));
                            }
                        }
                    }
                }
            }

            // Entrana
            transports.add(npcTransport(new WorldPoint(3041, 3237, 0), new WorldPoint(2834, 3331, 1), 1166, "Take-boat"));
            transports.add(npcTransport(new WorldPoint(2834, 3335, 0), new WorldPoint(3048, 3231, 1), 1170, "Take-boat"));
            transports.add(npcDialogTransport(new WorldPoint(2821, 3374, 0),
                    new WorldPoint(2822, 9774, 0),
                    1164,
                    "Well that is a risk I will have to take."));

            // Fossil Island
            transports.add(npcTransport(new WorldPoint(3362, 3445, 0),
                    new WorldPoint(3724, 3808, 0),
                    8012,
                    "Quick-Travel"));

            transports.add(objectDialogTransport(new WorldPoint(3724, 3808, 0),
                    new WorldPoint(3362, 3445, 0),
                    30914,
                    new String[] {"Travel"},
                    "Row to the barge and travel to the Digsite."));

            // Magic Mushtrees
            for (var source : MUSHTREES)
            {
                for (var target : MUSHTREES)
                {
                    if (source.position != target.position)
                    {
                        transports.add(mushtreeTransport(source.position, target.position, target.widget));
                    }
                }
            }

            // Gnome stronghold
            transports.add(objectDialogTransport(new WorldPoint(2460, 3382, 0), new WorldPoint(2461, 3385, 0), 190, new String[] {"Open"}, "Sorry, I'm a bit busy."));
            transports.add(objectDialogTransport(new WorldPoint(2461, 3382, 0), new WorldPoint(2461, 3385, 0), 190, new String[] {"Open"}, "Sorry, I'm a bit busy."));
            transports.add(objectDialogTransport(new WorldPoint(2462, 3382, 0), new WorldPoint(2461, 3385, 0), 190, new String[] {"Open"}, "Sorry, I'm a bit busy."));

            // Paterdomus
            transports.add(trapDoorTransport(new WorldPoint(3405, 3506, 0), new WorldPoint(3405, 9906, 0), 1579, 1581));
            transports.add(trapDoorTransport(new WorldPoint(3423, 3485, 0), new WorldPoint(3440, 9887, 0), 3432, 3433));
            transports.add(trapDoorTransport(new WorldPoint(3422, 3484, 0), new WorldPoint(3440, 9887, 0), 3432, 3433));

            // Port Piscarilius
            transports.add(npcTransport(new WorldPoint(1824, 3691, 0), new WorldPoint(3055, 3242, 1), 10727, "Port Sarim"));

            // Glarial's tomb
            transports.add(itemUseTransport(new WorldPoint(2557, 3444, 0), new WorldPoint(2555, 9844, 0), 294, 1992));
            transports.add(itemUseTransport(new WorldPoint(2557, 3445, 0), new WorldPoint(2555, 9844, 0), 294, 1992));
            transports.add(itemUseTransport(new WorldPoint(2558, 3443, 0), new WorldPoint(2555, 9844, 0), 294, 1992));
            transports.add(itemUseTransport(new WorldPoint(2559, 3443, 0), new WorldPoint(2555, 9844, 0), 294, 1992));
            transports.add(itemUseTransport(new WorldPoint(2560, 3444, 0), new WorldPoint(2555, 9844, 0), 294, 1992));
            transports.add(itemUseTransport(new WorldPoint(2560, 3445, 0), new WorldPoint(2555, 9844, 0), 294, 1992));
            transports.add(itemUseTransport(new WorldPoint(2558, 3446, 0), new WorldPoint(2555, 9844, 0), 294, 1992));
            transports.add(itemUseTransport(new WorldPoint(2559, 3446, 0), new WorldPoint(2555, 9844, 0), 294, 1992));

            // Waterfall Island
            transports.add(itemUseTransport(new WorldPoint(2512, 3476, 0), new WorldPoint(2513, 3468, 0), 954, 1996));
            transports.add(itemUseTransport(new WorldPoint(2512, 3466, 0), new WorldPoint(2511, 3463, 0), 954, 2020));

            // Edgeville Dungeon
            transports.add(trapDoorTransport(new WorldPoint(3096, 3468, 0), new WorldPoint(3096, 9867, 0), 1579, 1581));

            // Varrock Castle manhole
            transports.add(trapDoorTransport(new WorldPoint(3237, 3459, 0), new WorldPoint(3237, 9859, 0), 881, 882));

            // Draynor manor basement
            for (var entry : DRAYNOR_MANOR_BASEMENT_DOORS.entrySet())
            {
                if (Vars.getBit(entry.getKey()) == 1)
                {
                    var points = entry.getValue();
                    transports.add(lockingDoorTransport(points.getLeft(), points.getRight(), 11450));
                    transports.add(lockingDoorTransport(points.getRight(), points.getLeft(), 11450));
                }
            }

            // Corsair Cove, Captain Tock's ship's gangplank
            transports.add(objectTransport(new WorldPoint(2578, 2837, 1), new WorldPoint(2578, 2840, 0), 31756, "Cross"));
            transports.add(objectTransport(new WorldPoint(2578, 2840, 0), new WorldPoint(2578, 2837, 1), 31756, "Cross"));

            // Corsair Cove, Ithoi the Navigator's hut stairs
            transports.add(objectTransport(new WorldPoint(2532, 2833, 0), new WorldPoint(2529, 2835, 1), 31735, "Climb"));
            transports.add(objectTransport(new WorldPoint(2529, 2835, 1), new WorldPoint(2532, 2833, 0), 31735, "Climb"));

            // Corsair Cove, Dungeon hole to Ogress Warriors/Vine ladder
            transports.add(objectTransport(new WorldPoint(2523, 2860, 0), new WorldPoint(2012, 9004, 1), 31791, "Enter"));
            transports.add(objectTransport(new WorldPoint(2012, 9004, 1), new WorldPoint(2523, 2860, 0), 31790, "Climb"));

            if (Inventory.contains(SLASH_ITEMS) || Equipment.contains(SLASH_ITEMS))
            {
                for (Pair<WorldPoint, WorldPoint> pair : SLASH_WEB_POINTS)
                {
                    transports.add(slashWebTransport(pair.getLeft(), pair.getRight()));
                    transports.add(slashWebTransport(pair.getRight(), pair.getLeft()));
                }
            }

            LAST_TRANSPORT_LIST.clear();
            LAST_TRANSPORT_LIST.addAll(filteredStatic);
            LAST_TRANSPORT_LIST.addAll(transports);
        });
    }

    public static Transport lockingDoorTransport(
            WorldPoint source,
            WorldPoint destination,
            int openDoorId
    )
    {
        return new Transport(source, destination, 0, 0, () ->
        {
            TileObject openDoor = TileObjects.getFirstSurrounding(source, 1, openDoorId);

            if (openDoor != null)
            {
                openDoor.interact("Open");
            }
        });
    }

    public static Transport trapDoorTransport(
            WorldPoint source,
            WorldPoint destination,
            int closedId,
            int openedId
    )
    {
        return new Transport(source, destination, Integer.MAX_VALUE, 0, () ->
        {
            TileObject openedTrapdoor = TileObjects.getFirstSurrounding(source, 5, openedId);
            if (openedTrapdoor != null)
            {
                openedTrapdoor.interact(0);
                return;
            }

            TileObject closedTrapDoor = TileObjects.getFirstSurrounding(source, 5, closedId);
            if (closedTrapDoor != null)
            {
                closedTrapDoor.interact(0);
            }
        });
    }

    public static Transport fairyRingTransport(
            FairyRingLocation source,
            FairyRingLocation destination
    )
    {
        return new Transport(source.getLocation(), destination.getLocation(), Integer.MAX_VALUE, 0, () ->
        {
            log.debug("Looking for fairy ring at {} to {}", source.getLocation(), destination.getLocation());
            TileObject ring = TileObjects.getFirstSurrounding(source.getLocation(), 5, "Fairy ring");

            if (ring == null)
            {
                log.debug("Fairy ring at {} is null", source.getLocation());
                return;
            }

            if (destination == FairyRingLocation.ZANARIS)
            {
                ring.interact("Zanaris");
                return;
            }

            if (ring.hasAction(a -> a != null && a.contains(destination.getCode())))
            {
                ring.interact(a -> a != null && a.contains(destination.getCode()));
                return;
            }

            if (Widgets.isVisible(Widgets.get(WidgetInfo.FAIRY_RING)))
            {
                destination.travel();
                return;
            }

            ring.interact("Configure");
        });
    }

    public static Transport itemUseTransport(
            WorldPoint source,
            WorldPoint destination,
            int itemId,
            int objId
    )
    {
        return new Transport(source, destination, Integer.MAX_VALUE, 0, () ->
        {
            Item item = Inventory.getFirst(itemId);
            if (item == null)
            {
                return;
            }

            TileObject transport = TileObjects.getFirstSurrounding(source, 5, objId);
            if (transport != null)
            {
                item.useOn(transport);
            }
        });
    }

    public static Transport npcTransport(
            WorldPoint source,
            WorldPoint destination,
            int npcId,
            String... actions
    )
    {
        return new Transport(source, destination, 10, 0, () ->
        {
            NPC npc = NPCs.getNearest(x -> x.getWorldLocation().distanceTo(source) <= 10 && x.getId() == npcId);
            if (npc != null)
            {
                npc.interact(actions);
            }
        });
    }

    public static Transport npcTransport(
            WorldPoint source,
            WorldPoint destination,
            String npcName,
            String... actions
    )
    {
        return new Transport(source, destination, 10, 0, () ->
        {
            NPC npc = NPCs.getNearest(x -> x.getWorldLocation().distanceTo(source) <= 10 && x.getName().equalsIgnoreCase(npcName));
            if (npc != null)
            {
                npc.interact(actions);
            }
        });
    }

    public static Transport npcDialogTransport(
            WorldPoint source,
            WorldPoint destination,
            int npcId,
            String... chatOptions
    )
    {
        return new Transport(source, destination, 10, 0, () ->
        {
            if (Dialog.canContinue())
            {
                Dialog.continueSpace();
                return;
            }
            if (Dialog.isViewingOptions())
            {
                if (Dialog.chooseOption(chatOptions))
                {
                    return;
                }

                return;
            }

            NPC npc = NPCs.getNearest(x -> x.getWorldLocation().distanceTo(source) <= 10 && x.getId() == npcId);
            if (npc != null)
            {
                npc.interact(0);
            }
        });
    }

    public static Transport objectTransport(
            WorldPoint source,
            WorldPoint destination,
            int objId,
            String actions
    )
    {
        return new Transport(source, destination, Integer.MAX_VALUE, 0, () ->
        {
            TileObject first = TileObjects.getFirstAt(source, objId);
            if (first != null)
            {
                first.interact(actions);
                return;
            }

            TileObjects.getSurrounding(source, 5, x -> x.getId() == objId).stream()
                    .min(Comparator.comparingInt(o -> o.distanceTo(source)))
                    .ifPresent(obj -> obj.interact(actions));
        });
    }

    public static Transport objectTransport(
            WorldPoint source,
            WorldPoint destination,
            int objId,
            String actions,
            Requirements requirements
    )
    {
        return new Transport(source, destination, Integer.MAX_VALUE, 0, () ->
        {
            TileObject first = TileObjects.getFirstAt(source, objId);
            if (first != null)
            {
                log.debug("Transport found {}", first.getWorldLocation());
                first.interact(actions);
                return;
            }

            log.debug("Transport not found {}, {}", source, objId);
            TileObjects.getSurrounding(source, 5, x -> x.getId() == objId).stream()
                    .min(Comparator.comparingInt(o -> o.distanceTo(source)))
                    .ifPresent(obj -> obj.interact(actions));
        }, requirements);
    }

    public static Transport objectTransport(
            WorldPoint source,
            WorldPoint destination,
            TileObject tileObject,
            int actionIndex
    )
    {
        return new Transport(source, destination, Integer.MAX_VALUE, 0, () ->
        {
            if (tileObject == null)
            {
                return;
            }

            tileObject.interact(actionIndex);
        });
    }

    public static Transport objectDialogTransport(
            WorldPoint source,
            WorldPoint destination,
            int objId,
            String[] actions,
            String... chatOptions
    )
    {
        return new Transport(source, destination, Integer.MAX_VALUE, 0, () ->
        {
            if (Dialog.isOpen())
            {
                if (Dialog.canContinue())
                {
                    Dialog.continueSpace();
                    return;
                }

                if (Dialog.chooseOption(chatOptions))
                {
                    return;
                }

                return;
            }

            TileObject transport = TileObjects.getFirstSurrounding(source, 5, objId);
            if (transport != null)
            {
                transport.interact(actions);
            }
        });
    }

    public static Transport slashWebTransport(
            WorldPoint source,
            WorldPoint destination
    )
    {
        return new Transport(source, destination, Integer.MAX_VALUE, 0, () ->
        {
            TileObject transport = TileObjects.getFirstSurrounding(source, 5, it -> it.getName() != null && it.getName().contains("Web") && it.hasAction("Slash"));
            if (transport != null)
            {
                transport.interact("Slash");
            }
            else
            {
                Movement.walk(destination);
            }
        });
    }

    private static Transport spritTreeTransport(WorldPoint source, WorldPoint target, String location)
    {
        return new Transport(
                source,
                target,
                5,
                0,
                () ->
                {
                    Widget treeWidget = Widgets.get(187, 3);
                    if (Widgets.isVisible(treeWidget))
                    {
                        Arrays.stream(treeWidget.getDynamicChildren())
                                .filter(child -> child.getText().toLowerCase().contains(location.toLowerCase()))
                                .findFirst()
                                .ifPresent(child -> child.interact(0, MenuAction.WIDGET_CONTINUE.getId(), child.getIndex(), child.getId()));
                        return;
                    }

                    TileObject tree = TileObjects.getFirstSurrounding(source, 5, 1293, 1294, 1295);
                    if (tree != null)
                    {
                        final Point point = tree.menuPoint();
                        tree.interact(tree.getId(), MenuAction.GAME_OBJECT_FIRST_OPTION.getId(), point.getX(), point.getY());
                    }
                });
    }

    private static Transport mushtreeTransport(WorldPoint source, WorldPoint target, WidgetInfo widget)
    {
        return new Transport(
                source,
                target,
                5,
                0,
                () ->
                {
                    Widget treeWidget = Widgets.get(widget);
                    if (Widgets.isVisible(treeWidget))
                    {
                        treeWidget.interact(0, MenuAction.WIDGET_CONTINUE.getId(), treeWidget.getIndex(), treeWidget.getId());
                        return;
                    }

                    TileObject tree = TileObjects.getFirstSurrounding(source, 5, "Magic Mushtree");
                    if (tree != null)
                    {
                        tree.interact("Use");
                    }
                });
    }

    public static class MagicMushtree
    {
        private final WorldPoint position;
        private final WidgetInfo widget;

        public MagicMushtree(WorldPoint position, WidgetInfo widget)
        {
            this.position = position;
            this.widget = widget;
        }
    }

    public static class SpiritTree
    {
        private final WorldPoint position;
        private final String location;

        public SpiritTree(WorldPoint position, String location)
        {
            this.position = position;
            this.location = location;
        }
    }
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import lombok.Value;

@Value
public class VarRequirement implements Requirement
{
    Comparison comparison;
    VarType type;
    int var;
    int value;

    @Override
    public Boolean get()
    {
        return comparison.apply(type.apply(var), value);
    }
}

package net.unethicalite.api.game;

import net.unethicalite.client.Static;

public class Vars
{
	public static int getBit(int id)
	{
		return GameThread.invokeLater(() -> Static.getClient().getVarbitValue(Static.getClient().getVarps(), id));
	}

	public static int getVarp(int id)
	{
		return Static.getClient().getVarpValue(Static.getClient().getVarps(), id);
	}

	public static int getVarcInt(int varClientInt)
	{
		return Static.getClient().getVarcIntValue(varClientInt);
	}

	public static String getVarcStr(int varClientStr)
	{
		return Static.getClient().getVarcStrValue(varClientStr);
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import net.unethicalite.api.game.Vars;

import java.util.function.Function;

public enum VarType implements Function<Integer, Integer>
{
    VARBIT,
    VARP;

    @Override
    public Integer apply(Integer index)
    {
        switch (this)
        {
            case VARBIT:
                return Vars.getBit(index);
            case VARP:
                return Vars.getVarp(index);
        }
        return 0;
    }
}

package net.unethicalite.api.movement.pathfinder;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Player;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.commons.Rand;
import net.unethicalite.api.commons.Time;
import net.unethicalite.api.entities.NPCs;
import net.unethicalite.api.entities.Players;
import net.unethicalite.api.entities.TileObjects;
import net.unethicalite.api.game.Game;
import net.unethicalite.api.items.Equipment;
import net.unethicalite.api.items.Inventory;
import net.unethicalite.api.movement.Movement;
import net.unethicalite.api.movement.Reachable;
import net.unethicalite.api.movement.pathfinder.model.Teleport;
import net.unethicalite.api.movement.pathfinder.model.Transport;
import net.unethicalite.api.scene.Tiles;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;
import net.unethicalite.client.managers.RegionManager;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

@Singleton
@Slf4j
public class Walker
{
    public static final int MAX_INTERACT_DISTANCE = 20;
    private static final int MIN_TILES_WALKED_IN_STEP = 7;
    private static final int MAX_TILES_WALKED_IN_STEP = 14;
    private static final int MAX_MIN_ENERGY = 50;
    private static final int MIN_ENERGY = 5;
    private static final int MAX_NEAREST_SEARCH_ITERATIONS = 10;

    private static final ExecutorService executor = Executors.newSingleThreadExecutor();
    private static Future<List<WorldPoint>> pathFuture = null;
    private static WorldArea currentDestination = null;

    public static boolean walkTo(WorldPoint destination)
    {
        return walkTo(destination.toWorldArea());
    }

    public static boolean walkTo(WorldArea destination)
    {
        Player local = Players.getLocal();
        if (destination.contains(local))
        {
            currentDestination = null;
            return true;
        }

        if (Game.isInCutscene() || Widgets.isVisible(Widgets.get(299, 0)))
        {
            Time.sleepTicks(2);
            return false;
        }

        Map<WorldPoint, List<Transport>> transports = buildTransportLinks();
        LinkedHashMap<WorldPoint, Teleport> teleports = buildTeleportLinks(destination);
        List<WorldPoint> path = buildPath(destination);

        Static.getEntityRenderer().setCurrentPath(path);

        if (path == null || path.isEmpty())
        {
            log.error(path == null ? "Path is null" : "Path is empty");
            return false;
        }

        WorldPoint startPosition = path.get(0);
        Teleport teleport = teleports.get(startPosition);
        WorldPoint localWP = local.getWorldLocation();
        boolean offPath = path.stream().noneMatch(t -> t.distanceTo(localWP) <= 5 && canPathTo(localWP, t));

        // Teleport or refresh path if our direction changed
        if (offPath)
        {
            if (teleport != null)
            {
                log.debug("Casting teleport {}", teleport);
                if (Players.getLocal().isIdle())
                {
                    teleport.getHandler().run();
                    Time.sleepTick();
                }
                Time.sleepUntil(() -> Players.getLocal().distanceTo(teleport.getDestination()) < 10, 500);
                return false;
            }

            path = buildPath(destination, true);
            log.debug("Refreshed path {}", path.size() - 1);
        }

        return walkAlong(path, transports);
    }

    public static boolean walkAlong(List<WorldPoint> path, Map<WorldPoint, List<Transport>> transports)
    {
        List<WorldPoint> remainingPath = remainingPath(path);

        if (handleTransports(remainingPath, transports))
        {
            return false;
        }

        return stepAlong(remainingPath);
    }

    public static boolean stepAlong(List<WorldPoint> path)
    {
        List<WorldPoint> reachablePath = reachablePath(path);
        if (reachablePath.isEmpty())
        {
            return false;
        }
        int nextTileIdx = reachablePath.size() - 1;
        if (nextTileIdx <= MIN_TILES_WALKED_IN_STEP)
        {
            return step(reachablePath.get(nextTileIdx));
        }

        if (nextTileIdx > MAX_TILES_WALKED_IN_STEP)
        {
            nextTileIdx = MAX_TILES_WALKED_IN_STEP;
        }

        int targetDistance = Rand.nextInt(MIN_TILES_WALKED_IN_STEP, nextTileIdx);
        return step(reachablePath.get(targetDistance));
    }

    public static List<WorldPoint> reachablePath(List<WorldPoint> remainingPath)
    {
        Player local = Players.getLocal();
        List<WorldPoint> out = new ArrayList<>();
        for (WorldPoint p : remainingPath)
        {
            Tile tile = Tiles.getAt(p);
            if (tile == null)
            {
                break;
            }

            out.add(p);
        }

        if (out.isEmpty() || out.size() == 1 && out.get(0).equals(local.getWorldLocation()))
        {
            return Collections.emptyList();
        }

        return out;
    }

    public static boolean step(WorldPoint destination)
    {
        Player local = Players.getLocal();
        log.debug("Stepping towards " + destination);
        Movement.walk(destination);

        if (local.getWorldLocation().equals(destination))
        {
            return false;
        }

        if (!Movement.isRunEnabled() && (Movement.getRunEnergy() >= Rand.nextInt(MIN_ENERGY, MAX_MIN_ENERGY) || (local.getHealthScale() > -1 && Movement.getRunEnergy() > 0)))
        {
            Movement.toggleRun();
            Time.sleepUntil(Movement::isRunEnabled, 2000);
            return true;
        }

        if (!Movement.isRunEnabled() && Movement.getRunEnergy() > 0 && Movement.isStaminaBoosted())
        {
            Movement.toggleRun();
            Time.sleepUntil(Movement::isRunEnabled, 2000);
            return true;
        }

        // Handles when stuck on those trees next to draynor manor
        if (!local.isMoving())
        {
            NPC tree = NPCs.getNearest(n -> n.getId() == NpcID.TREE_4416 && n.getInteracting() == local && n.getWorldLocation().distanceTo2D(local.getWorldLocation()) <= 1);
            if (tree != null)
            {
                WorldArea area = local.getWorldLocation().dx(-1).dy(-1).createWorldArea(3, 3);
                area.toWorldPointList().stream()
                        .filter(wp -> !wp.equals(local.getWorldLocation()) && !wp.equals(tree.getWorldLocation()) && canPathTo(local.getWorldLocation(), wp))
                        .unordered()
                        .min(Comparator.comparingInt(wp -> wp.distanceTo2D(tree.getWorldLocation())))
                        .ifPresent(Movement::walk);
                return false;
            }
        }

        return true;
    }

    public static boolean handleTransports(List<WorldPoint> path, Map<WorldPoint, List<Transport>> transports)
    {
        // Edgeville/ardy wilderness lever warning
        Widget leverWarningWidget = Widgets.get(229, 1);
        if (Widgets.isVisible(leverWarningWidget))
        {
            log.debug("Handling Wilderness lever warning widget");
            Dialog.continueSpace();
            return true;
        }

        // Wilderness ditch warning
        Widget wildyDitchWidget = Widgets.get(475, 11);
        if (Widgets.isVisible(wildyDitchWidget))
        {
            log.debug("Handling Wilderness warning widget");
            wildyDitchWidget.interact("Enter Wilderness");
            return true;
        }

        if (Dialog.getOptions().stream()
                .anyMatch(widget -> widget.getText() != null && widget.getText().contains("Eeep! The Wilderness")))
        {
            log.debug("Handling wilderness warning dialog");
            Dialog.chooseOption("Yes, I'm brave");
            return true;
        }

        for (int i = 0; i < MAX_INTERACT_DISTANCE; i++)
        {
            if (i + 1 >= path.size())
            {
                break;
            }

            WorldPoint a = path.get(i);
            WorldPoint b = path.get(i + 1);

            Tile tileA = Tiles.getAt(a);
            Tile tileB = Tiles.getAt(b);

            if (a.distanceTo(b) > 1
                    || (tileA != null && tileB != null && !Reachable.isWalkable(b)))
            {
                Transport transport = transports.getOrDefault(a, List.of()).stream()
                        .filter(x -> x.getSource().equals(a) && x.getDestination().equals(b))
                        .findFirst()
                        .orElse(null);

                if (transport != null)
                {
                    if (ignoreObstacle(transport.getSource(), 2))
                    {
                        return true;
                    }
                    log.debug("Trying to use transport at {} to move {} -> {}", transport.getSource(), a, b);
                    transport.getHandler().run();
                    Time.sleepTick();
                    return true;
                }
            }

            // MLM Rocks
            TileObject rockfall = TileObjects.getFirstAt(a, "Rockfall");
            boolean hasPickaxe = Inventory.contains(Predicates.nameContains("pickaxe")) || Equipment.contains(Predicates.nameContains("pickaxe"));
            if (rockfall != null && hasPickaxe)
            {
                log.debug("Handling MLM rockfall");
                if (!Players.getLocal().isIdle())
                {
                    return true;
                }
                rockfall.interact("Mine");
                return true;
            }

            if (tileA == null)
            {
                return false;
            }

            // Diagonal door bullshit
            if (Math.abs(a.getX() - b.getX()) + Math.abs(a.getY() + b.getY()) > 1 && a.getPlane() == b.getPlane())
            {
                TileObject wall = TileObjects.getFirstAt(tileA, it ->
                        !(it instanceof WallObject) && it.getName() != null && it.getName().equals("Door")
                );
                if (wall != null && wall.hasAction("Open"))
                {
                    if (ignoreObstacle(wall.getWorldLocation(), 1))
                    {
                        return true;
                    }
                    log.debug("Handling diagonal door at {}", wall.getWorldLocation());
                    wall.interact("Open");
                    Time.sleepUntil(() -> !wall.hasAction("Open"), 2000);
                    return true;
                }
            }

            if (tileB == null)
            {
                return false;
            }

            // Normal doors
            if (Reachable.isDoored(tileA, tileB))
            {
                WallObject wall = tileA.getWallObject();
                if (ignoreObstacle(wall.getWorldLocation(), 1))
                {
                    return true;
                }
                wall.interact("Open");
                log.debug("Handling door at {}", wall.getWorldLocation());
                Time.sleepUntil(() -> tileA.getWallObject() == null
                        || !wall.hasAction("Open"), 2000);
                return true;
            }

            if (Reachable.isDoored(tileB, tileA))
            {
                WallObject wall = tileB.getWallObject();
                if (ignoreObstacle(wall.getWorldLocation(), 1))
                {
                    return true;
                }
                wall.interact("Open");
                log.debug("Handling door at {}", wall.getWorldLocation());
                Time.sleepUntil(() -> tileB.getWallObject() == null
                        || !wall.hasAction("Open"), 2000);
                return true;
            }
        }

        return false;
    }

    private static boolean ignoreObstacle(WorldPoint point, int distance)
    {
        if (Players.getLocal().isMoving())
        {
            LocalPoint localDesti = Static.getClient().getLocalDestinationLocation();
            if (localDesti != null)
            {
                WorldPoint desti = WorldPoint.fromLocal(Static.getClient(), localDesti);
                return desti.distanceTo2D(point) <= distance;
            }
        }
        return false;
    }

    public static WorldPoint nearestWalkableTile(WorldPoint source, Predicate<WorldPoint> filter)
    {
        CollisionMap cm = Static.getGlobalCollisionMap();

        if (!cm.fullBlock(source) && filter.test(source))
        {
            return source;
        }

        int currentIteration = 1;
        for (int radius = currentIteration; radius < MAX_NEAREST_SEARCH_ITERATIONS; radius++)
        {
            for (int x = -radius; x < radius; x++)
            {
                for (int y = -radius; y < radius; y++)
                {
                    WorldPoint p = source.dx(x).dy(y);
                    if (cm.fullBlock(p) || !filter.test(p))
                    {
                        continue;
                    }
                    return p;
                }
            }
        }
        log.debug("Could not find a walkable tile near {}", source);
        return null;
    }

    public static WorldPoint nearestWalkableTile(WorldPoint source)
    {
        return nearestWalkableTile(source, x -> true);
    }

    public static List<WorldPoint> remainingPath(List<WorldPoint> path)
    {
        Player local = Static.getClient().getLocalPlayer();
        if (local == null)
        {
            return Collections.emptyList();
        }

        var nearest = path.stream().min(Comparator.comparingInt(x -> x.distanceTo(local.getWorldLocation())))
                .orElse(null);
        if (nearest == null)
        {
            return Collections.emptyList();
        }

        return path.subList(path.indexOf(nearest), path.size());
    }

    public static List<WorldPoint> calculatePath(WorldArea destination)
    {
        Player local = Players.getLocal();
        LinkedHashMap<WorldPoint, Teleport> teleports = buildTeleportLinks(destination);
        List<WorldPoint> startPoints = new ArrayList<>(teleports.keySet());
        startPoints.add(local.getWorldLocation());
        return calculatePath(startPoints, destination);
    }

    public static List<WorldPoint> calculatePath(List<WorldPoint> startPoints, WorldArea destination)
    {
        if (Static.getClient().isClientThread())
        {
            throw new RuntimeException("Calculate path cannot be called on client thread");
        }
        return new Pathfinder(Static.getGlobalCollisionMap(), buildTransportLinks(), startPoints, destination, RegionManager.avoidWilderness()).find();
    }

    public static List<WorldPoint> calculatePath(WorldPoint destination)
    {
        return calculatePath(destination.toWorldArea());
    }

    public static List<WorldPoint> calculatePath(List<WorldPoint> startPoints, WorldPoint destination)
    {
        return calculatePath(startPoints, destination.toWorldArea());
    }

    private static List<WorldPoint> buildPath(
            List<WorldPoint> startPoints,
            WorldArea destination,
            boolean avoidWilderness,
            boolean forced
    )
    {
        if (pathFuture == null)
        {
            pathFuture = executor.submit(new Pathfinder(Static.getGlobalCollisionMap(), buildTransportLinks(), startPoints, destination, avoidWilderness));
            currentDestination = destination;
        }

        boolean sameDestination = currentDestination != null
                && destination.getX() == currentDestination.getX()
                && destination.getY() == currentDestination.getY()
                && destination.getPlane() == currentDestination.getPlane()
                && destination.getWidth() == currentDestination.getWidth()
                && destination.getHeight() == currentDestination.getHeight();
        boolean shouldRefresh = RegionManager.shouldRefreshPath();

		if (shouldRefresh)
		{
			log.debug("Path should refresh!");
		}

        if (!sameDestination || shouldRefresh || forced)
        {
            log.debug("Cancelling current path");
            pathFuture.cancel(true);
            pathFuture = executor.submit(new Pathfinder(Static.getGlobalCollisionMap(), buildTransportLinks(), startPoints, destination, avoidWilderness));
            currentDestination = destination;
        }

        try
        {
            if (Static.getClient().isClientThread())
            {
                // 16-17ms for 60fps, 6-7ms for 144fps
                return pathFuture.get(10, TimeUnit.MILLISECONDS);
            }
            return pathFuture.get();
        }
        catch (Exception e)
        {
            log.debug("Path is loading");
            return List.of();
        }
    }

    public static List<WorldPoint> buildPath()
    {
        if (currentDestination == null)
        {
            return List.of();
        }
        return buildPath(currentDestination);
    }

    public static List<WorldPoint> buildPath(WorldArea destination, boolean avoidWilderness, boolean forced)
    {
        Player local = Players.getLocal();
        LinkedHashMap<WorldPoint, Teleport> teleports = buildTeleportLinks(destination);
        List<WorldPoint> startPoints = new ArrayList<>(teleports.keySet());
        startPoints.add(local.getWorldLocation());

        return buildPath(startPoints, destination, avoidWilderness, forced);
    }

    public static List<WorldPoint> buildPath(WorldArea destination)
    {
        return buildPath(destination, RegionManager.avoidWilderness(), false);
    }

    public static List<WorldPoint> buildPath(WorldArea destination, boolean forced)
    {
        return buildPath(destination, RegionManager.avoidWilderness(), forced);
    }

    public static List<WorldPoint> buildPath(WorldPoint destination)
    {
        return buildPath(destination.toWorldArea());
    }

    public static List<WorldPoint> buildPath(WorldPoint destination, boolean forced)
    {
        return buildPath(destination.toWorldArea(), forced);
    }

    public static List<WorldPoint> buildPath(WorldPoint destination, boolean avoidWilderness, boolean forced)
    {
        return buildPath(destination.toWorldArea(), avoidWilderness, forced);
    }

    public static List<WorldPoint> buildPath(List<WorldPoint> startPoints, WorldPoint destination, boolean avoidWilderness, boolean forced)
    {
        return buildPath(startPoints, destination.toWorldArea(), avoidWilderness, forced);
    }

    public static Map<WorldPoint, List<Transport>> buildTransportLinks()
    {
        Map<WorldPoint, List<Transport>> out = new HashMap<>();
        if (!Static.getUnethicaliteConfig().useTransports())
        {
            return out;
        }

        for (Transport transport : TransportLoader.buildTransports())
        {
            out.computeIfAbsent(transport.getSource(), x -> new ArrayList<>()).add(transport);
        }

        return out;
    }

    public static LinkedHashMap<WorldPoint, Teleport> buildTeleportLinks(WorldArea destination)
    {
        LinkedHashMap<WorldPoint, Teleport> out = new LinkedHashMap<>();
        if (!Static.getUnethicaliteConfig().useTeleports())
        {
            return out;
        }

        Player local = Players.getLocal();

        for (Teleport teleport : TeleportLoader.buildTeleports())
        {
            if (teleport.getDestination().distanceTo(local.getWorldLocation()) > 50
                    && destination.distanceTo(local) > destination.distanceTo(teleport.getDestination()) + 20)
            {
                out.putIfAbsent(teleport.getDestination(), teleport);
            }
        }

        return out;
    }

    public static Map<WorldPoint, List<Transport>> buildTransportLinksOnPath(List<WorldPoint> path)
    {
        Map<WorldPoint, List<Transport>> out = new HashMap<>();
        for (Transport transport : TransportLoader.buildTransports())
        {
            WorldPoint destination = transport.getDestination();
            if (path.contains(destination))
            {
                out.computeIfAbsent(transport.getSource(), x -> new ArrayList<>()).add(transport);
            }
        }
        return out;
    }

    public static LinkedHashMap<WorldPoint, Teleport> buildTeleportLinksOnPath(List<WorldPoint> path)
    {
        LinkedHashMap<WorldPoint, Teleport> out = new LinkedHashMap<>();
        for (Teleport teleport : TeleportLoader.buildTeleports())
        {
            WorldPoint destination = teleport.getDestination();
            if (path.contains(destination))
            {
                out.putIfAbsent(destination, teleport);
            }
        }
        return out;
    }

    public static boolean canPathTo(WorldPoint start, WorldPoint destination)
    {
        List<WorldPoint> pathTo = start.pathTo(Static.getClient(), destination);
        return pathTo != null && pathTo.contains(destination);
    }
}

package net.unethicalite.api.script.blocking_events;

import net.runelite.api.MenuAction;
import net.runelite.api.widgets.Widget;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;

public class WelcomeScreenEvent extends BlockingEvent
{
	@Override
	public boolean validate()
	{
		return isWelcomeScreenOpen();
	}

	@Override
	public int loop()
	{
		Widget playButton = getPlayButton();
		if (playButton != null)
		{
			Static.getClient().interact(1, MenuAction.CC_OP.getId(), -1, playButton.getId());
		}

		return -1;
	}

	public static Widget getPlayButton()
	{
		Widget nu = Widgets.get(413, x -> x.hasAction("Play"));
		if (Widgets.isVisible(nu))
		{
			return nu;
		}

		Widget old = Widgets.get(378, x -> x.hasAction("Play"));
		if (Widgets.isVisible(old))
		{
			return old;
		}

		return null;
	}

	public static boolean isWelcomeScreenOpen()
	{
		return Widgets.isVisible(Widgets.get(378, x -> x.hasAction("Play")))
				|| Widgets.isVisible(Widgets.get(413, x -> x.hasAction("Play")));
	}
}

package net.unethicalite.api.packets;

import net.runelite.api.packets.PacketBufferNode;
import net.runelite.api.widgets.Widget;
import net.unethicalite.api.game.Game;
import net.unethicalite.client.Static;

public class WidgetPackets
{
	public static void widgetFirstOption(Widget widget)
	{
		queueWidgetAction1Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetSecondOption(Widget widget)
	{
		queueWidgetAction2Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetThirdOption(Widget widget)
	{
		queueWidgetAction3Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetFourthOption(Widget widget)
	{
		queueWidgetAction4Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetFifthOption(Widget widget)
	{
		queueWidgetAction5Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetSixthOption(Widget widget)
	{
		queueWidgetAction6Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetSeventhOption(Widget widget)
	{
		queueWidgetAction7Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetEighthOption(Widget widget)
	{
		queueWidgetAction8Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetNinthOption(Widget widget)
	{
		queueWidgetAction9Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetTenthOption(Widget widget)
	{
		queueWidgetAction10Packet(widget.getId(), widget.getItemId(), widget.getIndex());
	}

	public static void widgetItemAction(net.runelite.api.widgets.WidgetInfo container, net.runelite.api.Item item, String action)
	{
		var index = item.getActionIndex(action);
		widgetItemAction(container, item, index);
	}

	public static void widgetItemAction(net.runelite.api.widgets.WidgetInfo container, net.runelite.api.Item item, int index)
	{
		var widgetPackedId = container.getPackedId();
		var itemId = item.getId();
		var itemSlot = item.getSlot();
		switch (index)
		{
			case 0:
				queueWidgetAction1Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 1:
				queueWidgetAction2Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 2:
				queueWidgetAction3Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 3:
				queueWidgetAction4Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 4:
				queueWidgetAction5Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 5:
				queueWidgetAction6Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 6:
				queueWidgetAction7Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 7:
				queueWidgetAction8Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 8:
				queueWidgetAction9Packet(widgetPackedId, itemId, itemSlot);
				break;
			case 9:
				queueWidgetAction10Packet(widgetPackedId, itemId, itemSlot);
				break;
		}
	}

	public static void widgetAction(Widget widget, String action)
	{
		var index = widget.getActionIndex(action);
		switch (index)
		{
			case 0:
				widgetFirstOption(widget);
				break;
			case 1:
				widgetSecondOption(widget);
				break;
			case 2:
				widgetThirdOption(widget);
				break;
			case 3:
				widgetFourthOption(widget);
				break;
			case 4:
				widgetFifthOption(widget);
				break;
			case 5:
				widgetSixthOption(widget);
				break;
			case 6:
				widgetSeventhOption(widget);
				break;
			case 7:
				widgetEighthOption(widget);
				break;
			case 8:
				widgetNinthOption(widget);
				break;
			case 9:
				widgetTenthOption(widget);
				break;
		}
	}

	public static void queueWidgetAction1Packet(int widgetId, int itemId, int childId)
	{
		createFirstAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction2Packet(int widgetId, int itemId, int childId)
	{
		createSecondAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction3Packet(int widgetId, int itemId, int childId)
	{
		createThirdAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction4Packet(int widgetId, int itemId, int childId)
	{
		createFourthAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction5Packet(int widgetId, int itemId, int childId)
	{
		createFifthAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction6Packet(int widgetId, int itemId, int childId)
	{
		createSixthAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction7Packet(int widgetId, int itemId, int childId)
	{
		createSeventhAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction8Packet(int widgetId, int itemId, int childId)
	{
		createEighthAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction9Packet(int widgetId, int itemId, int childId)
	{
		createNinthAction(widgetId, itemId, childId).send();
	}

	public static void queueWidgetAction10Packet(int widgetId, int itemId, int childId)
	{
		createTenthAction(widgetId, itemId, childId).send();
	}

	public static void queueResumePauseWidgetPacket(int widgetId, int childId)
	{
		createContinuePacket(widgetId, childId).send();
	}

	public static void queueWidgetOnWidgetPacket(int sourceWidgetId, int sourceSlot, int sourceItemId, int destinationWidgetId, int destinationSlot, int destinationItemId)
	{
		createWidgetOnWidget(sourceWidgetId, sourceSlot, sourceItemId, destinationWidgetId, destinationSlot, destinationItemId).send();
	}

	public static void queueResumeObjectPacket(int itemId)
	{
		createContinueObjectPacket(itemId).send();
	}

	public static void queueWidgetTypePacket(int widgetId)
	{
		createWidgetTypePacket(widgetId).send();
	}

	// Removed?
	public static PacketBufferNode createType1Action(int widgetId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packet = client.preparePacket(clientPacket.IF_BUTTON10(), client.getPacketWriter().getIsaacCipher());
		packet.getPacketBuffer().writeInt(widgetId);
		return packet;
	}

	public static PacketBufferNode createDefaultAction(int type, int widgetPackedId, int itemId, int itemSlot)
	{
		switch (type)
		{
			case 1:
				return createFirstAction(widgetPackedId, itemId, itemSlot);
			case 2:
				return createSecondAction(widgetPackedId, itemId, itemSlot);
			case 3:
				return createThirdAction(widgetPackedId, itemId, itemSlot);
			case 4:
				return createFourthAction(widgetPackedId, itemId, itemSlot);
			case 5:
				return createFifthAction(widgetPackedId, itemId, itemSlot);
			case 6:
				return createSixthAction(widgetPackedId, itemId, itemSlot);
			case 7:
				return createSeventhAction(widgetPackedId, itemId, itemSlot);
			case 8:
				return createEighthAction(widgetPackedId, itemId, itemSlot);
			case 9:
				return createNinthAction(widgetPackedId, itemId, itemSlot);
			case 10:
				return createTenthAction(widgetPackedId, itemId, itemSlot);
		}
		throw new IllegalArgumentException("Invalid widget action type: " + type);
	}

	public static PacketBufferNode createFirstAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON1(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createSecondAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON2(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createThirdAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON3(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createFourthAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON4(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createFifthAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON5(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createSixthAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON6(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createSeventhAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON7(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createEighthAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON8(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createNinthAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON9(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createTenthAction(int widgetId, int itemId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTON10(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		packetBufferNode.getPacketBuffer().writeShort(childId);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createWidgetOnWidget(int sourceWidgetId, int sourceSlot, int sourceItemId, int itemId, int destinationSlot, int widgetId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.IF_BUTTONT(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShortLE(destinationSlot);
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		packetBufferNode.getPacketBuffer().writeIntME(sourceWidgetId);
		packetBufferNode.getPacketBuffer().writeShortAddLE(sourceSlot);
		packetBufferNode.getPacketBuffer().writeIntIME(widgetId);
		packetBufferNode.getPacketBuffer().writeShortAdd(sourceItemId);
		return packetBufferNode;
	}

	public static PacketBufferNode createContinuePacket(int widgetId, int childId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.RESUME_PAUSEBUTTON(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeIntME(widgetId);
		packetBufferNode.getPacketBuffer().writeShortLE(childId);
		return packetBufferNode;
	}

	public static PacketBufferNode createContinueObjectPacket(int itemId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.RESUME_OBJDIALOG(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeShort(itemId);
		return packetBufferNode;
	}

	/*
	Not entirely sure what the correct naming for this packet would be.
	But here's an example of how it's used.
	Example is at the tannery.
	Each menu option appears to have its own widget and Widget ID.
	https://i.imgur.com/OTmM4yQ.png
	 */
	public static PacketBufferNode createWidgetTypePacket(int widgetId)
	{
		var client = Static.getClient();
		var clientPacket = Game.getClientPacket();
		var packetBufferNode = Static.getClient().preparePacket(clientPacket.WIDGET_TYPE(), client.getPacketWriter().getIsaacCipher());
		packetBufferNode.getPacketBuffer().writeInt(widgetId);
		return packetBufferNode;
	}
}
package net.unethicalite.api.query.widgets;

import net.unethicalite.api.commons.Predicates;
import net.unethicalite.api.query.Query;
import net.unethicalite.api.query.results.WidgetQueryResults;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.ArrayUtils;

import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;

public class WidgetQuery extends Query<Widget, WidgetQuery, WidgetQueryResults>
{
	private int[] widgetIds = null;
	private int[] types = null;
	private String[] texts = null;
	private String[] actions = null;
	private Boolean visible = null;

	public WidgetQuery(Supplier<List<Widget>> supplier)
	{
		super(supplier);
	}

	@Override
	protected WidgetQueryResults results(List<Widget> list)
	{
		return new WidgetQueryResults(list);
	}

	public WidgetQuery ids(int... ids)
	{
		this.widgetIds = ids;
		return this;
	}

	public WidgetQuery types(int... types)
	{
		this.types = types;
		return this;
	}

	public WidgetQuery texts(String... texts)
	{
		this.texts = texts;
		return this;
	}

	public WidgetQuery actions(String... actions)
	{
		this.actions = actions;
		return this;
	}

	public WidgetQuery visible(Boolean visible)
	{
		this.visible = visible;
		return this;
	}

	@Override
	public boolean test(Widget widget)
	{
		if (widgetIds != null && !ArrayUtils.contains(widgetIds, widget.getId()))
		{
			return false;
		}

		if (types != null && !ArrayUtils.contains(types, widget.getType()))
		{
			return false;
		}

		if (texts != null && !ArrayUtils.contains(texts, widget.getText()))
		{
			return false;
		}

		if (actions != null && Arrays.stream(actions).noneMatch(Predicates.texts(widget.getActions())))
		{
			return false;
		}

		if (visible != null && visible != widget.isVisible())
		{
			return false;
		}

		return super.test(widget);
	}
}

package net.unethicalite.api.query.results;

import net.runelite.api.widgets.Widget;

import java.util.List;

public class WidgetQueryResults extends QueryResults<Widget, WidgetQueryResults>
{
	public WidgetQueryResults(List<Widget> results)
	{
		super(results);
	}
}

package net.unethicalite.api.widgets;

import net.unethicalite.api.query.widgets.WidgetQuery;
import net.unethicalite.client.Static;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class Widgets
{
	public static WidgetQuery query()
	{
		return new WidgetQuery(() -> Arrays.stream(Static.getClient().getWidgets())
				.flatMap(Arrays::stream)
				.collect(Collectors.toList()));
	}

	public static WidgetQuery query(int group)
	{
		return new WidgetQuery(() -> get(group));
	}

	public static Widget get(WidgetInfo widgetInfo)
	{
		return Static.getClient().getWidget(widgetInfo);
	}

	public static Widget get(int group, int id)
	{
		return Static.getClient().getWidget(group, id);
	}

	public static Widget get(int group, int id, int child)
	{
		return get(group, id) == null ? null : get(group, id).getChild(child);
	}

	public static List<Widget> get(int group)
	{
		Widget[][] all = Static.getClient().getWidgets();
		if (all == null)
		{
			return Collections.emptyList();
		}

		Widget[] widgets = all[group];
		if (widgets == null)
		{
			return Collections.emptyList();
		}

		return Arrays.asList(widgets);
	}

	public static Widget get(int group, Predicate<Widget> filter)
	{
		return get(group).stream().filter(filter).findFirst().orElse(null);
	}

	public static List<Widget> getChildren(Widget widget, Predicate<Widget> filter)
	{
		if (widget == null)
		{
			return Collections.emptyList();
		}

		Widget[] children = widget.getChildren();
		if (children == null)
		{
			return Collections.emptyList();
		}

		return Arrays.stream(children).filter(filter).collect(Collectors.toList());
	}

	public static List<Widget> getChildren(WidgetInfo widgetInfo, Predicate<Widget> filter)
	{
		return getChildren(get(widgetInfo), filter);
	}

	public static List<Widget> getChildren(int group, int child, Predicate<Widget> filter)
	{
		return getChildren(get(group, child), filter);
	}

	public static List<Widget> getAll(int group, Predicate<Widget> filter)
	{
		return get(group).stream().filter(filter).collect(Collectors.toList());
	}

	public static Widget fromId(int packedId)
	{
		return Static.getClient().getWidget(packedId);
	}

	public static boolean isVisible(Widget widget)
	{
		return widget != null && widget.isVisible();
	}
}

package net.unethicalite.api.movement.pathfinder.model.requirement;

import lombok.Value;
import net.unethicalite.api.game.Worlds;

@Value
public class WorldRequirement implements Requirement
{
    boolean memberWorld;

    @Override
    public Boolean get()
    {
        return !memberWorld || Worlds.inMembersWorld();
    }
}
package net.unethicalite.api.game;

import net.unethicalite.api.commons.Rand;
import net.unethicalite.api.commons.Time;
import net.unethicalite.api.widgets.Dialog;
import net.unethicalite.api.widgets.Tab;
import net.unethicalite.api.widgets.Tabs;
import net.unethicalite.api.widgets.Widgets;
import net.unethicalite.client.Static;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.World;
import net.runelite.api.WorldType;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.http.api.worlds.WorldResult;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.function.Predicate;

@Slf4j
public class Worlds
{
	private static List<World> lookup()
	{
		List<World> out = new ArrayList<>();
		WorldResult lookup = Static.getWorldService().getWorlds();
		if (lookup == null)
		{
			return Collections.emptyList();
		}

		lookup.getWorlds().forEach(w ->
		{
			World world = Static.getClient().createWorld();
			world.setActivity(w.getActivity());
			world.setAddress(w.getAddress());
			world.setId(w.getId());
			world.setPlayerCount(w.getPlayers());
			world.setLocation(w.getLocation());
			EnumSet<WorldType> types = EnumSet.noneOf(WorldType.class);
			w.getTypes().stream().map(Worlds::toApiWorldType).forEach(types::add);
			world.setTypes(types);
			out.add(world);
		});

		Static.getClient().setWorldList(out.toArray(new World[0]));

		return out;
	}

	public static List<World> getAll(Predicate<World> filter)
	{
		List<World> out = new ArrayList<>();
		List<World> loadedWorlds;

		try
		{
			World[] worlds = Static.getClient().getWorldList();
			if (worlds == null)
			{
				loadWorlds();
				return out;
			}

			loadedWorlds = Arrays.asList(worlds);
		}
		catch (Exception e)
		{
			log.warn("Game couldn't load worlds, falling back to RuneLite API.");
			loadedWorlds = lookup();
		}

		for (World world : loadedWorlds)
		{
			if (filter.test(world))
			{
				out.add(world);
			}
		}

		return out;
	}

	public static World getFirst(Predicate<World> filter)
	{
		return getAll(filter)
				.stream()
				.findFirst()
				.orElse(null);
	}

	public static World getFirst(int id)
	{
		return getFirst(x -> x.getId() == id);
	}

	public static World getRandom(Predicate<World> filter)
	{
		List<World> all = getAll(filter);
		if (all.isEmpty())
		{
			return null;
		}

		return all.get(Rand.nextInt(0, all.size()));
	}

	public static int getCurrentId()
	{
		return Static.getClient().getWorld();
	}

	public static void hopTo(World world)
	{
		hopTo(world, false);
	}

	public static void hopTo(World world, boolean spam)
	{
		if (!isHopperOpen())
		{
			openHopper();
			Time.sleepUntil(Worlds::isHopperOpen, 3000);
		}

		Widget rememberOption = Dialog.getOptions().stream()
				.filter(x -> x.getText().contains("Yes. In future, only warn about"))
				.findFirst()
				.orElse(null);
		if (Widgets.isVisible(rememberOption))
		{
			Dialog.chooseOption(2);
			Time.sleepUntil(() -> Game.getState() == GameState.HOPPING, 3000);
			return;
		}

		log.debug("Hoping to world {}", world.getId());
		Static.getClient().interact(1, MenuAction.CC_OP.getId(), world.getId(), WidgetInfo.WORLD_SWITCHER_LIST.getId());
		if (!spam)
		{
			Time.sleepUntil(() -> Game.getState() == GameState.HOPPING, 3000);
		}

		if (Dialog.isViewingOptions())
		{
			Dialog.chooseOption(2);
			Time.sleepUntil(() -> Game.getState() == GameState.HOPPING, 3000);
		}
	}

	public static World getCurrentWorld()
	{
		return getFirst(Static.getClient().getWorld());
	}

	public static boolean inMembersWorld()
	{
		return inMembersWorld(false);
	}

	public static boolean inMembersWorld(boolean useLookUp)
	{
		if (useLookUp)
		{
			World currentWorld = lookup().stream()
					.filter(x -> x.getId() == getCurrentId())
					.findFirst()
					.orElse(null);
			if (currentWorld != null)
			{
				return currentWorld.isMembers();
			}
		}
		return Static.getClient().isMembersWorld();
	}

	public static void loadWorlds()
	{
		if (Game.isOnLoginScreen())
		{
			openLobbyWorlds();
			Time.sleep(200);
			closeLobbyWorlds();
			return;
		}

		if (Game.isLoggedIn())
		{
			openHopper();
		}
	}

	public static void openHopper()
	{
		if (!Tabs.isOpen(Tab.LOG_OUT))
		{
			Tabs.open(Tab.LOG_OUT);
		}

		Static.getClient().interact(1, MenuAction.CC_OP.getId(), -1, WidgetInfo.WORLD_SWITCHER_BUTTON.getId());
	}

	public static void openLobbyWorlds()
	{
		Static.getClient().loadWorlds();
		Static.getClient().setWorldSelectOpen(true);
	}

	public static void closeLobbyWorlds()
	{
		Static.getClient().setWorldSelectOpen(false);
	}

	public static boolean isHopperOpen()
	{
		return Widgets.isVisible(Widgets.get(WidgetInfo.WORLD_SWITCHER_LIST));
	}

	private static WorldType toApiWorldType(net.runelite.http.api.worlds.WorldType httpWorld)
	{
		if (httpWorld == net.runelite.http.api.worlds.WorldType.TOURNAMENT)
		{
			return WorldType.TOURNAMENT_WORLD;
		}

		return WorldType.valueOf(httpWorld.name());
	}
}

